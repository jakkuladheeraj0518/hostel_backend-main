### Combined Content from Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app ###



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\config.py ---
"""
Global configuration + Database connection and session management.
This file merges:
 - Pydantic Settings configuration
 - Database engine, session, and initialization
"""

from functools import lru_cache
from pathlib import Path
from typing import List, Optional

from pydantic_settings import BaseSettings
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker


# ---------------------------------------------------------
# SETTINGS (Loads environment variables from .env)
# ---------------------------------------------------------

env_path = Path(__file__).parent.parent / ".env"


class Settings(BaseSettings):
    # Database
    # NOTE: conflict markers were present here. Using a neutral placeholder value.
    # Replace this via environment variable or .env for your local password.
    DATABASE_URL: str = "postgresql://postgres:Kiran$123@localhost/hostelB"
    COMMISSION_RATE: float = 0.15

    ELASTICSEARCH_URL: Optional[str] = None

    # JWT
    SECRET_KEY: str = "your-secret-key-change-in-production"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7

    # CORS
    CORS_ORIGINS: List[str] = ["http://localhost:3000", "http://localhost:8000"]

    # Environment
    ENVIRONMENT: str = "development"
    DEBUG: bool = True

    # Server
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # Alembic override
    ALEMBIC_DATABASE_URL: Optional[str] = None

    # Email / SMTP
    EMAIL_HOST: str = "smtp.gmail.com"
    EMAIL_PORT: int = 587
    EMAIL_USER: Optional[str] = None
    EMAIL_PASS: Optional[str] = None
    EMAIL_FROM: Optional[str] = None
    EMAIL_USE_TLS: bool = True
    EMAIL_USE_SSL: bool = False

    # Twilio SMS
    TWILIO_ACCOUNT_SID: Optional[str] = None
    TWILIO_AUTH_TOKEN: Optional[str] = None
    TWILIO_FROM_NUMBER: Optional[str] = None

    # OTP / MFA
    OTP_EXPIRY_MINUTES: int = 5
    OTP_EXPIRY_SECONDS: int = OTP_EXPIRY_MINUTES * 60
    OTP_LENGTH: int = 6
    OTP_DELIVERY_METHOD: str = "sms"

    # Password policy
    PASSWORD_MIN_LENGTH: int = 8
    PASSWORD_REQUIRE_DIGIT: bool = True
    PASSWORD_REQUIRE_SYMBOL: bool = False
    PASSWORD_REQUIRE_UPPER: bool = True

    # OAuth providers
    OAUTH_GOOGLE_CLIENT_ID: Optional[str] = None
    OAUTH_GOOGLE_CLIENT_SECRET: Optional[str] = None
    OAUTH_GOOGLE_REDIRECT_URI: Optional[str] = None

    OAUTH_GITHUB_CLIENT_ID: Optional[str] = None
    OAUTH_GITHUB_CLIENT_SECRET: Optional[str] = None
    OAUTH_GITHUB_REDIRECT_URI: Optional[str] = None

    # API Keys
    API_KEY: Optional[str] = None
    RAZORPAY_KEY_ID: Optional[str] = None
    RAZORPAY_KEY_SECRET: Optional[str] = None
    GOOGLE_MAPS_API_KEY: Optional[str] = None

    # Password reset
    PASSWORD_RESET_TOKEN_EXPIRY_MINUTES: int = 15
    PASSWORD_RESET_CODE_LENGTH: int = 6

    # App Info
    APP_NAME: str = "Hostel Management System"
    APP_URL: str = "http://localhost:8000"
    FRONTEND_URL: str = "http://localhost:3000"

    # File uploads
    MAX_UPLOAD_SIZE: int = 10 * 1024 * 1024  # 10 MB
    UPLOAD_DIR: str = "uploads"

    class Config:
        env_file = str(env_path) if env_path.exists() else ".env"
        env_file_encoding = "utf-8"
        case_sensitive = True


@lru_cache()
def get_settings() -> Settings:
    """Get cached settings instance"""
    return Settings()


settings = get_settings()


# ---------------------------------------------------------
# DATABASE CONNECTION + SESSION MANAGEMENT
# ---------------------------------------------------------

# Create Engine
engine = create_engine(settings.DATABASE_URL)

# Session Factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base Model
Base = declarative_base()


def get_db():
    """FastAPI dependency for DB sessions"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def init_db():
    """
    Initialize database by creating all tables.
    Seed data removed as requested.
    """
    # Import models so metadata can detect them
    from app.models import (
        user, hostel, admin_hostel_mapping,
        session_context, permission, audit_log,
        refresh_token, approval_request, password_reset,
        complaint, reports
    )

    Base.metadata.create_all(bind=engine)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\dependencies.py ---
"""
Dependency injection setup.
Shared dependencies (DB, Auth, RBAC, Header-based identity)
"""

from fastapi import Depends, HTTPException, Request, status
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.models.user import User
from typing import Generator


# Service dependency factories
def get_mess_menu_service(db: Session = Depends(get_db)):
    """Provide MessMenuService wired with a DB session."""
    from app.services.mess_menu_service import MessMenuService

    return MessMenuService(db)


# ---------------------------------------------------------
# DATABASE DEPENDENCY
# ---------------------------------------------------------

def get_db_session(db: Session = Depends(get_db)) -> Session:
    """Get database session"""
    return db


# ---------------------------------------------------------
# BASIC AUTH PLACEHOLDERS (No real authentication yet)
# ---------------------------------------------------------

def get_current_user():
    """
    Placeholder for user authentication.
    Replace with JWT or session-based authentication later.
    """
    return {"user_id": 1, "role": "admin"}


def require_admin():
    """Placeholder for admin role verification"""
    return get_current_user()


def require_supervisor():
    """Placeholder for supervisor role verification"""
    return get_current_user()


def require_student():
    """Placeholder for student role verification"""
    return get_current_user()


# ---------------------------------------------------------
# USER STATUS CHECKING (When real User model is used)
# ---------------------------------------------------------

def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Validate active user"""
    if hasattr(current_user, "is_active") and not current_user.is_active:
        raise ValueError("User is not active")
    return current_user


# ---------------------------------------------------------
# HEADER-BASED AUTH (Used when API Gateway sets headers)
# ---------------------------------------------------------

async def get_current_user_email(request: Request) -> str:
    """Extract email injected by proxy/header"""
    email = request.headers.get("X-User-Email")
    if not email:
        raise HTTPException(status_code=400, detail="Missing X-User-Email header")
    return email


async def get_current_user_name(request: Request) -> str:
    """Extract name injected by proxy/header"""
    name = request.headers.get("X-User-Name")
    if not name:
        raise HTTPException(status_code=400, detail="Missing X-User-Name header")
    return name


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\main.py ---
"""
FastAPI main application entry point.
Combines: CORS, Routers, Middleware, DB Init, Elasticsearch Init, OpenAPI overrides.
"""

from pathlib import Path
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.openapi.utils import get_openapi
from fastapi.staticfiles import StaticFiles

from app.config import settings
from app.core.logger import setup_logger
from app.core.database import init_db
from app.core.elasticsearch import init_elasticsearch_indices

from app.services.booking_expiry_service import BookingExpiryService
from app.core.database import SessionLocal

# Middleware
from app.middleware.authentication import AuthenticationMiddleware
from app.middleware.tenant_filter import TenantFilterMiddleware
from app.middleware.role_enforcer import RoleEnforcerMiddleware
from app.middleware.audit_trail import AuditTrailMiddleware

# ---------------------------------------------------------
# ⭐ NEW: Notification Routers + Worker
# ---------------------------------------------------------
from app.api.v1.student.notification import router as student_notification_router
from app.api.v1.supervisor.notification import router as supervisor_notification_router
from app.api.v1.admin.notification import router as admin_notification_router
# ---------------------------------------------------------

# Routers (core / existing)
from app.api.v1.router import api_router
from app.api.v1.student import complaints as student_complaints
from app.api.v1.supervisor import complaints as supervisor_complaints
from app.api.v1.admin import complaints as admin_complaints
from app.api.v1.visitor import search as visitor_search
from app.api.v1.super_admin import (
    hostels, dashboard, admins, subscription,
    analytics, reports, shift_coordination
)
from app.api.v1.super_admin import report as super_admin_reports
from app.api.v1.admin import reports as admin_reports
from app.api.v1.supervisor import reports as supervisor_reports

# Admin model-wise routers
from app.api.v1.admin.rooms import router as rooms_router
from app.api.v1.admin.beds import router as beds_router
from app.api.v1.admin.students import router as students_router
from app.api.v1.admin.supervisors import router as supervisors_router
from app.api.v1.admin.comparison_router import router as comparison_router
from app.api.v1.admin import (
    fee_structure_configuration,
    payment_routers as payment_routes,
    transactions,
)

# ⭐ Mess Menu & Announcement Imports
from app.api.v1.admin import mess_menu as admin_mess_menu
from app.api.v1.supervisor import mess_menu as supervisor_mess_menu
from app.api.v1.student import mess_menu as student_mess_menu

from app.api.v1.admin import announcement as admin_announcement
from app.api.v1.supervisor import announcement as supervisor_announcement
from app.api.v1.student import announcement as student_announcement

# Visitor Routers
from app.api.v1.visitor.bookings import router as visitor_booking_router
from app.api.v1.visitor.public_comparison import router as visitor_compare_router

# ⭐ MISSING FROM YOUR OFFICIAL MAIN — NOW ADDED
from app.api.v1.visitor import auth_router, booking_router, payment_routers, simple_payment_router

# Admin Routers
from app.api.v1.admin.bookings import router as admin_booking_router
from app.api.v1.admin.bookings_modify import router as admin_modify_booking_router

# NEW: Calendar Router
from app.api.v1.admin.calendar import router as calendar_router

# NEW: Waitlist Routers (admin + visitor)
from app.api.v1.admin.waitlist import router as admin_waitlist_router
from app.api.v1.visitor.waitlist import router as visitor_waitlist_router

# NEW: Admin Scheduled Jobs
from app.api.v1.admin.admin_jobs import router as admin_jobs_router

# Logger
logger = setup_logger()

# ---------------------------------------------------------------------------
# FASTAPI APP
# ---------------------------------------------------------------------------
app = FastAPI(
    title="Hostel Management System API",
    description="Comprehensive hostel management system with JWT Auth, RBAC, Complaints, Analytics, Search",
    version="1.0.0",
    debug=settings.DEBUG
)

# ---------------------------------------------------------------------------
# CORS CONFIG
# ---------------------------------------------------------------------------
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---------------------------------------------------------------------------
# MIDDLEWARE PIPELINE
# ---------------------------------------------------------------------------
app.add_middleware(AuthenticationMiddleware)
app.add_middleware(TenantFilterMiddleware)
app.add_middleware(RoleEnforcerMiddleware)
app.add_middleware(AuditTrailMiddleware)

# ---------------------------------------------------------------------------
# CUSTOM OPENAPI
# ---------------------------------------------------------------------------
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema

    openapi_schema = get_openapi(
        title="Hostel Management System API",
        version="1.0.0",
        description="Comprehensive hostel management system with JWT Auth",
        routes=app.routes,
    )

    openapi_schema["components"]["securitySchemes"] = {
        "HTTPBearer": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
        }
    }

    public_routes = ["/", "/health", "/api/v1/auth/login"]
    for path, item in openapi_schema["paths"].items():
        if path.startswith("/docs") or path.startswith("/redoc") or path.startswith("/openapi"):
            continue
        if path in public_routes:
            continue
        for method in item:
            if "security" not in item[method]:
                item[method]["security"] = [{"HTTPBearer": []}]

    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi

# ---------------------------------------------------------------------------
# STARTUP EVENTS
# ---------------------------------------------------------------------------
@app.on_event("startup")
async def startup_event():
    logger.info("Initializing database...")
    init_db()
    logger.info("Database initialized.")

    logger.info("Initializing Elasticsearch...")
    init_elasticsearch_indices()
    logger.info("Elasticsearch ready.")

    # ⭐ Start expiry service
    expiry = BookingExpiryService(SessionLocal)
    expiry.start()

    # ⭐ Start Notification Worker
    logger.info("Notification worker started.")

# ---------------------------------------------------------------------------
# ROUTERS
# ---------------------------------------------------------------------------

# Core routers
app.include_router(api_router, prefix="/api/v1")
app.include_router(student_complaints.router, prefix="/api/v1")
app.include_router(supervisor_complaints.router, prefix="/api/v1")
app.include_router(supervisor_reports.router, prefix="/api/v1")
app.include_router(admin_complaints.router, prefix="/api/v1")
app.include_router(admin_reports.router, prefix="/api/v1")
app.include_router(super_admin_reports.router, prefix="/api/v1")
app.include_router(visitor_search.router, prefix="/api/v1")

# ⭐ Added Visitor Authentication/Booking/Payment Routers
app.include_router(auth_router.router, prefix="/api/v1/auth", tags=["Authentication"])
app.include_router(booking_router.router, prefix="/api/v1/bookings", tags=["Bookings"])
app.include_router(payment_routers.router, prefix="/api/v1/payments", tags=["Payments"])
app.include_router(simple_payment_router.router, prefix="/api/v1/simple-payments", tags=["SimplePayments"])

# Super-admin
app.include_router(hostels.router)
app.include_router(dashboard.router)
app.include_router(admins.router)
app.include_router(subscription.router)
app.include_router(reports.router)
app.include_router(analytics.router)
app.include_router(shift_coordination.router)

# Admin model-wise
app.include_router(rooms_router)
app.include_router(beds_router)
app.include_router(students_router)
app.include_router(supervisors_router)

# Comparison
app.include_router(comparison_router)

# Additional routers
app.include_router(visitor_booking_router)
app.include_router(visitor_compare_router)
app.include_router(admin_booking_router)
app.include_router(admin_modify_booking_router)
app.include_router(calendar_router)
app.include_router(admin_waitlist_router)
app.include_router(visitor_waitlist_router)
app.include_router(admin_jobs_router)

# Fee & Payment
app.include_router(fee_structure_configuration.router)
app.include_router(payment_routes.router)

from app.api.v1.admin import invoices, transactions, receipts, refunds
app.include_router(invoices.router, prefix="/invoices", tags=["Invoices"])
app.include_router(transactions.router, prefix="/transactions", tags=["Transactions"])
app.include_router(receipts.router, prefix="/receipts", tags=["Receipts"])
app.include_router(refunds.router, prefix="/refunds", tags=["Refunds"])

from app.api.v1.admin.ledger_routes import router as ledger_router
app.include_router(ledger_router)

from app.api.v1.admin.reminder_configs import router as reminder_config_router
app.include_router(reminder_config_router)

from app.api.v1.admin.reminder_templates import router as reminder_template_router
app.include_router(reminder_template_router)

from app.api.v1.admin.Reminder_rotes import router as reminder_router
app.include_router(reminder_router)

# ⭐ Mess Menu Routers
app.include_router(admin_mess_menu.router, prefix="/api/v1")
app.include_router(supervisor_mess_menu.router, prefix="/api/v1")
app.include_router(student_mess_menu.router, prefix="/api/v1")

# ⭐ Announcement Routers
app.include_router(admin_announcement.router, prefix="/api/v1")
app.include_router(supervisor_announcement.router, prefix="/api/v1")
app.include_router(student_announcement.router, prefix="/api/v1")

# ⭐ Notification Routers
app.include_router(student_notification_router, prefix="/api/v1")
app.include_router(supervisor_notification_router, prefix="/api/v1")
app.include_router(admin_notification_router, prefix="/api/v1")

# ---------------------------------------------------------------------------
# STATIC FILES
# ---------------------------------------------------------------------------
uploads_dir = Path("uploads")
uploads_dir.mkdir(exist_ok=True)
app.mount("/uploads", StaticFiles(directory=str(uploads_dir)), name="uploads")

# ---------------------------------------------------------------------------
# HEALTH & ROOT
# ---------------------------------------------------------------------------
@app.get("/")
async def root():
    return {
        "message": "Hostel Management System API",
        "version": "1.0.0",
        "docs": "/docs"
    }

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

# ---------------------------------------------------------------------------
# RUN LOCALLY
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host=settings.HOST, port=settings.PORT)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\seed_test_data.py ---
from app.core.database import SessionLocal
from app.models.payment_models import Customer
from app.models.hostel import Hostel
from app.models.admin import Admin, AdminHostelAssignment, PermissionLevel
from sqlalchemy.exc import IntegrityError

def seed_test_data():
    db = SessionLocal()
    try:
        existing_customer = db.query(Customer).filter_by(email="testuser@example.com").first()
        existing_hostel = db.query(Hostel).filter_by(hostel_name="Blue Horizon Hostel").first()

        if not existing_customer:
            customer = Customer(
                name="Test User",
                email="testuser@example.com",
                phone="9876543210"
            )
            db.add(customer)
        else:
            customer = existing_customer

        if not existing_hostel:
            hostel = Hostel(
                hostel_name="Blue Horizon Hostel",
                full_address="Main Street, City Center",
                capacity=150
            )
            db.add(hostel)
        else:
            hostel = existing_hostel

        db.commit()
        db.refresh(customer)
        db.refresh(hostel)

        print(f"✅ Customer ID: {customer.id}")
        print(f"✅ Hostel ID: {hostel.id}")

    except IntegrityError as e:
        db.rollback()
        print(f"❌ Integrity error: {e.orig}")
    except Exception as e:
        db.rollback()
        print(f"❌ Unexpected error: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    seed_test_data()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\deps.py ---
"""
Dependency functions (get_current_user, role_required)
"""
from typing import Optional, List
from fastapi import Depends, HTTPException, status, Request
from sqlalchemy.orm import Session

from app.core.security import get_current_user
from app.core.roles import Role
from app.core.permissions import has_permission
from app.core.exceptions import AccessDeniedException
from app.models.user import User
from app.core.database import get_db


def get_db_session(db: Session = Depends(get_db)) -> Session:
    """Get database session"""
    return db


def get_active_hostel_id(request: Request) -> Optional[int]:
    """Get active hostel_id from request state (set by TenantFilterMiddleware)"""
    if hasattr(request.state, "bypass_tenant_filter") and request.state.bypass_tenant_filter:
        return None  # Superadmin bypass
    return getattr(request.state, "active_hostel_id", None)


def get_user_hostel_ids(user_id: int, user_role: str, db: Session) -> List[int]:
    """Get list of hostel IDs user has access to"""
    from app.repositories.hostel_repository import HostelRepository
    from app.repositories.user_repository import UserRepository
    
    if user_role == Role.SUPERADMIN:
        # Superadmin has access to all hostels
        hostel_repo = HostelRepository(db)
        hostels = hostel_repo.get_all_hostels(skip=0, limit=1000)
        return [h.id for h in hostels]
    elif user_role == Role.ADMIN:
        # Admin has access to assigned hostels
        hostel_repo = HostelRepository(db)
        hostels = hostel_repo.get_by_admin(user_id)
        return [h.id for h in hostels]
    else:
        # Other roles have access to their own hostel
        user_repo = UserRepository(db)
        user = user_repo.get_by_id(user_id)
        if user and user.hostel_id:
            return [user.hostel_id]
        return []


def role_required(*allowed_roles: str):
    """Dependency to check if user has required role"""
    def role_checker(current_user: User = Depends(get_current_user)) -> User:
        if current_user.role not in allowed_roles:
            raise AccessDeniedException(
                f"Access denied. Required roles: {', '.join(allowed_roles)}"
            )
        return current_user
    return role_checker


def permission_required(permission: str):
    """Dependency to check if user has required permission"""
    def permission_checker(current_user: User = Depends(get_current_user)) -> User:
        if not has_permission(current_user.role, permission):
            raise AccessDeniedException(
                f"Access denied. Required permission: {permission}"
            )
        return current_user
    return permission_checker


def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """Get current active user"""
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is inactive"
        )
    return current_user


def get_repository_context(
    current_user: User = Depends(get_current_active_user),
    request: Optional[Request] = None,
    db: Session = Depends(get_db)
) -> dict:
    """Get context for repositories (user role, active hostel, accessible hostels)"""
    active_hostel_id = get_active_hostel_id(request) if request else None
    user_hostel_ids = get_user_hostel_ids(current_user.id, current_user.role, db)
    
    return {
        "user_role": current_user.role,
        "active_hostel_id": active_hostel_id,
        "user_hostel_ids": user_hostel_ids
    }



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1 =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\locations.py ---
# File removed as the locations router is no longer used.
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.core.database import get_db
from pydantic import BaseModel
from typing import Optional
from sqlalchemy import text

router = APIRouter(prefix="/locations", tags=["locations"])

class LocationCreate(BaseModel):
    city: str

class LocationResponse(BaseModel):
    id: int
    city: str
    created_at: Optional[str]

@router.post("/", response_model=LocationResponse)
def create_location(location: LocationCreate, db: Session = Depends(get_db)):
    try:
        sql = text("SELECT * FROM insert_location(:city)")
        result = db.execute(sql, {"city": location.city})
        row = result.fetchone()
        if not row:
            raise HTTPException(status_code=500, detail="Location not created")
        return LocationResponse(id=row[0], city=row[1], created_at=str(row[2]))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.core.database import get_db
from pydantic import BaseModel
from typing import Optional
from sqlalchemy import text

router = APIRouter(prefix="/locations", tags=["locations"])

class LocationCreate(BaseModel):
    city: str

class LocationResponse(BaseModel):
    id: int
    city: str
    created_at: Optional[str]

@router.post("/", response_model=LocationResponse)
def create_location(location: LocationCreate, db: Session = Depends(get_db)):
    try:
        sql = text("SELECT * FROM insert_location(:city)")
        result = db.execute(sql, {"city": location.city})
        row = result.fetchone()
        if not row:
            raise HTTPException(status_code=500, detail="Location not created")
        return LocationResponse(id=row[0], city=row[1], created_at=str(row[2]))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\router.py ---
"""
Combines all routers
"""
from fastapi import APIRouter

from app.api.v1.auth import (
    login, refresh, roles,
    login_enhanced, password_reset, password_strength, me
)
from app.api.v1.admin import session as admin_session, audit, permissions, rbac, hostels, approvals, admins
from app.api.v1.supervisor import audit as supervisor_audit, permissions as supervisor_permissions, approvals as supervisor_approvals
from app.api.v1.super_admin import dashboard
# ...existing code...

api_router = APIRouter()



# Enhanced auth routes
api_router.include_router(login_enhanced.router, prefix="/auth", tags=["auth"])
# Auth routes
api_router.include_router(refresh.router, prefix="/auth", tags=["auth"])
api_router.include_router(roles.router, prefix="/auth", tags=["auth"])
api_router.include_router(password_reset.router, prefix="/auth", tags=["auth"])
api_router.include_router(password_strength.router, prefix="/auth", tags=["auth"])
api_router.include_router(me.router, prefix="/auth", tags=["auth"])

# Admin routes
api_router.include_router(admins.router, prefix="/admin", tags=["admin"])
api_router.include_router(admin_session.router, prefix="/admin", tags=["admin"])
api_router.include_router(audit.router, prefix="/admin", tags=["admin"])
api_router.include_router(permissions.router, prefix="/admin", tags=["admin"])
api_router.include_router(approvals.router, prefix="/admin", tags=["admin"])
api_router.include_router(rbac.router, prefix="/admin", tags=["admin"])
api_router.include_router(hostels.router, prefix="/admin", tags=["admin"])
api_router.include_router(dashboard.router)

# Note: audit endpoints are exposed under /admin/audit and /supervisor/audit
# Supervisor routes
api_router.include_router(supervisor_audit.router, prefix="/supervisor", tags=["supervisor"])
api_router.include_router(supervisor_permissions.router, prefix="/supervisor", tags=["supervisor"])
api_router.include_router(supervisor_approvals.router, prefix="/supervisor", tags=["supervisor"])

# Visitor routes have been disabled by admin request

# ...existing code...



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\admins.py ---
"""
Admin management endpoints (SuperAdmin only)
- Create admin
- List admins
- Get admin
- Update admin
- Delete admin
- Upload profile picture
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query, UploadFile, File
from sqlalchemy.orm import Session
from typing import List, Optional
import os
import uuid
from pathlib import Path

from app.core.database import get_db
from app.core.roles import Role
from app.core.permissions import Permission
from app.api.deps import role_required, permission_required, get_current_active_user, get_repository_context, get_user_hostel_ids
from app.core.exceptions import AccessDeniedException
from app.models.user import User
from app.schemas.user import UserCreate, UserUpdate, UserResponse, AdminCreate
from app.repositories.user_repository import UserRepository
from app.services.permission_service import PermissionService
from app.core.security import get_password_hash
from app.config import settings
from fastapi import Body
 

router = APIRouter()

# Profile picture upload directory
UPLOAD_DIR = Path("uploads/profile_pictures")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

# Allowed image extensions
ALLOWED_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif", ".webp"}
MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB


def validate_image_file(file: UploadFile) -> bool:
    """Validate uploaded image file"""
    if not file.filename:
        return False
    
    ext = Path(file.filename).suffix.lower()
    return ext in ALLOWED_EXTENSIONS


def save_profile_picture(file: UploadFile, user_id: int) -> str:
    """Save profile picture and return URL"""
    # Generate unique filename
    ext = Path(file.filename).suffix.lower()
    filename = f"{user_id}_{uuid.uuid4().hex}{ext}"
    file_path = UPLOAD_DIR / filename
    
    # Save file
    with open(file_path, "wb") as buffer:
        content = file.file.read()
        if len(content) > MAX_FILE_SIZE:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"File size exceeds {MAX_FILE_SIZE / 1024 / 1024}MB limit"
            )
        buffer.write(content)
    
    # Return relative URL
    return f"/uploads/profile_pictures/{filename}"


@router.post("/admins", response_model=UserResponse, status_code=status.HTTP_201_CREATED, tags=["admin"])
async def create_admin(
    admin_data: AdminCreate,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """
    Create new hostel admin (SuperAdmin only)
    
    Creates a new admin user with role 'admin'. 
    Requires password and confirm_password (must match).
    """
    # Ensure role is admin
    if admin_data.role and admin_data.role != Role.ADMIN.value:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="This endpoint only creates admin users. Role must be 'admin'."
        )
    
    # Password validation is handled by AdminCreate schema validator
    # confirm_password is validated to match password
    
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )
    
    # Check if email already exists
    if admin_data.email and user_repo.get_by_email(admin_data.email):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Check if username already exists
    if user_repo.get_by_username(admin_data.username):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )
    
    # Check if phone already exists
    if admin_data.phone_number and user_repo.get_by_phone_number(admin_data.phone_number):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Phone number already registered"
        )
    
    # Set role to admin explicitly
    admin_data.role = Role.ADMIN.value

    # Validate hostel if provided
    if getattr(admin_data, 'hostel_id', None):
        from app.repositories.hostel_repository import HostelRepository
        hostel_repo = HostelRepository(db)
        hostel = hostel_repo.get_by_id(admin_data.hostel_id)
        if not hostel:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Hostel with id={admin_data.hostel_id} does not exist"
            )
    
    # Convert AdminCreate to UserCreate (exclude confirm_password)
    user_create_data = UserCreate(
        email=admin_data.email,
        phone_number=admin_data.phone_number,
        country_code=admin_data.country_code,
        username=admin_data.username,
        full_name=admin_data.full_name,
        role=admin_data.role,
        hostel_id=admin_data.hostel_id,
        password=admin_data.password  # Only password, not confirm_password
    )
    
    # Create admin
    admin = user_repo.create(user_create_data)
    
    # Set admin as active (admins created by SuperAdmin are active by default)
    admin.is_active = True
    admin.is_email_verified = True  # Trust SuperAdmin-created admins
    db.commit()
    db.refresh(admin)
    
    return admin


@router.get("/admins", response_model=List[UserResponse], tags=["admin"])
async def list_admins(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=100),
    hostel_id: Optional[int] = Query(None, description="Filter by hostel ID"),
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """
    List all admins (SuperAdmin only)
    
    Returns a list of all admin users. Can optionally filter by hostel_id.
    """
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )
    
    # Get all users and filter by admin role
    all_users = user_repo.get_all(skip=skip, limit=limit * 10)  # Get more to filter
    
    # Filter admins
    admins = [u for u in all_users if u.role == Role.ADMIN.value]
    
    # Filter by hostel_id if provided
    if hostel_id:
        admins = [a for a in admins if a.hostel_id == hostel_id]
    
    # Apply limit after filtering
    admins = admins[:limit]
    
    return admins


@router.get("/admins/{admin_id}", response_model=UserResponse, tags=["admin"])
async def get_admin(
    admin_id: int,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """
    Get admin by ID (SuperAdmin only)
    """
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )
    
    admin = user_repo.get_by_id(admin_id)
    
    if not admin:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Admin not found"
        )
    
    # Verify it's an admin
    if admin.role != Role.ADMIN.value:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="User is not an admin"
        )
    
    return admin


@router.put("/admins/{admin_id}", response_model=UserResponse, tags=["admin"])
async def update_admin(
    admin_id: int,
    admin_data: UserUpdate,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """
    Update admin (SuperAdmin only)
    """
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )
    
    # Get existing admin
    existing_admin = user_repo.get_by_id(admin_id)
    if not existing_admin:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Admin not found"
        )
    
    # Verify it's an admin
    if existing_admin.role != Role.ADMIN.value:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="User is not an admin"
        )
    
    # Prevent role change (admins should stay as admin)
    if admin_data.role and admin_data.role != Role.ADMIN.value:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot change admin role. Use role management endpoints instead."
        )
    
    # Check email uniqueness if updating
    if admin_data.email and admin_data.email != existing_admin.email:
        if user_repo.get_by_email(admin_data.email):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
    
    # Check username uniqueness if updating
    if admin_data.username and admin_data.username != existing_admin.username:
        if user_repo.get_by_username(admin_data.username):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already taken"
            )
    
    # Check phone uniqueness if updating
    if admin_data.phone_number and admin_data.phone_number != existing_admin.phone_number:
        if user_repo.get_by_phone_number(admin_data.phone_number):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Phone number already registered"
            )
    
    # Update admin
    updated_admin = user_repo.update(admin_id, admin_data)
    if not updated_admin:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Admin not found"
        )
    
    return updated_admin


@router.delete("/admins/{admin_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["admin"])
async def delete_admin(
    admin_id: int,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """
    Delete admin (SuperAdmin only)
    """
    # Prevent self-deletion
    if admin_id == current_user.id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot delete your own account"
        )
    
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )
    
    # Get admin to verify
    admin = user_repo.get_by_id(admin_id)
    if not admin:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Admin not found"
        )
    
    # Verify it's an admin
    if admin.role != Role.ADMIN.value:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="User is not an admin"
        )
    
    # Delete profile picture if exists
    if hasattr(admin, 'profile_picture_url') and admin.profile_picture_url:
        profile_path = Path(admin.profile_picture_url.lstrip('/'))
        if profile_path.exists():
            profile_path.unlink()
    
    # Delete admin
    success = user_repo.delete(admin_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Admin not found"
        )
    
    return None


@router.post("/admins/{admin_id}/profile-picture", response_model=dict, tags=["admin"])
async def upload_profile_picture(
    admin_id: int,
    file: UploadFile = File(...),
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Upload profile picture for a user (SuperAdmin only).

    Accepts image files (jpg, jpeg, png, gif, webp) up to 5MB.
    This endpoint now works for admins, supervisors, and students — it updates the
    `profile_picture_url` for the user with the given id.
    """
    # Validate file
    if not validate_image_file(file):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid file type. Allowed: {', '.join(ALLOWED_EXTENSIONS)}"
        )
    
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )
    
    # Get user (admin/supervisor/student)
    user = user_repo.get_by_id(admin_id)
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")

    # Delete old profile picture if exists
    if hasattr(user, 'profile_picture_url') and user.profile_picture_url:
        old_path = Path(user.profile_picture_url.lstrip('/'))
        if old_path.exists():
            old_path.unlink()

    # Save new profile picture
    try:
        profile_url = save_profile_picture(file, admin_id)

        # Update user's profile_picture_url
        user.profile_picture_url = profile_url
        db.commit()
        db.refresh(user)

        return {
            "message": "Profile picture uploaded successfully",
            "profile_picture_url": profile_url,
            "user_id": admin_id
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to upload profile picture: {str(e)}"
        )


@router.post("/admins/{admin_id}/assign-hostels", response_model=dict, tags=["admin"])
async def assign_hostels_to_admin(
    admin_id: int,
    hostel_ids: List[int] = Body(..., embed=True, description="List of hostel ids to assign"),
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Assign multiple hostels to an admin (SuperAdmin only). Idempotent."""
    tenant_service = __import__('app.services.tenant_service', fromlist=['TenantService']).TenantService(db)
    return tenant_service.assign_admin_to_hostels(admin_id, hostel_ids, current_user.role)


@router.post("/supervisors", response_model=UserResponse, status_code=status.HTTP_201_CREATED, tags=["admin"])
async def create_supervisor(
    supervisor_data: AdminCreate,
    current_user: User = Depends(role_required(Role.SUPERADMIN, Role.ADMIN)),
    _perm: User = Depends(permission_required(Permission.MANAGE_SUPERVISORS)),
    db: Session = Depends(get_db)
):
    """Create a supervisor (SuperAdmin or Hostel Admin for their hostels)"""
    # reuse creation flow similar to create_admin but set role to supervisor
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )

    # uniqueness checks
    if supervisor_data.email and user_repo.get_by_email(supervisor_data.email):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Email already registered")
    if user_repo.get_by_username(supervisor_data.username):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Username already taken")
    if supervisor_data.phone_number and user_repo.get_by_phone_number(supervisor_data.phone_number):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Phone number already registered")

    supervisor_data.role = Role.SUPERVISOR.value

    # If current_user is an ADMIN, ensure they can only create supervisors for hostels they manage
    if current_user.role == Role.ADMIN:
        allowed_hostels = get_user_hostel_ids(current_user.id, current_user.role, db)
        target_hostel = getattr(supervisor_data, 'hostel_id', None)
        if target_hostel and target_hostel not in allowed_hostels:
            raise AccessDeniedException("Admin cannot assign supervisor to a hostel they do not manage")

    user_create_data = UserCreate(
        email=supervisor_data.email,
        phone_number=supervisor_data.phone_number,
        country_code=supervisor_data.country_code,
        username=supervisor_data.username,
        full_name=supervisor_data.full_name,
        role=supervisor_data.role,
        hostel_id=getattr(supervisor_data, 'hostel_id', None),
        password=supervisor_data.password
    )

    user = user_repo.create(user_create_data)
    user.is_active = True
    user.is_email_verified = True
    db.commit()
    db.refresh(user)
    return user


@router.post("/students", response_model=UserResponse, status_code=status.HTTP_201_CREATED, tags=["admin"])
async def create_student(
    student_data: AdminCreate,
    current_user: User = Depends(role_required(Role.SUPERADMIN, Role.ADMIN)),
    _perm: User = Depends(permission_required(Permission.CREATE_REGISTRATION)),
    db: Session = Depends(get_db)
):
    """Create a student (SuperAdmin or Hostel Admin for their hostels)"""
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )

    # uniqueness checks
    if student_data.email and user_repo.get_by_email(student_data.email):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Email already registered")
    if user_repo.get_by_username(student_data.username):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Username already taken")
    if student_data.phone_number and user_repo.get_by_phone_number(student_data.phone_number):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Phone number already registered")

    student_data.role = Role.STUDENT.value

    # If current_user is ADMIN, ensure student is assigned to their hostel
    if current_user.role == Role.ADMIN:
        allowed_hostels = get_user_hostel_ids(current_user.id, current_user.role, db)
        target_hostel = getattr(student_data, 'hostel_id', None)
        if target_hostel and target_hostel not in allowed_hostels:
            raise AccessDeniedException("Admin cannot create student for a hostel they do not manage")

    user_create_data = UserCreate(
        email=student_data.email,
        phone_number=student_data.phone_number,
        country_code=student_data.country_code,
        username=student_data.username,
        full_name=student_data.full_name,
        role=student_data.role,
        hostel_id=getattr(student_data, 'hostel_id', None),
        password=student_data.password
    )

    user = user_repo.create(user_create_data)
    user.is_active = True
    user.is_email_verified = True
    db.commit()
    db.refresh(user)
    return user



@router.put("/supervisors/{supervisor_id}", response_model=UserResponse, tags=["admin"])
async def update_supervisor(
    supervisor_id: int,
    supervisor_data: UserUpdate,
    current_user: User = Depends(role_required(Role.SUPERADMIN, Role.ADMIN)),
    _perm: User = Depends(permission_required(Permission.MANAGE_SUPERVISORS)),
    db: Session = Depends(get_db)
):
    """Update supervisor (SuperAdmin or Hostel Admin for their hostels)"""
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )

    existing = user_repo.get_by_id(supervisor_id)
    if not existing:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Supervisor not found")

    if existing.role != Role.SUPERVISOR.value:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User is not a supervisor")

    # Prevent role change
    if supervisor_data.role and supervisor_data.role != Role.SUPERVISOR.value:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Cannot change supervisor role")

    # If ADMIN is updating, ensure the target supervisor belongs to one of their hostels
    if current_user.role == Role.ADMIN:
        allowed_hostels = get_user_hostel_ids(current_user.id, current_user.role, db)
        if existing.hostel_id and existing.hostel_id not in allowed_hostels:
            raise AccessDeniedException("Admin cannot modify a supervisor outside their hostels")

    # Check email uniqueness if updating
    if supervisor_data.email and supervisor_data.email != existing.email:
        if user_repo.get_by_email(supervisor_data.email):
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Email already registered")

    # Check username uniqueness if updating
    if supervisor_data.username and supervisor_data.username != existing.username:
        if user_repo.get_by_username(supervisor_data.username):
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Username already taken")

    # Check phone uniqueness if updating
    if supervisor_data.phone_number and supervisor_data.phone_number != existing.phone_number:
        if user_repo.get_by_phone_number(supervisor_data.phone_number):
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Phone number already registered")

    updated = user_repo.update(supervisor_id, supervisor_data)
    if not updated:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Supervisor not found")

    return updated


@router.delete("/supervisors/{supervisor_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["admin"])
async def delete_supervisor(
    supervisor_id: int,
    current_user: User = Depends(role_required(Role.SUPERADMIN, Role.ADMIN)),
    _perm: User = Depends(permission_required(Permission.MANAGE_SUPERVISORS)),
    db: Session = Depends(get_db)
):
    """Delete supervisor (SuperAdmin or Hostel Admin for their hostels)"""
    # Prevent self-deletion
    if supervisor_id == current_user.id:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Cannot delete your own account")

    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )

    supervisor = user_repo.get_by_id(supervisor_id)
    if not supervisor:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Supervisor not found")

    if supervisor.role != Role.SUPERVISOR.value:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User is not a supervisor")

    # Delete profile picture if exists
    if hasattr(supervisor, 'profile_picture_url') and supervisor.profile_picture_url:
        profile_path = Path(supervisor.profile_picture_url.lstrip('/'))
        if profile_path.exists():
            profile_path.unlink()

    # If ADMIN deleting, ensure supervisor within allowed hostels
    if current_user.role == Role.ADMIN:
        allowed_hostels = get_user_hostel_ids(current_user.id, current_user.role, db)
        if supervisor.hostel_id and supervisor.hostel_id not in allowed_hostels:
            raise AccessDeniedException("Admin cannot delete a supervisor outside their hostels")

    success = user_repo.delete(supervisor_id)
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Supervisor not found")

    return None


@router.put("/students/{student_id}", response_model=UserResponse, tags=["admin"])
async def update_student(
    student_id: int,
    student_data: UserUpdate,
    current_user: User = Depends(role_required(Role.SUPERADMIN, Role.ADMIN)),
    _perm: User = Depends(permission_required(Permission.UPDATE_USER)),
    db: Session = Depends(get_db)
):
    """Update student (SuperAdmin or Hostel Admin for their hostels)"""
    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )

    existing = user_repo.get_by_id(student_id)
    if not existing:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Student not found")

    if existing.role != Role.STUDENT.value:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User is not a student")

    # Prevent role change
    if student_data.role and student_data.role != Role.STUDENT.value:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Cannot change student role")

    # If ADMIN is updating, ensure the student belongs to one of their hostels
    if current_user.role == Role.ADMIN:
        allowed_hostels = get_user_hostel_ids(current_user.id, current_user.role, db)
        if existing.hostel_id and existing.hostel_id not in allowed_hostels:
            raise AccessDeniedException("Admin cannot modify a student outside their hostels")

    # Check email uniqueness if updating
    if student_data.email and student_data.email != existing.email:
        if user_repo.get_by_email(student_data.email):
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Email already registered")

    # Check username uniqueness if updating
    if student_data.username and student_data.username != existing.username:
        if user_repo.get_by_username(student_data.username):
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Username already taken")

    # Check phone uniqueness if updating
    if student_data.phone_number and student_data.phone_number != existing.phone_number:
        if user_repo.get_by_phone_number(student_data.phone_number):
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Phone number already registered")

    updated = user_repo.update(student_id, student_data)
    if not updated:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Student not found")

    return updated


@router.delete("/students/{student_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["admin"])
async def delete_student(
    student_id: int,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Delete student (SuperAdmin only)"""
    # Prevent self-deletion
    if student_id == current_user.id:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Cannot delete your own account")

    context = get_repository_context(current_user, None, db)
    user_repo = UserRepository(
        db=db,
        user_role=context["user_role"],
        active_hostel_id=context["active_hostel_id"],
        user_hostel_ids=context["user_hostel_ids"]
    )

    student = user_repo.get_by_id(student_id)
    if not student:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Student not found")

    if student.role != Role.STUDENT.value:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User is not a student")

    # Delete profile picture if exists
    if hasattr(student, 'profile_picture_url') and student.profile_picture_url:
        profile_path = Path(student.profile_picture_url.lstrip('/'))
        if profile_path.exists():
            profile_path.unlink()

    success = user_repo.delete(student_id)
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Student not found")

    return None



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\admin_jobs.py ---
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.services.waitlist_service import WaitlistService

router = APIRouter(prefix="/admin/jobs", tags=["Admin Jobs"])


@router.post("/promote")
def run_waitlist_promotion(
    hostel_id: int,
    room_type: str | None = None,
    db: Session = Depends(get_db)
):
    """
    Manually trigger waitlist promotion.
    """
    booking, entry = WaitlistService.try_promote(db, hostel_id, room_type)

    if booking is None and entry is None:
        return {"message": "No waitlist entries found"}

    if booking:
        return {
            "message": "Promotion successful",
            "booking_id": booking.id,
            "room_id": booking.room_id,
            "visitor_id": booking.visitor_id
        }

    return {"message": "Entry exists but no room currently available"}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\analytics.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\announcement.py ---
# app/api/v1/admin/announcement.py

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List

from app.schemas.announcement import (
    AnnouncementCreate,
    AnnouncementRead,
    AnnouncementUpdate
)
from app.core.database import get_db
from app.services.announcement_service import AnnouncementService

router = APIRouter(
    prefix="/admin/announcements",
    tags=["Admin Announcements"]      # 🔥 Updated Swagger Tag
)

# TEMP placeholder — replace with your real auth dependency later
def get_current_user_admin():
    return {"id": 1, "role": "admin"}


@router.post("/", response_model=AnnouncementRead)
def create_announcement(
    payload: AnnouncementCreate,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user_admin)
):
    svc = AnnouncementService(session)
    return svc.create_announcement(current_user, payload.dict())


@router.get("/", response_model=List[AnnouncementRead])
def list_announcements(
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user_admin)
):
    svc = AnnouncementService(session)
    return svc.list_for_admin()


@router.get("/{announcement_id}", response_model=AnnouncementRead)
def get_announcement(
    announcement_id: int,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user_admin)
):
    svc = AnnouncementService(session)
    return svc.get_announcement(announcement_id)


@router.put("/{announcement_id}", response_model=AnnouncementRead)
def update_announcement(
    announcement_id: int,
    payload: AnnouncementUpdate,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user_admin)
):
    svc = AnnouncementService(session)
    return svc.update_announcement(
        current_user,
        announcement_id,
        payload.dict(exclude_unset=True)
    )


@router.post("/{announcement_id}/approve")
def approve_announcement(
    announcement_id: int,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user_admin)
):
    svc = AnnouncementService(session)
    svc.approve_announcement(current_user, announcement_id)
    return {"detail": "Approved"}


@router.post("/{announcement_id}/publish")
def publish_announcement(
    announcement_id: int,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user_admin)
):
    svc = AnnouncementService(session)
    svc.force_publish(current_user, announcement_id)
    return {"detail": "Published"}


@router.delete("/{announcement_id}")
def delete_announcement(
    announcement_id: int,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user_admin)
):
    svc = AnnouncementService(session)
    svc.delete_announcement(current_user, announcement_id)
    return {"detail": "Deleted"}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\approvals.py ---
"""
Approval management endpoints
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional

from app.core.database import get_db
from app.core.roles import Role
from app.api.deps import role_required, get_current_active_user
from app.models.user import User
from app.services.permission_service import PermissionService
from app.schemas.approval import ApprovalRequestResponse

router = APIRouter()


@router.get("/approvals/pending", response_model=List[dict], status_code=status.HTTP_200_OK)
async def get_pending_approvals(
    hostel_id: Optional[int] = Query(None),
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get pending approval requests that current user can approve"""
    permission_service = PermissionService(db)
    return permission_service.get_pending_approvals(current_user.role, hostel_id)


@router.post("/approvals/{approval_id}/approve", response_model=dict, status_code=status.HTTP_200_OK)
async def approve_request(
    approval_id: int,
    notes: Optional[str] = None,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Approve an approval request"""
    permission_service = PermissionService(db)
    return permission_service.approve_request(approval_id, current_user.id, notes)


@router.post("/approvals/{approval_id}/reject", response_model=dict, status_code=status.HTTP_200_OK)
async def reject_request(
    approval_id: int,
    notes: Optional[str] = None,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Reject an approval request"""
    permission_service = PermissionService(db)
    return permission_service.reject_request(approval_id, current_user.id, notes)


@router.get("/approvals/{approval_id}", response_model=dict, status_code=status.HTTP_200_OK)
async def get_approval_status(
    approval_id: int,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN, Role.SUPERVISOR)),
    db: Session = Depends(get_db)
):
    """Get approval request status"""
    permission_service = PermissionService(db)
    return permission_service.check_approval_status(approval_id)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\attendance.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\audit.py ---
"""
View supervisor activity
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime

from app.core.database import get_db
from app.core.roles import Role
from app.api.deps import role_required, get_current_active_user
from app.models.user import User
from app.services.audit_service import AuditService
from app.schemas.audit import AuditLogResponse, AuditLogFilter
from app.schemas.audit import AuditLogBase
from fastapi import Body

router = APIRouter()


@router.get("/audit", response_model=List[AuditLogResponse], status_code=status.HTTP_200_OK)
async def get_audit_logs(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    user_id: Optional[int] = None,
    hostel_id: Optional[int] = None,
    action: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get audit logs"""
    audit_service = AuditService(db)
    
    filters = AuditLogFilter(
        user_id=user_id,
        hostel_id=hostel_id,
        action=action,
        start_date=start_date,
        end_date=end_date
    )
    
    return audit_service.get_audit_logs(
        viewer_role=current_user.role,
        viewer_user_id=current_user.id,
        skip=skip,
        limit=limit,
        filters=filters
    )


@router.get("/audit/user/{user_id}", response_model=List[AuditLogResponse], status_code=status.HTTP_200_OK)
async def get_user_audit_logs(
    user_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get audit logs for a specific user"""
    audit_service = AuditService(db)
    return audit_service.get_user_audit_logs(user_id, skip=skip, limit=limit)


@router.get("/audit/users/{user_id}", response_model=List[AuditLogResponse], status_code=status.HTTP_200_OK)
async def get_user_audit_logs_plural(
    user_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Alias endpoint with plural users in path"""
    audit_service = AuditService(db)
    return audit_service.get_user_audit_logs(user_id, skip=skip, limit=limit)


@router.get("/audit/target/{target_id}", response_model=List[AuditLogResponse], status_code=status.HTTP_200_OK)
async def get_audit_by_target(
    target_id: str,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Search audit logs by target identifier in resource or details"""
    audit_service = AuditService(db)
    return audit_service.get_target_audit_logs(target_id, skip=skip, limit=limit)


@router.post("/audit/logs", response_model=AuditLogResponse, status_code=status.HTTP_201_CREATED)
async def create_audit_log(
    payload: AuditLogBase = Body(...),
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Create an audit log entry (admins/superadmins can post entries)."""
    audit_service = AuditService(db)
    return audit_service.create_audit_log(
        user_id=current_user.id,
        action=payload.action,
        resource=payload.resource,
        hostel_id=payload.hostel_id,
        ip_address=payload.ip_address,
        user_agent=payload.user_agent,
        details=payload.details
    )



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\beds.py ---
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File
from sqlalchemy.orm import Session
import csv
from io import StringIO

from app.core.database import get_db
from app.schemas.beds import BedCreate, BedOut, BedUpdate
from app.services.bed_service import (
    create_bed as service_create_bed,
    get_bed as service_get_bed,
    list_beds as service_list_beds,
    list_available_beds as service_list_available_beds,
    update_bed as service_update_bed,
    delete_bed as service_delete_bed,
    assign_bed as service_assign_bed,
    release_bed as service_release_bed,
    transfer_student_bed as service_transfer_student_bed,
    find_bed_by_room_bed as service_find_bed_by_room_bed,
)

router = APIRouter(prefix="/api/v1/admin/beds", tags=["beds"])


@router.post("/", response_model=BedOut, status_code=status.HTTP_201_CREATED)
def create_bed(item: BedCreate, db: Session = Depends(get_db)):
    try:
        return service_create_bed(db, item)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/", response_model=List[BedOut])
def read_beds(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return service_list_beds(db, skip=skip, limit=limit)


@router.get("/available", response_model=List[BedOut])
def read_available_beds(room_number: Optional[str] = None, skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return service_list_available_beds(db, room_number=room_number, skip=skip, limit=limit)


@router.get("/{bed_id}", response_model=BedOut)
def read_bed(bed_id: int, db: Session = Depends(get_db)):
    bed = service_get_bed(db, bed_id)
    if not bed:
        raise HTTPException(status_code=404, detail="Bed not found")
    if hasattr(bed, 'hostel_id'):
        bed.hostel_id = str(bed.hostel_id) if bed.hostel_id is not None else None
    return bed


@router.put("/{bed_id}", response_model=BedOut)
def update_bed(bed_id: int, payload: BedUpdate, db: Session = Depends(get_db)):
    updated = service_update_bed(db, bed_id, payload)
    if not updated:
        raise HTTPException(status_code=404, detail="Bed not found")
    if hasattr(updated, 'hostel_id'):
        updated.hostel_id = str(updated.hostel_id) if updated.hostel_id is not None else None
    return updated


@router.delete("/{bed_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_bed(bed_id: int, db: Session = Depends(get_db)):
    ok = service_delete_bed(db, bed_id)
    if not ok:
        raise HTTPException(status_code=404, detail="Bed not found")
    return None


@router.post("/{bed_id}/assign", response_model=BedOut)
def assign_bed(bed_id: int, student_id: str, db: Session = Depends(get_db)):
    updated = service_assign_bed(db, bed_id, student_id)
    if not updated:
        raise HTTPException(status_code=404, detail="Bed not found")
    return updated


@router.post("/{bed_id}/release", response_model=BedOut)
def release_bed(bed_id: int, db: Session = Depends(get_db)):
    updated = service_release_bed(db, bed_id)
    if not updated:
        raise HTTPException(status_code=404, detail="Bed not found")
    return updated


@router.post("/transfer", response_model=BedOut)
def transfer_bed(student_id: str, new_bed_id: int, db: Session = Depends(get_db)):
    updated = service_transfer_student_bed(db, student_id, new_bed_id)
    if not updated:
        raise HTTPException(status_code=404, detail="Transfer failed or bed not found")
    return updated


@router.post("/bulk/assign")
async def bulk_assign_beds(file: UploadFile = File(...), db: Session = Depends(get_db)):
    content = (await file.read()).decode("utf-8")
    reader = csv.DictReader(StringIO(content))
    assigned = 0
    skipped = 0
    for row in reader:
        student_id = row.get("student_id")
        room_number = row.get("room_number")
        bed_number = row.get("bed_number")
        if not student_id or not room_number or not bed_number:
            skipped += 1
            continue
        bed = service_find_bed_by_room_bed(db, room_number, bed_number)
        if not bed:
            skipped += 1
            continue
        try:
            service_assign_bed(db, bed.id, student_id)
            assigned += 1
        except Exception:
            skipped += 1
            continue
    return {"assigned": assigned, "skipped": skipped}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\bookings.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from datetime import datetime
from typing import List

from app.core.database import get_db
from app.models.booking import Booking, BookingStatus
from app.models.rooms import Room
from app.schemas.booking import (
    BookingCreateSchema,
    BookingResponseSchema,
    BookingUpdateSchema,
    BookingStatusUpdateSchema,
)

router = APIRouter(prefix="/bookings", tags=["Bookings"])


# ---------------------------------------------------------
# CHECK DOUBLE BOOKING
# ---------------------------------------------------------
def is_room_available(db: Session, room_id: int, check_in: datetime, check_out: datetime):
    return (
        db.query(Booking)
        .filter(
            Booking.room_id == room_id,
            Booking.status == BookingStatus.confirmed,
            Booking.check_in < check_out,
            Booking.check_out > check_in
        )
        .first()
        is None
    )


# ---------------------------------------------------------
# CREATE BOOKING
# ---------------------------------------------------------
@router.post("/", response_model=BookingResponseSchema)
def create_booking(payload: BookingCreateSchema, db: Session = Depends(get_db)):

    room = db.query(Room).filter(Room.id == payload.room_id).first()
    if not room:
        raise HTTPException(404, "Room not found")

    if room.available_beds <= 0:
        raise HTTPException(400, "No beds available in this room")

    # Prevent overlapping confirmed bookings
    if not is_room_available(db, payload.room_id, payload.check_in, payload.check_out):
        raise HTTPException(400, "Room is not available for these dates")

    booking = Booking(
        hostel_id=payload.hostel_id,
        room_id=payload.room_id,
        visitor_id=payload.visitor_id,
        check_in=payload.check_in,
        check_out=payload.check_out,
        amount_paid=payload.amount_paid,
        status=BookingStatus.pending,
    )

    db.add(booking)
    db.commit()
    db.refresh(booking)

    return booking


# ---------------------------------------------------------
# GET ALL BOOKINGS
# ---------------------------------------------------------
@router.get("/", response_model=List[BookingResponseSchema])
def list_bookings(db: Session = Depends(get_db)):
    return db.query(Booking).all()


# ---------------------------------------------------------
# GET SINGLE BOOKING
# ---------------------------------------------------------
@router.get("/{booking_id}", response_model=BookingResponseSchema)
def get_booking(booking_id: int, db: Session = Depends(get_db)):
    booking = db.query(Booking).filter(Booking.id == booking_id).first()
    if not booking:
        raise HTTPException(404, "Booking not found")
    return booking


# ---------------------------------------------------------
# UPDATE BOOKING DETAILS (DATE, ROOM)
# ---------------------------------------------------------
@router.put("/{booking_id}", response_model=BookingResponseSchema)
def update_booking(booking_id: int, payload: BookingUpdateSchema, db: Session = Depends(get_db)):

    booking = db.query(Booking).filter(Booking.id == booking_id).first()
    if not booking:
        raise HTTPException(404, "Booking not found")

    # Changing Room → Check availability first
    if payload.room_id:
        room = db.query(Room).filter(Room.id == payload.room_id).first()
        if not room:
            raise HTTPException(404, "Room not found")

        if not is_room_available(
            db, payload.room_id,
            payload.check_in or booking.check_in,
            payload.check_out or booking.check_out
        ):
            raise HTTPException(400, "New room not available on selected dates")

        booking.room_id = payload.room_id

    # Update dates
    if payload.check_in:
        booking.check_in = payload.check_in
    if payload.check_out:
        booking.check_out = payload.check_out

    db.commit()
    db.refresh(booking)
    return booking


# ---------------------------------------------------------
# UPDATE STATUS (ADMIN)
# ---------------------------------------------------------
@router.patch("/{booking_id}/status", response_model=BookingResponseSchema)
def update_status(booking_id: int, payload: BookingStatusUpdateSchema, db: Session = Depends(get_db)):

    booking = db.query(Booking).filter(Booking.id == booking_id).first()
    if not booking:
        raise HTTPException(404, "Booking not found")

    new_status = payload.status

    # When confirming, ensure room has free beds
    if new_status == BookingStatus.confirmed:
        room = db.query(Room).filter(Room.id == booking.room_id).first()
        if room.available_beds <= 0:
            raise HTTPException(400, "No beds available to confirm booking")

        room.available_beds -= 1

    # When canceling → release bed
    if new_status == BookingStatus.cancelled:
        room = db.query(Room).filter(Room.id == booking.room_id).first()
        room.available_beds += 1

    booking.status = new_status
    db.commit()
    db.refresh(booking)
    return booking


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\bookings_modify.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.dependencies import get_db
from app.schemas.booking import BookingUpdate, BookingResponse
from app.services.booking_service import BookingService


router = APIRouter(
    prefix="/admin/bookings",
    tags=["Admin Booking Modification"]
)


@router.put("/{booking_id}/modify", response_model=BookingResponse)
def admin_modify_booking(
    booking_id: int,
    updates: BookingUpdate,
    db: Session = Depends(get_db)
):
    """
    Admin-level booking modification:
    - Change room
    - Change dates
    - Change both
    - Checks for overlap automatically
    """
    updated = BookingService.modify_booking(db, booking_id, updates)
    return updated


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\calendar.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from datetime import date, timedelta

from app.core.database import get_db
from app.models.booking import Booking, BookingStatus
from app.models.rooms import Room
from app.services.booking_service import BookingService   # ⭐ REQUIRED IMPORT

router = APIRouter(prefix="/calendar", tags=["Calendar"])


# ---------------------------------------------------------
# Helper: Date Range Generator
# ---------------------------------------------------------
def generate_date_range(start: date, end: date):
    days = (end - start).days
    return [start + timedelta(days=i) for i in range(days)]


# ---------------------------------------------------------
# 1. CALENDAR FOR A SINGLE ROOM
# ---------------------------------------------------------
@router.get("/room/{room_id}")
def room_calendar(room_id: int, db: Session = Depends(get_db)):

    room = db.query(Room).filter(Room.id == room_id).first()
    if not room:
        raise HTTPException(404, "Room not found")

    bookings = (
        db.query(Booking)
        .filter(Booking.room_id == room_id)
        .all()
    )

    booked_dates = []
    pending_dates = []

    for b in bookings:
        days = generate_date_range(b.check_in.date(), b.check_out.date())

        if b.status == BookingStatus.confirmed.value:
            booked_dates.extend(days)
        elif b.status == BookingStatus.pending.value:
            pending_dates.extend(days)

    return {
        "room_id": room.id,
        "hostel_id": room.hostel_id,
        "room_type": room.room_type,
        "booked_dates": booked_dates,
        "pending_dates": pending_dates,
        "available_beds": room.available_beds,
        "total_beds": room.total_beds,
    }


# ---------------------------------------------------------
# 2. CALENDAR FOR ENTIRE HOSTEL
# ---------------------------------------------------------
@router.get("/hostel/{hostel_id}")
def hostel_calendar(hostel_id: int, db: Session = Depends(get_db)):

    rooms = db.query(Room).filter(Room.hostel_id == hostel_id).all()
    if not rooms:
        raise HTTPException(404, "No rooms found for this hostel")

    hostel_calendar_data = []

    for room in rooms:
        bookings = (
            db.query(Booking)
            .filter(Booking.room_id == room.id)
            .all()
        )

        booked_dates = []
        pending_dates = []

        for b in bookings:
            days = generate_date_range(b.check_in.date(), b.check_out.date())

            if b.status == BookingStatus.confirmed.value:
                booked_dates.extend(days)
            elif b.status == BookingStatus.pending:
                pending_dates.extend(days)

        hostel_calendar_data.append({
            "room_id": room.id,
            "room_type": room.room_type,
            "booked_dates": booked_dates,
            "pending_dates": pending_dates,
            "available_beds": room.available_beds,
            "total_beds": room.total_beds,
        })

    return {
        "hostel_id": hostel_id,
        "rooms": hostel_calendar_data
    }


# ---------------------------------------------------------
# 3. DRAG & DROP CHECK → Can move booking?
# ---------------------------------------------------------
@router.get("/drag-drop/validate")
def validate_drag_drop(
    booking_id: int,
    new_room_id: int,
    new_check_in: date,
    new_check_out: date,
    db: Session = Depends(get_db)
):

    booking = db.query(Booking).filter(Booking.id == booking_id).first()
    if not booking:
        raise HTTPException(404, "Booking not found")

    # Check room exists
    room = db.query(Room).filter(Room.id == new_room_id).first()
    if not room:
        raise HTTPException(404, "Room not found")

    # Conflict detection
    conflict = (
        db.query(Booking)
        .filter(
            Booking.room_id == new_room_id,
            Booking.status == BookingStatus.confirmed,
            Booking.id != booking_id,
            Booking.check_in < new_check_out,
            Booking.check_out > new_check_in
        )
        .first()
    )

    if conflict:
        return {
            "can_move": False,
            "reason": "Room already booked on selected dates"
        }

    return {"can_move": True}


# ---------------------------------------------------------
# ⭐ NEW → 4. APPLY DRAG & DROP CHANGE (ADMIN)
# ---------------------------------------------------------
@router.post("/drag-drop/apply")
def apply_drag_drop(
    booking_id: int,
    new_room_id: int,
    new_check_in: date,
    new_check_out: date,
    db: Session = Depends(get_db)
):
    """
    Applies actual calendar drag-drop:
    - Moves booking to new room
    - Updates start/end dates
    - Race-safe with row-level locking
    - Uses BookingService.admin_modify_booking()
    """

    updates = {
        "room_id": new_room_id,
        "check_in": new_check_in,
        "check_out": new_check_out
    }

    updated = BookingService.admin_modify_booking(
        db=db,
        booking_id=booking_id,
        updates=updates
    )

    return {
        "message": "Booking updated successfully",
        "booking_id": updated.id,
        "new_room_id": updated.room_id,
        "new_check_in": updated.check_in,
        "new_check_out": updated.check_out
    }


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\comparison_router.py ---
# app/api/v1/comparison_router.py
from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.schemas.comparison import HostelComparisonRequest, HostelComparisonItem
from app.services.comparison_service import compare_hostels as service_compare_hostels

router = APIRouter(prefix="/api/v1/hostels", tags=["hostels"])


@router.post("/compare", response_model=List[HostelComparisonItem])
def compare_hostels(payload: HostelComparisonRequest, db: Session = Depends(get_db)):
    """
    Compare up to N hostels (validated by schema). Returns pricing, amenities, counts.
    Endpoint kept under /api/v1/hostels/compare for backward compatibility.
    """
    return service_compare_hostels(db, payload.hostel_ids)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\complaints.py ---
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import Optional
from datetime import datetime
from sqlalchemy import select

from app.core.database import get_db
from app.repositories.complaint_repository import ComplaintRepository
from app.services.complaint_service import ComplaintService
from app.models.complaint import Complaint, ComplaintStatus
from app.schemas.complaint import (
    ComplaintResponse,
    ComplaintDetailResponse,
    ComplaintListResponse,
    ComplaintFilter,
    ComplaintAssignment,
    ComplaintUpdate,
    ComplaintAnalytics
)

router = APIRouter(prefix="/admin/complaints", tags=["Admin Complaints"])


# ------------------------------------------------------------------------------------
# LIST ALL COMPLAINTS
# ------------------------------------------------------------------------------------
@router.get("/", response_model=ComplaintListResponse)
async def list_all_complaints(
    hostel_name: Optional[str] = None,
    category: Optional[str] = None,
    status_filter: Optional[str] = None,
    priority: Optional[str] = None,
    assigned_to_email: Optional[str] = None,
    student_email: Optional[str] = None,
    is_escalated: Optional[bool] = None,
    start_date: Optional[datetime] = Query(None),
    end_date: Optional[datetime] = Query(None),
    page: int = 1,
    page_size: int = 10,
    db: Session = Depends(get_db)
):
    filters = ComplaintFilter(
        hostel_name=hostel_name,
        category=category,
        status=status_filter,
        priority=priority,
        assigned_to_email=assigned_to_email,
        student_email=student_email,
        is_escalated=is_escalated,
        start_date=start_date,
        end_date=end_date,
        page=page,
        page_size=page_size
    )

    service = ComplaintService(ComplaintRepository(db))
    complaints, total = await service.list_complaints(filters)

    return {
        "total": total,
        "page": page,
        "page_size": page_size,
        "total_pages": (total + page_size - 1) // page_size,
        "complaints": complaints
    }


# ------------------------------------------------------------------------------------
# GET SINGLE COMPLAINT
# ------------------------------------------------------------------------------------
@router.get("/{complaint_id}", response_model=ComplaintDetailResponse)
async def get_complaint(complaint_id: int, db: Session = Depends(get_db)):
    service = ComplaintService(ComplaintRepository(db))
    result = await service.get_complaint_with_details(complaint_id)

    if not result:
        raise HTTPException(404, "Complaint not found")

    complaint = result["complaint"]

    return {
        **complaint.__dict__,
        "attachments": result["attachments"],
        "notes": result["notes"]
    }


# ------------------------------------------------------------------------------------
# UPDATE COMPLAINT
# ------------------------------------------------------------------------------------
@router.patch("/{complaint_id}", response_model=ComplaintResponse)
async def update_complaint(complaint_id: int, update_data: ComplaintUpdate, db: Session = Depends(get_db)):
    service = ComplaintService(ComplaintRepository(db))
    complaint = await service.update_complaint(complaint_id, update_data)

    if not complaint:
        raise HTTPException(404, "Complaint not found")

    return complaint


# ------------------------------------------------------------------------------------
# REASSIGN COMPLAINT
# ------------------------------------------------------------------------------------
@router.post("/{complaint_id}/reassign", response_model=ComplaintResponse)
async def reassign_complaint(complaint_id: int, assignment_data: ComplaintAssignment, db: Session = Depends(get_db)):
    service = ComplaintService(ComplaintRepository(db))

    complaint = await service.reassign_complaint(
        complaint_id,
        assignment_data.assigned_to_name,
        assignment_data.assigned_to_email
    )

    if not complaint:
        raise HTTPException(404, "Complaint not found")

    return complaint


# ------------------------------------------------------------------------------------
# ANALYTICS — OVERVIEW
# ------------------------------------------------------------------------------------
@router.get("/analytics/overview", response_model=ComplaintAnalytics)
async def get_complaint_analytics(
    hostel_name: Optional[str] = Query(None),
    start_date: Optional[datetime] = Query(None),
    end_date: Optional[datetime] = Query(None),
    db: Session = Depends(get_db)
):
    service = ComplaintService(ComplaintRepository(db))
    result = await service.get_analytics(hostel_name, start_date, end_date)
    return result


# ------------------------------------------------------------------------------------
# ANALYTICS — CROSS HOSTEL
# ------------------------------------------------------------------------------------
@router.get("/analytics/cross-hostel")
async def get_cross_hostel_analytics(
    start_date: Optional[datetime] = Query(None),
    end_date: Optional[datetime] = Query(None),
    db: Session = Depends(get_db)
):
    service = ComplaintService(ComplaintRepository(db))

    hostels = [row[0] for row in db.execute(select(Complaint.hostel_name).distinct()).all()]
    cross_hostel_data = []

    for hostel_name in hostels:
        analytics = await service.get_analytics(hostel_name, start_date, end_date)
        cross_hostel_data.append({"hostel_name": hostel_name, "analytics": analytics})

    category_counts = {}
    for hostel_data in cross_hostel_data:
        for category, count in hostel_data["analytics"]["category_distribution"].items():
            category_counts[category] = category_counts.get(category, 0) + count

    systemic_issues = sorted(
        [{"category": k, "total_complaints": v} for k, v in category_counts.items()],
        key=lambda x: x["total_complaints"],
        reverse=True
    )

    return {
        "hostel_analytics": cross_hostel_data,
        "systemic_issues": systemic_issues,
        "total_hostels": len(hostels)
    }


# ------------------------------------------------------------------------------------
# ANALYTICS — SUPERVISOR PERFORMANCE
# ------------------------------------------------------------------------------------
@router.get("/analytics/supervisor-performance")
async def get_all_supervisor_performance(
    hostel_name: Optional[str] = Query(None),
    start_date: Optional[datetime] = Query(None),
    end_date: Optional[datetime] = Query(None),
    db: Session = Depends(get_db)
):
    service = ComplaintService(ComplaintRepository(db))

    query = select(
        Complaint.assigned_to_email,
        Complaint.assigned_to_name
    ).distinct().where(Complaint.assigned_to_email.isnot(None))

    if hostel_name:
        query = query.where(Complaint.hostel_name.ilike(f"%{hostel_name}%"))

    supervisors = db.execute(query).all()
    performance_data = []

    for supervisor_email, supervisor_name in supervisors:
        if not supervisor_email:
            continue

        performance = await service.get_supervisor_performance(
            supervisor_email,
            start_date,
            end_date
        )

        performance["supervisor_name"] = supervisor_name
        performance_data.append(performance)

    performance_data.sort(
        key=lambda x: x["average_resolution_time_hours"] or float("inf")
    )

    return {
        "total_supervisors": len(performance_data),
        "supervisors": performance_data
    }


# ------------------------------------------------------------------------------------
# ANALYTICS — SLA VIOLATIONS
# ------------------------------------------------------------------------------------
@router.get("/analytics/sla-violations")
async def get_sla_violations(
    hostel_name: Optional[str] = Query(None),
    db: Session = Depends(get_db)
):
    now = datetime.utcnow()

    query = select(Complaint).where(
        Complaint.sla_deadline.isnot(None),
        Complaint.sla_deadline < now,
        Complaint.status.notin_([ComplaintStatus.RESOLVED, ComplaintStatus.CLOSED])
    )

    if hostel_name:
        query = query.where(Complaint.hostel_name.ilike(f"%{hostel_name}%"))

    violations = db.execute(query.order_by(Complaint.sla_deadline.asc())).scalars().all()

    data = []
    for complaint in violations:
        hours_overdue = (now - complaint.sla_deadline).total_seconds() / 3600
        data.append({
            "id": complaint.id,
            "title": complaint.title,
            "category": complaint.category.value,
            "priority": complaint.priority.value,
            "status": complaint.status.value,
            "hostel_name": complaint.hostel_name,
            "assigned_to_email": complaint.assigned_to_email,
            "sla_deadline": complaint.sla_deadline,
            "hours_overdue": round(hours_overdue, 2),
            "created_at": complaint.created_at
        })

    return {"total_violations": len(data), "violations": data}


# ------------------------------------------------------------------------------------
# ANALYTICS — ESCALATED COMPLAINTS
# ------------------------------------------------------------------------------------
@router.get("/analytics/escalated")
async def get_escalated_complaints(
    hostel_name: Optional[str] = Query(None),
    page: int = 1,
    page_size: int = 10,
    db: Session = Depends(get_db)
):
    filters = ComplaintFilter(
        hostel_name=hostel_name,
        is_escalated=True,
        page=page,
        page_size=page_size
    )

    service = ComplaintService(ComplaintRepository(db))
    complaints, total = await service.list_complaints(filters)

    return {
        "total": total,
        "page": page,
        "page_size": page_size,
        "total_pages": (total + page_size - 1) // page_size,
        "complaints": complaints
    }


# ------------------------------------------------------------------------------------
# DELETE COMPLAINT
# ------------------------------------------------------------------------------------
@router.delete("/{complaint_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_complaint(complaint_id: int, db: Session = Depends(get_db)):
    repo = ComplaintRepository(db)
    complaint = repo.get_by_id(complaint_id)

    if not complaint:
        raise HTTPException(404, "Complaint not found")

    repo.delete(complaint)
    return None


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\dashboard.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\fee_structure_configuration.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.schemas import fee_structure_schemas as schemas
from app.services.fee_structure_service import FeeStructureService

router = APIRouter(prefix="/fee-structure", tags=["Fee Structure Configuration"])

@router.post("/hostels", response_model=schemas.HostelRead, status_code=200)
def create_hostel(data: schemas.HostelCreate, db: Session = Depends(get_db)):
    try:
        return FeeStructureService(db).create_hostel(data)
    except Exception as e:
        return {"message": "Hostel created successfully (mock response)", "error": str(e)}

@router.get("/hostels", response_model=list[schemas.HostelRead])
def list_hostels(db: Session = Depends(get_db)):
    return FeeStructureService(db).list_hostels()

@router.post("/fee-plans", response_model=schemas.FeePlanRead)
def create_fee_plan(data: schemas.FeePlanCreate, db: Session = Depends(get_db)):
    return FeeStructureService(db).create_fee_plan(data)

@router.post("/security-deposits", response_model=schemas.SecurityDepositRead)
def create_deposit(data: schemas.SecurityDepositCreate, db: Session = Depends(get_db)):
    return FeeStructureService(db).create_deposit(data)

@router.post("/mess-charges", response_model=schemas.MessChargeRead)
def create_mess_charge(data: schemas.MessChargeCreate, db: Session = Depends(get_db)):
    return FeeStructureService(db).create_mess_charge(data)

@router.post("/additional-services", response_model=schemas.AdditionalServiceRead)
def create_service(data: schemas.AdditionalServiceCreate, db: Session = Depends(get_db)):
    return FeeStructureService(db).create_service(data)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\hostels.py ---
"""
Multi-hostel authorization
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.core.roles import Role
from app.api.deps import role_required, get_current_active_user
from app.models.user import User
from app.services.tenant_service import TenantService
from app.schemas.hostel import HostelResponse

router = APIRouter()


@router.get("/hostels", response_model=List[dict], status_code=status.HTTP_200_OK)
async def get_user_hostels(
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get hostels user has access to"""
    tenant_service = TenantService(db)
    return tenant_service.get_user_hostels(current_user.id, current_user.role)


@router.post("/hostels/{hostel_id}/assign-admin/{admin_id}", response_model=dict, status_code=status.HTTP_200_OK)
async def assign_admin_to_hostel(
    hostel_id: int,
    admin_id: int,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Assign admin to hostel (Superadmin only)"""
    tenant_service = TenantService(db)
    return tenant_service.assign_admin_to_hostel(admin_id, hostel_id, current_user.role)






# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\hostel_selector.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\invoices.py ---
# app/api/v1/routers/invoices.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.core.database import SessionLocal, Base, engine, get_db
from app.schemas.payment_schemas import InvoiceCreate, InvoiceResponse
from app.services.payment_services import PaymentService


router = APIRouter()
# ensure tables created (safe)
# Base.metadata.create_all(bind=engine)

# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()

@router.post("/", response_model=InvoiceResponse, status_code=status.HTTP_201_CREATED)
def create_invoice(invoice: InvoiceCreate, db: Session = Depends(get_db)):
    try:
        created = PaymentService.create_invoice(
            db=db,
            user_id=invoice.user_id,
            hostel_id=invoice.hostel_id,
            items=[it.dict() for it in invoice.items],
            description=invoice.description,
            due_date=invoice.due_date
        )
        return created
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{invoice_id}", response_model=InvoiceResponse)
def get_invoice(invoice_id: int, db: Session = Depends(get_db)):
    inv = db.query(__import__("app").models.payment_models.Invoice).filter(__import__("app").models.payment_models.Invoice.id == invoice_id).first()
    if not inv:
        raise HTTPException(status_code=404, detail="Invoice not found")
    return inv

@router.get("/user/{user_id}", response_model=list[InvoiceResponse])
def get_user_invoices(user_id: int, db: Session = Depends(get_db)):
    invoices = db.query(__import__("app").models.payment_models.Invoice).filter(__import__("app").models.payment_models.Invoice.user_id == user_id).order_by(__import__("app").models.payment_models.Invoice.created_at.desc()).all()
    return invoices


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\ledger_routes.py ---
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from datetime import date
from typing import Optional
from app.services.ledger_service import LedgerService
from app.core.database import get_db


router = APIRouter(prefix="/ledger", tags=["Payment Ledger & Reports"])


# ---------------------------------------------------------
# 🔹 Transaction History (user_id instead of student_id)
# ---------------------------------------------------------
@router.get("/transactions")
def get_transaction_history(
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    hostel_id: Optional[int] = Query(None),
    user_id: Optional[int] = Query(None),       # 🔥 updated
    transaction_type: Optional[str] = Query(None),
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=200),
    db: Session = Depends(get_db)
):
    return LedgerService(db).get_transaction_history(
        start_date=start_date,
        end_date=end_date,
        hostel_id=hostel_id,
        user_id=user_id,                          # 🔥 updated
        transaction_type=transaction_type,
        page=page,
        page_size=page_size
    )


# ---------------------------------------------------------
# 🔹 Outstanding Payments
# ---------------------------------------------------------
@router.get("/outstanding")
def get_outstanding_payments(
    hostel_id: Optional[int] = Query(None),
    overdue_only: bool = Query(False),
    db: Session = Depends(get_db)
):
    return LedgerService(db).get_outstanding_payments_report(
        hostel_id=hostel_id,
        overdue_only=overdue_only
    )


# ---------------------------------------------------------
# 🔹 Revenue by Hostel
# ---------------------------------------------------------
@router.get("/reports/revenue-by-hostel")
def get_revenue_by_hostel(
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    db: Session = Depends(get_db)
):
    return LedgerService(db).get_revenue_report_by_hostel(
        start_date=start_date,
        end_date=end_date
    )


# ---------------------------------------------------------
# 🔹 Monthly Revenue
# ---------------------------------------------------------
@router.get("/reports/monthly-revenue/{year}")
def monthly_revenue(
    year: int,
    hostel_id: Optional[int] = Query(None),
    db: Session = Depends(get_db)
):
    return LedgerService(db).report_repo.get_monthly_revenue_report(
        year=year,
        hostel_id=hostel_id
    )


# ---------------------------------------------------------
# 🔹 Payment Method Breakdown
# ---------------------------------------------------------
@router.get("/reports/payment-methods")
def payment_methods(
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    hostel_id: Optional[int] = None,
    db: Session = Depends(get_db)
):
    return LedgerService(db).report_repo.get_payment_method_breakdown(
        start_date=start_date,
        end_date=end_date,
        hostel_id=hostel_id
    )


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\maintenance.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\mess_menu.py ---
from fastapi import APIRouter, Depends, Query, status
from typing import List, Optional
from datetime import date
from app.schemas.mess_menu import (
    MessMenuCreate, MessMenuUpdate, MessMenuResponse,
    MenuDuplicationRequest, MenuApprovalRequest
)
from app.services.mess_menu_service import MessMenuService
from app.dependencies import get_mess_menu_service

router = APIRouter(prefix="/admin/mess-menu", tags=["Admin - Mess Menu"])


@router.post("/", response_model=MessMenuResponse, status_code=status.HTTP_201_CREATED)
def create_menu(
    menu: MessMenuCreate,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Create a new mess menu (Admin only)
    - Daily, weekly, or monthly menu planning
    - Special diet accommodation
    - Meal timing configuration per hostel
    """
    return service.create_menu(menu)


@router.get("/{menu_id}", response_model=MessMenuResponse)
def get_menu(
    menu_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get specific menu by ID (Admin only)
    """
    return service.get_menu(menu_id)


@router.get("/hostel/{hostel_id}", response_model=List[MessMenuResponse])
def get_hostel_menus(
    hostel_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    menu_type: Optional[str] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get all menus for a specific hostel with filters (Admin only)
    - Filter by menu type (daily/weekly/monthly)
    - Filter by date range
    """
    return service.get_menus_by_hostel(
        hostel_id, skip, limit, menu_type, start_date, end_date
    )


@router.put("/{menu_id}", response_model=MessMenuResponse)
def update_menu(
    menu_id: int,
    menu_update: MessMenuUpdate,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Update an existing menu (Admin only)
    - Modify menu items, timing, special diets
    """
    return service.update_menu(menu_id, menu_update)


@router.delete("/{menu_id}", status_code=status.HTTP_200_OK)
def delete_menu(
    menu_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Delete a menu (Admin only)
    """
    return service.delete_menu(menu_id)


@router.post("/duplicate", response_model=List[MessMenuResponse])
def duplicate_menu(
    duplication_request: MenuDuplicationRequest,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Duplicate menu across multiple hostels (Admin only)
    - Operational efficiency by copying menus
    - Optionally change target date
    """
    return service.duplicate_menu(duplication_request)


@router.post("/{menu_id}/approve", response_model=MessMenuResponse)
def approve_menu(
    menu_id: int,
    approval: MenuApprovalRequest,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Approve a menu proposed by supervisor (Admin only)
    - Approval workflow for collaborative management
    """
    return service.approve_menu(menu_id, approval)


@router.get("/hostel/{hostel_id}/dietary-restrictions", response_model=dict)
def get_dietary_restrictions_report(
    hostel_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get dietary restrictions report for a hostel (Admin only)
    - Summary of students with special dietary needs
    - Allergy distribution
    - Diet type distribution
    """
    return service.get_dietary_restrictions_report(hostel_id)

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\notification.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.schemas.notification import NotificationCreate, NotificationOut
from app.services.notification_service import NotificationService
from app.core.database import get_db
from app.schemas.notification import TemplateCreate, TemplateOut
from app.models.notification import NotificationTemplate
from typing import List
from fastapi import Body

router = APIRouter(prefix="/admin/notifications", tags=["admin-notifications"])


@router.post("/notify", response_model=NotificationOut)
def notify_admin(payload: NotificationCreate, db: Session = Depends(get_db)):
	svc = NotificationService(db)
	try:
		notif = svc.send_notification(
			recipient_id=payload.recipient_id,
			recipient_type=payload.recipient_type,
			channel=payload.channel,
			subject=payload.subject or "",
			body=payload.body or "",
		)
		return notif
	except Exception as exc:
		raise HTTPException(status_code=500, detail=str(exc))


@router.post("/templates", response_model=TemplateOut)
def create_template(payload: TemplateCreate, db: Session = Depends(get_db)):
	repo = NotificationService(db).repo
	tpl = repo.get_template_by_name(payload.name)
	if tpl:
		raise HTTPException(status_code=400, detail="template_exists")
	new = NotificationTemplate(
		name=payload.name,
		channel=payload.channel,
		subject_template=payload.subject_template,
		body_template=payload.body_template,
	)
	created = repo.create_template(new)
	return created


@router.get("/templates", response_model=List[TemplateOut])
def list_templates(db: Session = Depends(get_db)):
	repo = NotificationService(db).repo
	return repo.list_templates()


@router.get("/templates/{template_id}", response_model=TemplateOut)
def get_template(template_id: int, db: Session = Depends(get_db)):
	repo = NotificationService(db).repo
	tpl = repo.get_template(template_id)
	if not tpl:
		raise HTTPException(status_code=404, detail="not_found")
	return tpl


@router.put("/templates/{template_id}", response_model=TemplateOut)
def update_template(template_id: int, payload: TemplateCreate, db: Session = Depends(get_db)):
	svc = NotificationService(db)
	repo = svc.repo
	tpl = repo.get_template(template_id)
	if not tpl:
		raise HTTPException(status_code=404, detail="not_found")
	updated = repo.update_template(tpl, payload.dict())
	return updated


@router.delete("/templates/{template_id}")
def delete_template(template_id: int, db: Session = Depends(get_db)):
	repo = NotificationService(db).repo
	tpl = repo.get_template(template_id)
	if not tpl:
		raise HTTPException(status_code=404, detail="not_found")
	repo.delete_template(tpl)
	return {"deleted": True}


@router.post("/route", response_model=List[dict])
def route_example(payload: dict = Body(...), db: Session = Depends(get_db)):
	"""Demonstrate routing/escalation for a recipient. Payload must include recipient_id and recipient_type."""
	recipient_id = payload.get("recipient_id")
	recipient_type = payload.get("recipient_type")
	if not recipient_id or not recipient_type:
		raise HTTPException(status_code=400, detail="recipient_id and recipient_type required")
	svc = NotificationService(db)
	routed = svc.route_recipients(recipient_id, recipient_type)
	return [{"recipient_id": r[0], "recipient_type": r[1]} for r in routed]


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\payments.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\payment_routers.py ---
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.schemas.payment_schemas import CreateOrderRequest
from app.services.payment_services import RazorpayService
from app.core.security import get_current_user
from app.models.user import User

router = APIRouter(prefix="/payments/razorpay", tags=["Razorpay Payments"])


@router.post("/create-order")
def create_razorpay_order(
    request: CreateOrderRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)    # 🔥 FIXED
):
    try:
        return RazorpayService.create_order(
            db=db,
            request=request,
            current_user=current_user                  # 🔥 passes real user
        )
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Payment creation failed: {str(e)}")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\permissions.py ---
"""
Manage supervisor permission rules
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.core.roles import Role
from app.api.deps import role_required, get_current_active_user
from app.models.user import User
from app.services.permission_service import PermissionService
from app.schemas.permission import RolePermissionAssign

router = APIRouter()


@router.post("/permissions/assign", response_model=dict, status_code=status.HTTP_200_OK)
async def assign_permission_to_role(
    assign_data: RolePermissionAssign,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Assign permission to role (Superadmin only)"""
    permission_service = PermissionService(db)
    return permission_service.assign_permission_to_role(assign_data)


@router.get("/permissions/role/{role}", response_model=dict, status_code=status.HTTP_200_OK)
async def get_role_permissions(
    role: str,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get all permissions for a role"""
    permission_service = PermissionService(db)
    return permission_service.get_role_permissions(role)


@router.get("/permissions/all", response_model=List[dict], status_code=status.HTTP_200_OK)
async def get_all_permissions(
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get all available permissions"""
    permission_service = PermissionService(db)
    return permission_service.get_all_permissions()



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\rbac.py ---
"""
Role management endpoints
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.core.roles import Role
from app.api.deps import role_required, get_current_active_user
from app.models.user import User
from app.services.rbac_service import RBACService
from app.services.role_service import RoleService
from app.schemas.rbac import RoleAssign, PermissionCheck, RolePermissionsResponse

router = APIRouter()


@router.post("/rbac/assign-role", response_model=dict, status_code=status.HTTP_200_OK)
async def assign_role(
    assign_data: RoleAssign,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Assign role to user"""
    rbac_service = RBACService(db)
    return rbac_service.assign_role(assign_data, current_user.role)


@router.post("/rbac/check-permission", response_model=dict, status_code=status.HTTP_200_OK)
async def check_permission(
    check_data: PermissionCheck,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Check if role has permission"""
    rbac_service = RBACService(db)
    has_perm = rbac_service.check_permission(check_data)
    return {
        "role": check_data.role,
        "permission": check_data.permission,
        "has_permission": has_perm
    }


@router.get("/rbac/roles", response_model=List[str], status_code=status.HTTP_200_OK)
async def get_all_roles(
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get all available roles"""
    role_service = RoleService(db)
    return role_service.get_all_available_roles()


@router.get("/rbac/role/{role}/permissions", response_model=RolePermissionsResponse, status_code=status.HTTP_200_OK)
async def get_role_permissions(
    role: str,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get all permissions for a role"""
    rbac_service = RBACService(db)
    return rbac_service.get_role_permissions_list(role)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\receipts.py ---
# app/api/v1/routers/receipts.py
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
from app.core.database import SessionLocal, get_db
from app.models.payment_models import Receipt
from app.utils.receipt_generatorss import generate_receipt_pdf

router = APIRouter()

# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()

@router.get("/transaction/{transaction_id}")
def get_receipt_by_transaction(transaction_id: int, db: Session = Depends(get_db)):
    receipt = db.query(Receipt).filter(Receipt.transaction_id == transaction_id).first()
    if not receipt:
        raise HTTPException(status_code=404, detail="Receipt not found")
    return {
        "id": receipt.id,
        "receipt_number": receipt.receipt_number,
        "pdf_path": receipt.pdf_path
    }

@router.get("/{receipt_id}/download")
def download_receipt(receipt_id: int, db: Session = Depends(get_db)):
    receipt = db.query(Receipt).filter(Receipt.id == receipt_id).first()
    if not receipt:
        raise HTTPException(status_code=404, detail="Receipt not found")
    if not receipt.pdf_path or not __import__("os").path.exists(receipt.pdf_path):
        # regenerate
        tx = receipt.transaction
        inv = receipt.invoice
        path = generate_receipt_pdf(receipt, inv, tx)
        receipt.pdf_path = path
        db.commit()
    return FileResponse(receipt.pdf_path, media_type="application/pdf", filename=f"receipt_{receipt.receipt_number}.pdf")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\refunds.py ---
# app/api/v1/routers/refunds.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.core.database import SessionLocal, get_db
from app.schemas.payment_schemas import RefundCreate, RefundApproval
from app.services.payment_services import PaymentService
from app.models.payment_models import RefundRequest, Invoice, Transaction, PaymentStatus
from app.models.payment_models import TransactionType
from datetime import datetime
import uuid
import traceback


router = APIRouter()

# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()

@router.post("/request")
def request_refund(refund: RefundCreate, db: Session = Depends(get_db)):
    try:
        req = PaymentService.request_refund(
            db=db,
            transaction_id=refund.transaction_id,
            refund_amount=refund.refund_amount,
            reason=refund.reason,
            requested_by=refund.requested_by
        )
        return req
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/{refund_id}/approve")
def approve_refund(refund_id: int, approval: RefundApproval, db: Session = Depends(get_db)):
    """
    Approves or rejects a refund request.
    Creates a refund transaction and updates invoice if approved.
    """
    # 🔍 1. Fetch refund record
    refund = db.query(RefundRequest).filter(RefundRequest.id == refund_id).first()
    if not refund:
        raise HTTPException(status_code=404, detail="Refund request not found")

    # 🚫 Already processed
    if refund.status not in ["initiated", "processing"]:
        raise HTTPException(status_code=400, detail=f"Refund already {refund.status}")

    try:
        if approval.approve:
            # 🧾 Generate transaction ID safely
            txn_id = (
                PaymentService.generate_transaction_id()
                if hasattr(PaymentService, "generate_transaction_id")
                else f"TXN-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8].upper()}"
            )

            # 💸 Create refund transaction
            txn = Transaction(
                transaction_id=txn_id,
                invoice_id=refund.invoice_id,
                transaction_type=TransactionType.REFUND.value,
                amount=-abs(refund.refund_amount),
                payment_method="refund",
                notes=f"Refund processed: {refund.reason}",
                status="success",
                processed_by=approval.approved_by,
                created_at=datetime.utcnow()
            )
            db.add(txn)

            # 🧾 Fetch invoice and update totals
            invoice = db.query(Invoice).filter(Invoice.id == refund.invoice_id).first()
            if not invoice:
                raise HTTPException(status_code=404, detail="Invoice linked to refund not found")

            invoice.paid_amount = max(invoice.paid_amount - refund.refund_amount, 0)
            invoice.due_amount += refund.refund_amount

            if invoice.paid_amount <= 0:
                invoice.status = PaymentStatus.PENDING.value
            elif invoice.due_amount > 0:
                invoice.status = PaymentStatus.PENDING.value
            else:
                invoice.status = PaymentStatus.SUCCESS.value

            # ✅ Update refund record
            refund.status = "completed"
            refund.approved_by = approval.approved_by
            refund.processed_at = datetime.utcnow()
            refund.completed_at = datetime.utcnow()

            message = "Refund approved successfully"

        else:
            # ❌ Refund rejected
            refund.status = "rejected"
            refund.rejection_reason = approval.rejection_reason
            refund.approved_by = approval.approved_by
            refund.processed_at = datetime.utcnow()
            message = "Refund request rejected"

        # 💾 Commit all changes
        db.commit()
        db.refresh(refund)

        return {
            "success": True,
            "message": message,
            "refund": {
                "refund_id": refund.refund_id,
                "status": refund.status,
                "refund_amount": refund.refund_amount,
                "approved_by": refund.approved_by,
                "processed_at": refund.processed_at,
                "completed_at": refund.completed_at,
            },
        }

    except Exception as e:
        db.rollback()
        print("❌ Refund approval error:", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Refund approval failed: {str(e)}")

# from app.services.payment_services import RefundService
# from app.schemas.payment_schemas import RefundApproval
# @router.post("/{refund_id}/approve")
# def approve_refund(refund_id: int, approval: RefundApproval, db: Session = Depends(get_db)):
#     """Approves or rejects a refund request"""
#     try:
#         service = RefundService(db)
#         if approval.approve:
#             result = service.approve_refund(refund_id, approval)
#         else:
#             result = service.reject_refund(refund_id, approval)
#         return result
#     except ValueError as ve:
#         raise HTTPException(status_code=400, detail=str(ve))
#     except Exception as e:
#         print("❌ Refund approval error:", e)
#         traceback.print_exc()
#         raise HTTPException(status_code=500, detail=f"Refund processing failed: {str(e)}")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\reminder_configs.py ---
# app/api/v1/routers/configs.py

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.core.database import SessionLocal,get_db
from app.schemas.payment_schemas import ReminderConfigCreate, ReminderConfigResponse
from app.models.payment_models import ReminderConfiguration
import json

router = APIRouter(prefix="/reminders/config", tags=["Reminder Config"])


# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()


# -----------------------------------------------------------
# Create or update config
# -----------------------------------------------------------

@router.post("/", response_model=ReminderConfigResponse)
def save_config(config: ReminderConfigCreate, db: Session = Depends(get_db)):

    existing = db.query(ReminderConfiguration).filter(
        ReminderConfiguration.hostel_id == config.hostel_id
    ).first()

    data = config.dict()
    if data.get("escalation_emails"):
        data["escalation_emails"] = json.dumps(data["escalation_emails"])

    if data.get("escalation_cc"):
        data["escalation_cc"] = json.dumps(data["escalation_cc"])

    if existing:
        for key, val in data.items():
            setattr(existing, key, val)
        db.commit()
        db.refresh(existing)
        return existing

    new_config = ReminderConfiguration(**data)
    db.add(new_config)
    db.commit()
    db.refresh(new_config)
    return new_config


# -----------------------------------------------------------
# Fetch config
# -----------------------------------------------------------

@router.get("/{hostel_id}", response_model=ReminderConfigResponse)
def get_config(hostel_id: int, db: Session = Depends(get_db)):
    config = db.query(ReminderConfiguration).filter(
        ReminderConfiguration.hostel_id == hostel_id
    ).first()

    if not config:
        raise HTTPException(404, "Config not found")

    return config


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\Reminder_rotes.py ---
# app/api/v1/routers/reminders.py

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session
from app.core.database import SessionLocal,get_db
from app.models.payment_models import PaymentReminder, Invoice
from app.schemas.payment_schemas import PaymentReminderResponse
from app.services.reminder_services import (
    create_and_schedule_reminder,
    process_single_reminder
)
from app.models.payment_models import ReminderType, ReminderChannel

router = APIRouter(prefix="/reminders", tags=["Reminders"])


# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()


# -----------------------------------------------------------
# 1️⃣ Get reminders for invoice
# -----------------------------------------------------------

@router.get("/invoice/{invoice_id}", response_model=list[PaymentReminderResponse])
def get_invoice_reminders(invoice_id: int, db: Session = Depends(get_db)):
    reminders = db.query(PaymentReminder).filter(
        PaymentReminder.invoice_id == invoice_id
    ).all()

    return reminders


# -----------------------------------------------------------
# 2️⃣ Send manual reminder
# -----------------------------------------------------------

@router.post("/send-manual")
def send_manual(
    invoice_id: int,
    reminder_type: ReminderType,
    channel: ReminderChannel,
    background: BackgroundTasks,
    db: Session = Depends(get_db)
):

    invoice = db.query(Invoice).filter(Invoice.id == invoice_id).first()
    if not invoice:
        raise HTTPException(404, "Invoice not found")

    create_and_schedule_reminder(invoice, reminder_type, channel, db)
    return {"success": True, "message": "Reminder sent successfully"}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\reminder_templates.py ---
# app/api/v1/routers/templates.py

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.core.database import SessionLocal,get_db
from app.models.payment_models import ReminderTemplate, ReminderType
from app.schemas.payment_schemas import TemplateCreate, TemplateResponse

router = APIRouter(prefix="/reminders/templates", tags=["Reminder Templates"])


# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()


# -----------------------------------------------------------
# Create template
# -----------------------------------------------------------

@router.post("/", response_model=TemplateResponse)
def create_template(template: TemplateCreate, db: Session = Depends(get_db)):
    new_template = ReminderTemplate(**template.dict())
    db.add(new_template)
    db.commit()
    db.refresh(new_template)
    return new_template


# -----------------------------------------------------------
# Get templates
# -----------------------------------------------------------

@router.get("/", response_model=list[TemplateResponse])
def get_templates(reminder_type: ReminderType = None, db: Session = Depends(get_db)):

    query = db.query(ReminderTemplate)
    if reminder_type:
        query = query.filter(ReminderTemplate.reminder_type == reminder_type)

    return query.all()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\reports.py ---
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from datetime import date, datetime, timedelta
from typing import List
from app.core.database import get_db
from app.schemas.reports import *
from app.services.analytics_service import AnalyticsService

router = APIRouter(prefix="/admin/reports", tags=["Admin Reports"])

@router.get("/dashboard")
def get_admin_dashboard(
    hostel_id: int,
    start_date: date = None,
    end_date: date = None,
    db: Session = Depends(get_db)
):
    """Get comprehensive dashboard for a single hostel"""
    if not start_date:
        start_date = date.today().replace(day=1)  # First day of current month
    if not end_date:
        end_date = date.today()
    
    # Get KPI
    kpi = AnalyticsService._get_hostel_kpi(db, hostel_id, start_date, end_date)
    
    # Get complaint metrics
    complaint_metrics = AnalyticsService.get_complaint_metrics(db, [hostel_id], start_date, end_date)
    
    # Get marketing analytics
    marketing = AnalyticsService.get_marketing_analytics(db, [hostel_id], start_date, end_date)
    
    # Get recent complaints
    from app.models.complaint import Complaint
    from app.models.hostel import Hostel
    
    # Get hostel name
    hostel = db.query(Hostel).filter(Hostel.id == hostel_id).first()
    hostel_name = hostel.hostel_name if hostel else "Unknown"
    
    # Query recent complaints for this hostel
    recent_complaints = db.query(Complaint).filter(
        Complaint.hostel_name == hostel_name,
        Complaint.created_at >= datetime.combine(start_date, datetime.min.time()),
        Complaint.created_at <= datetime.combine(end_date, datetime.max.time())
    ).limit(10).all()
    
    return {
        "hostel_id": hostel_id,
        "period": f"{start_date} to {end_date}",
        "kpi": kpi,
        "complaints": complaint_metrics[0] if complaint_metrics else None,
        "marketing": marketing[0] if marketing else None,
        "recent_complaints": recent_complaints,
        "generated_at": datetime.utcnow()
    }

@router.get("/financial/income")
def get_income_statement(
    hostel_id: int,
    start_date: date,
    end_date: date,
    db: Session = Depends(get_db)
):
    """Get income statement for hostel"""
    from sqlalchemy import text
    
    result = db.execute(text("""
        SELECT 
            transaction_type,
            category,
            SUM(amount) as total_amount,
            COUNT(*) as transaction_count
        FROM financial_transactions
        WHERE hostel_id = :hostel_id
        AND transaction_date BETWEEN :start_date AND :end_date
        GROUP BY transaction_type, category
        ORDER BY transaction_type, category
    """), {'hostel_id': hostel_id, 'start_date': start_date, 'end_date': end_date}).fetchall()
    
    revenue = sum(float(row.total_amount) for row in result if row.transaction_type in ['fee', 'booking'])
    expenses = sum(float(row.total_amount) for row in result if row.transaction_type == 'expense')
    
    return {
        "hostel_id": hostel_id,
        "period": f"{start_date} to {end_date}",
        "revenue": revenue,
        "expenses": expenses,
        "profit": revenue - expenses,
        "breakdown": [
            {
                "type": row.transaction_type,
                "category": row.category,
                "amount": float(row.total_amount),
                "count": row.transaction_count
            }
            for row in result
        ]
    }

@router.get("/financial/outstanding-payments")
def get_outstanding_payments(hostel_id: int, db: Session = Depends(get_db)):
    """Get outstanding payment tracking"""
    from sqlalchemy import text
    
    result = db.execute(text("""
        SELECT 
            student_id,
            SUM(amount) as outstanding_amount,
            COUNT(*) as pending_count
        FROM financial_transactions
        WHERE hostel_id = :hostel_id
        AND payment_status = 'pending'
        AND transaction_type = 'fee'
        GROUP BY student_id
        ORDER BY outstanding_amount DESC
    """), {'hostel_id': hostel_id}).fetchall()
    
    return {
        "hostel_id": hostel_id,
        "total_outstanding": sum(float(row.outstanding_amount) for row in result),
        "students": [
            {
                "student_id": row.student_id,
                "outstanding_amount": float(row.outstanding_amount),
                "pending_count": row.pending_count
            }
            for row in result
        ]
    }

@router.get("/operational/occupancy")
def get_occupancy_report(hostel_id: int, start_date: date, end_date: date, 
                        db: Session = Depends(get_db)):
    """Get occupancy reports"""
    trends = AnalyticsService.get_occupancy_trends(db, [hostel_id], start_date, end_date)
    return {"trends": trends}

@router.get("/operational/demographics")
def get_student_demographics(hostel_id: int, db: Session = Depends(get_db)):
    """Get student demographic analysis"""
    from sqlalchemy import text
    
    # This would require a students table - simplified version
    result = db.execute(text("""
        SELECT 
            COUNT(DISTINCT student_id) as total_students
        FROM attendance
        WHERE hostel_id = :hostel_id
        AND date >= CURRENT_DATE - INTERVAL '30 days'
    """), {'hostel_id': hostel_id}).first()
    
    return {
        "hostel_id": hostel_id,
        "total_students": result.total_students or 0
    }

@router.get("/operational/attendance-patterns")
def get_attendance_patterns(hostel_id: int, start_date: date, end_date: date,
                           db: Session = Depends(get_db)):
    """Get attendance patterns and trends"""
    return AnalyticsService.get_attendance_trends(db, hostel_id, start_date, end_date)

@router.get("/operational/complaints")
def get_complaint_metrics(hostel_id: int, start_date: date, end_date: date,
                         db: Session = Depends(get_db)):
    """Get complaint resolution metrics"""
    metrics = AnalyticsService.get_complaint_metrics(db, [hostel_id], start_date, end_date)
    return metrics[0] if metrics else {}

@router.get("/operational/maintenance-costs")
def get_maintenance_costs(hostel_id: int, start_date: date, end_date: date,
                         db: Session = Depends(get_db)):
    """Get maintenance costs and trend analysis"""
    from sqlalchemy import text
    
    # complaints table stores `hostel_name` not `hostel_id`; resolve name first
    from app.models.hostel import Hostel

    hostel = db.query(Hostel).filter(Hostel.id == hostel_id).first()
    hostel_name = hostel.hostel_name if hostel else None

    result = db.execute(text("""
        SELECT 
            DATE_TRUNC('month', resolved_at) as month,
            COUNT(*) as complaint_count,
            SUM(actual_cost) as total_cost,
            AVG(actual_cost) as avg_cost
        FROM complaints
        WHERE hostel_name = :hostel_name
        AND resolved_at BETWEEN :start_date AND :end_date
        AND actual_cost IS NOT NULL
        GROUP BY DATE_TRUNC('month', resolved_at)
        ORDER BY month
    """), {'hostel_name': hostel_name, 'start_date': datetime.combine(start_date, datetime.min.time()), 
           'end_date': datetime.combine(end_date, datetime.max.time())}).fetchall()
    
    return {
        "hostel_id": hostel_id,
        "period": f"{start_date} to {end_date}",
        "monthly_breakdown": [
            {
                "month": str(row.month),
                "complaint_count": row.complaint_count,
                "total_cost": float(row.total_cost or 0),
                "average_cost": float(row.avg_cost or 0)
            }
            for row in result
        ]
    }

@router.get("/marketing/profile-views")
def get_profile_analytics(hostel_id: int, start_date: date, end_date: date,
                         db: Session = Depends(get_db)):
    """Get hostel profile view analytics"""
    analytics = AnalyticsService.get_marketing_analytics(db, [hostel_id], start_date, end_date)
    return analytics[0] if analytics else {}

@router.get("/multi-hostel/comparison")
def compare_hostels(
    hostel_ids: List[int] = Query(...),
    start_date: date = Query(...),
    end_date: date = Query(...),
    db: Session = Depends(get_db)
):
    """Compare revenue and performance across hostels"""
    return AnalyticsService.get_revenue_comparison(
        db, hostel_ids, start_date, end_date,
        start_date - timedelta(days=(end_date - start_date).days),
        start_date - timedelta(days=1)
    )

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\rooms.py ---
from typing import List, Optional
from uuid import UUID  # Unused, kept for reference
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Path
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session
import csv
from io import StringIO

from app.core.database import get_db
from app.schemas.rooms import RoomCreate, RoomOut, RoomUpdate
from app.services.room_service import (
    create_room as service_create_room,
    get_room as service_get_room,
    list_rooms as service_list_rooms,
    update_room as service_update_room,
    delete_room as service_delete_room,
    set_room_maintenance as service_set_room_maintenance,
    set_room_availability as service_set_room_availability,
)
from app.models.rooms import RoomType, MaintenanceStatus

router = APIRouter(prefix="/api/v1/admin/rooms", tags=["rooms"])


@router.post("/", response_model=RoomOut, status_code=status.HTTP_201_CREATED)
def create_room(item: RoomCreate, db: Session = Depends(get_db)):
    try:
        room = service_create_room(db, item)
        room.hostel_id = str(room.hostel_id)  # Ensure hostel_id is returned as a string
        return room
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/", response_model=List[RoomOut])
def read_rooms(
    skip: int = 0,
    limit: int = 100,
    room_type: Optional[str] = None,
    maintenance_status: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    min_capacity: Optional[int] = None,
    only_available: Optional[bool] = None,
    amenities_like: Optional[str] = None,
    db: Session = Depends(get_db),
):
    rt = None
    ms = None
    if room_type:
        try:
            rt = RoomType(room_type)
        except Exception:
            raise HTTPException(status_code=400, detail=f"Invalid room_type: {room_type}")
    if maintenance_status:
        try:
            ms = MaintenanceStatus(maintenance_status)
        except Exception:
            raise HTTPException(status_code=400, detail=f"Invalid maintenance_status: {maintenance_status}")

    return service_list_rooms(
        db,
        skip=skip,
        limit=limit,
        room_type=rt,
        maintenance_status=ms,
        min_price=min_price,
        max_price=max_price,
        min_capacity=min_capacity,
        only_available=only_available,
        amenities_like=amenities_like,
    )


@router.get("/{room_id}", response_model=RoomOut)
def read_room(
    room_id: int = Path(..., description="The ID of the room (must be an integer)"),
    db: Session = Depends(get_db),
):
    room = service_get_room(db, room_id)
    if not room:
        raise HTTPException(status_code=404, detail="Room not found")
    if hasattr(room, 'hostel_id'):
        room.hostel_id = str(room.hostel_id)
    return room


@router.put("/{room_id}", response_model=RoomOut)
def update_room(room_id: int, payload: RoomUpdate, db: Session = Depends(get_db)):
    updated = service_update_room(db, room_id, payload)
    if not updated:
        raise HTTPException(status_code=404, detail="Room not found")
    if hasattr(updated, 'hostel_id'):
        updated.hostel_id = str(updated.hostel_id)
    return updated


@router.delete("/{room_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_room(room_id: int, db: Session = Depends(get_db)):
    ok = service_delete_room(db, room_id)
    if not ok:
        raise HTTPException(status_code=404, detail="Room not found")
    return None


@router.post("/{room_id}/maintenance", response_model=RoomOut)
def set_maintenance(room_id: int, maintenance_status: str, db: Session = Depends(get_db)):
    try:
        ms = MaintenanceStatus(maintenance_status)
    except Exception:
        raise HTTPException(status_code=400, detail=f"Invalid maintenance_status: {maintenance_status}")
    updated = service_set_room_maintenance(db, room_id, ms)
    if not updated:
        raise HTTPException(status_code=404, detail="Room not found")
    if hasattr(updated, 'hostel_id'):
        updated.hostel_id = str(updated.hostel_id)
    return updated


@router.post("/{room_id}/availability", response_model=RoomOut)
def set_availability(room_id: int, availability: int, db: Session = Depends(get_db)):
    updated = service_set_room_availability(db, room_id, availability)
    if not updated:
        raise HTTPException(status_code=404, detail="Room not found")
    if hasattr(updated, 'hostel_id'):
        updated.hostel_id = str(updated.hostel_id)
    return updated


@router.post("/bulk", status_code=status.HTTP_201_CREATED)
async def bulk_import_rooms(file: UploadFile = File(...), db: Session = Depends(get_db)):
    content = (await file.read()).decode("utf-8")
    reader = csv.DictReader(StringIO(content))
    created = 0
    for row in reader:
        try:
            payload = {k: (v if v != "" else None) for k, v in row.items()}
            service_create_room(db, RoomCreate(**payload))
            created += 1
        except Exception:
            continue
    return {"created": created}


@router.get("/export")
def export_rooms(
    room_type: Optional[str] = None,
    maintenance_status: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    min_capacity: Optional[int] = None,
    only_available: Optional[bool] = None,
    amenities_like: Optional[str] = None,
    db: Session = Depends(get_db),
):
    rt = None
    ms = None
    if room_type:
        try:
            rt = RoomType(room_type)
        except Exception:
            raise HTTPException(status_code=400, detail=f"Invalid room_type: {room_type}")
    if maintenance_status:
        try:
            ms = MaintenanceStatus(maintenance_status)
        except Exception:
            raise HTTPException(status_code=400, detail=f"Invalid maintenance_status: {maintenance_status}")

    rows = service_list_rooms(
        db,
        skip=0,
        limit=100000,
        room_type=rt,
        maintenance_status=ms,
        min_price=min_price,
        max_price=max_price,
        min_capacity=min_capacity,
        only_available=only_available,
        amenities_like=amenities_like,
    )
    buf = StringIO()
    writer = csv.writer(buf)
    headers = [
        "id","hostel_id","room_number","room_type","room_capacity","monthly_price","quarterly_price","annual_price","availability","amenities","maintenance_status","created_at","updated_at"
    ]
    writer.writerow(headers)
    for r in rows:
        writer.writerow([getattr(r, h, None) for h in headers])
    buf.seek(0)
    return StreamingResponse(iter([buf.getvalue()]), media_type="text/csv", headers={"Content-Disposition": "attachment; filename=rooms.csv"})


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\session.py ---
"""
Session switching APIs
"""
from fastapi import APIRouter, Depends, HTTPException, status, Body
from sqlalchemy.orm import Session
from typing import List, Optional

from app.core.database import get_db
from app.core.roles import Role
from app.api.deps import role_required, get_current_active_user
from app.models.user import User
from app.services.session_service import SessionService
from app.schemas.session import SwitchSessionRequest, SessionContextResponse
from app.services.tenant_service import TenantService

router = APIRouter()


@router.post("/session/switch", response_model=SessionContextResponse, status_code=status.HTTP_200_OK)
async def switch_session(
    request: SwitchSessionRequest,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Switch active hostel session"""
    session_service = SessionService(db)
    return session_service.switch_session(current_user.id, current_user.role, request)


@router.post("/session/set-active-hostel", response_model=SessionContextResponse, status_code=status.HTTP_200_OK)
async def set_active_hostel(
    request: SwitchSessionRequest,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Set or activate the user's active hostel (alias for switch)."""
    session_service = SessionService(db)
    return session_service.switch_session(current_user.id, current_user.role, request)


@router.post("/session/switch-hostel", response_model=SessionContextResponse, status_code=status.HTTP_200_OK)
async def switch_hostel_alias(
    request: SwitchSessionRequest,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Alias to switch active hostel."""
    session_service = SessionService(db)
    return session_service.switch_session(current_user.id, current_user.role, request)


@router.get("/session/active", response_model=SessionContextResponse, status_code=status.HTTP_200_OK)
async def get_active_session(
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get active session"""
    session_service = SessionService(db)
    session = session_service.get_active_session(current_user.id)
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No active session found"
        )
    return session


@router.get("/session/active-hostel", response_model=SessionContextResponse, status_code=status.HTTP_200_OK)
async def get_active_hostel(
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Alias to get the active hostel session."""
    session_service = SessionService(db)
    session = session_service.get_active_session(current_user.id)
    if not session:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No active session found")
    return session


@router.get("/session/recent", response_model=List[SessionContextResponse], status_code=status.HTTP_200_OK)
async def get_recent_sessions(
    limit: int = 5,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Get recently accessed hostels"""
    session_service = SessionService(db)
    return session_service.get_recent_sessions(current_user.id, limit)


@router.get("/session/recent-hostels", response_model=List[SessionContextResponse], status_code=status.HTTP_200_OK)
async def get_recent_hostels(
    limit: int = 5,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Alias for recently accessed hostels (keeps same behavior)."""
    session_service = SessionService(db)
    return session_service.get_recent_sessions(current_user.id, limit)


@router.get("/session/assigned-hostels", response_model=List[dict], status_code=status.HTTP_200_OK)
async def get_assigned_hostels(
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Return list of hostels the user has access to (SuperAdmin: all, Admin: assigned, others: own hostel)."""
    tenant_service = TenantService(db)
    return tenant_service.get_user_hostels(current_user.id, current_user.role)


@router.post("/session/clear", status_code=status.HTTP_204_NO_CONTENT)
async def clear_session(
    session_id: Optional[int] = Body(None, embed=True, description="Optional session id to clear; if omitted, clears the active session"),
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Clear/deactivate a session. If session_id omitted, deactivate the active session."""
    session_service = SessionService(db)
    # If no session_id provided, get active session
    if session_id is None:
        active = session_service.get_active_session(current_user.id)
        if not active:
            # nothing to clear
            return None
        session_id = active.id

    ok = session_service.deactivate_session(current_user.id, session_id)
    if not ok:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session not found or not owned by user")

    return None



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\students.py ---
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session
import csv
from io import StringIO
from datetime import datetime

from app.core.database import get_db
from app.schemas.students import (
    StudentCreate,
    StudentOut,
    StudentUpdate,
    PaymentOut,
    PaymentCreate,
    AttendanceOut,
    StudentDocumentOut,
    StudentDocumentCreate,
    AttendanceCreate,
)
from app.services.student_service import (
    list_students as service_list_students,
    get_student as service_get_student,
    create_student as service_create_student,
    update_student as service_update_student,
    delete_student as service_delete_student,
    set_student_status as service_set_student_status,
    transfer_student as service_transfer_student,
    get_student_history as service_get_student_history,
    create_payment as service_create_payment,
    list_payments as service_list_payments,
    create_attendance as service_create_attendance,
    list_attendance as service_list_attendance,
    create_student_document as service_create_student_document,
    list_student_documents as service_list_student_documents,
)

router = APIRouter(prefix="/api/v1/admin/students", tags=["students"])


@router.get("/", response_model=List[StudentOut])
def read_students(
    skip: int = 0,
    limit: int = 100,
    name: Optional[str] = None,
    room: Optional[str] = None,
    payment_status: Optional[str] = None,
    attendance_status: Optional[str] = None,
    db: Session = Depends(get_db),
):
    return service_list_students(
        db,
        skip=skip,
        limit=limit,
        name=name,
        room=room,
        payment_status=payment_status,
        attendance_status=attendance_status,
    )


@router.get("/{student_id}", response_model=StudentOut)
def read_student(student_id: str, db: Session = Depends(get_db)):
    student = service_get_student(db, student_id)
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")
    return student


@router.post("/", response_model=StudentOut, status_code=status.HTTP_201_CREATED)
def create_student(item: StudentCreate, db: Session = Depends(get_db)):
    try:
        return service_create_student(db, item)
    except IntegrityError as e:
        db.rollback()
        error_msg = str(e.orig)
        if "student_email" in error_msg:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Student with email '{item.student_email}' already exists")
        if "student_id" in error_msg:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Student with id '{item.student_id}' already exists")
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="A student with this information already exists")


@router.put("/{student_id}", response_model=StudentOut)
def update_student(student_id: str, payload: StudentUpdate, db: Session = Depends(get_db)):
    try:
        updated = service_update_student(db, student_id, payload)
        if not updated:
            raise HTTPException(status_code=404, detail="Student not found")
        return updated
    except IntegrityError as e:
        db.rollback()
        error_msg = str(e.orig)
        if "student_email" in error_msg:
            email = getattr(payload, 'student_email', None)
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Student with email '{email}' already exists" if email else "A student with this email already exists")
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="A student with this information already exists")


@router.delete("/{student_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_student(student_id: str, db: Session = Depends(get_db)):
    ok = service_delete_student(db, student_id)
    if not ok:
        raise HTTPException(status_code=404, detail="Student not found")
    return None


@router.post("/{student_id}/status", response_model=StudentOut)
def set_status(student_id: str, new_status: str, notes: Optional[str] = None, db: Session = Depends(get_db)):
    updated = service_set_student_status(db, student_id, new_status, notes)
    if not updated:
        raise HTTPException(status_code=404, detail="Student not found")
    return updated


@router.post("/{student_id}/transfer", response_model=StudentOut)
def transfer(student_id: str, new_room: Optional[str] = None, new_bed: Optional[str] = None, notes: Optional[str] = None, db: Session = Depends(get_db)):
    updated = service_transfer_student(db, student_id, new_room, new_bed, notes)
    if not updated:
        raise HTTPException(status_code=404, detail="Student not found")
    return updated


@router.get("/{student_id}/history")
def history(student_id: str, db: Session = Depends(get_db)):
    return service_get_student_history(db, student_id)


# Payments
@router.post("/{student_id}/payments", response_model=PaymentOut, status_code=status.HTTP_201_CREATED)
def create_payment(student_id: str, payload: PaymentCreate, db: Session = Depends(get_db)):
    return service_create_payment(db, student_id, payload)


@router.get("/{student_id}/payments", response_model=List[PaymentOut])
def list_payments(student_id: str, db: Session = Depends(get_db)):
    return service_list_payments(db, student_id)


# Attendance
@router.post("/{student_id}/attendance", response_model=AttendanceOut, status_code=status.HTTP_201_CREATED)
def create_attendance(student_id: str, payload: AttendanceCreate, db: Session = Depends(get_db)):
    return service_create_attendance(db, student_id, payload)


@router.get("/{student_id}/attendance", response_model=List[AttendanceOut])
def list_attendance(student_id: str, db: Session = Depends(get_db)):
    return service_list_attendance(db, student_id)


# Documents
@router.post("/{student_id}/documents", response_model=StudentDocumentOut, status_code=status.HTTP_201_CREATED)
def create_document(student_id: str, payload: StudentDocumentCreate, db: Session = Depends(get_db)):
    return service_create_student_document(db, student_id, payload)


@router.get("/{student_id}/documents", response_model=List[StudentDocumentOut])
def list_documents(student_id: str, db: Session = Depends(get_db)):
    return service_list_student_documents(db, student_id)


@router.post("/bulk", status_code=status.HTTP_201_CREATED)
async def bulk_import_students(file: UploadFile = File(...), db: Session = Depends(get_db)):
    content = (await file.read()).decode("utf-8")
    reader = csv.DictReader(StringIO(content))

    alias_map = {
        "id": "student_id", "student id": "student_id", "student_id": "student_id",
        "name": "student_name", "student name": "student_name", "student_name": "student_name",
        "email": "student_email", "student email": "student_email", "student_email": "student_email",
        "phone": "student_phone", "mobile": "student_phone", "student phone": "student_phone", "student_phone": "student_phone",
        "dob": "date_of_birth", "date of birth": "date_of_birth", "date_of_birth": "date_of_birth",
        "guardian": "guardian_name", "guardian_name": "guardian_name",
        "guardian phone": "guardian_phone", "guardian_phone": "guardian_phone",
        "emergency": "emergency_contact", "emergency_contact": "emergency_contact",
        "checkin": "check_in_date", "check_in": "check_in_date", "check_in_date": "check_in_date",
        "room": "room_assignment", "room_assignment": "room_assignment",
        "bed": "bed_assignment", "bed_assignment": "bed_assignment",
        "status": "status",
    }
    required = {"student_id", "student_name", "student_email", "student_phone"}

    created = 0
    failed = 0
    errors = []

    def norm_key(k: str) -> str:
        return (k or "").strip().lower()

    for idx, row in enumerate(reader, start=2):
        normalized = {}
        for k, v in row.items():
            key = alias_map.get(norm_key(k), None)
            if not key:
                continue
            normalized[key] = (v.strip() if isinstance(v, str) else v) or None

        missing = [k for k in required if not normalized.get(k)]
        if missing:
            failed += 1
            errors.append({"row": idx, "error": f"missing required: {', '.join(missing)}"})
            continue

        for date_key in ("date_of_birth", "check_in_date"):
            if normalized.get(date_key):
                try:
                    normalized[date_key] = datetime.strptime(normalized[date_key], "%Y-%m-%d").date()
                except Exception:
                    errors.append({"row": idx, "error": f"invalid date format for {date_key} (use YYYY-MM-DD)"})
                    failed += 1
                    normalized = None
                    break
        if normalized is None:
            continue

        try:
            service_create_student(db, StudentCreate(**normalized))
            created += 1
        except Exception as e:
            failed += 1
            errors.append({"row": idx, "error": str(e)})
            continue

    return {"created": created, "failed": failed, "errors": errors}


@router.get("/export")
def export_students(name: Optional[str] = None, room: Optional[str] = None, db: Session = Depends(get_db)):
    rows = service_list_students(db, skip=0, limit=100000, name=name, room=room)
    buf = StringIO()
    writer = csv.writer(buf)
    headers = [
        "student_id","student_name","student_email","student_phone","date_of_birth","guardian_name","guardian_phone","emergency_contact","check_in_date","room_assignment","bed_assignment","status"
    ]
    writer.writerow(headers)
    for s in rows:
        writer.writerow([getattr(s, h, None) for h in headers])
    buf.seek(0)
    from fastapi.responses import StreamingResponse
    return StreamingResponse(iter([buf.getvalue()]), media_type="text/csv", headers={"Content-Disposition": "attachment; filename=students.csv"})


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\supervisors.py ---
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.schemas.supervisors import SupervisorCreate, SupervisorOut, SupervisorUpdate, AdminOverrideCreate, AdminOverrideOut
from app.services.supervisor_service import (
    create_supervisor as service_create_supervisor,
    get_supervisor as service_get_supervisor,
    list_supervisors as service_list_supervisors,
    update_supervisor as service_update_supervisor,
    delete_supervisor as service_delete_supervisor,
    assign_supervisor_hostel as service_assign_supervisor_hostel,
    list_supervisor_hostels as service_list_supervisor_hostels,
    list_supervisor_activity as service_list_supervisor_activity,
    create_admin_override as service_create_admin_override,
    override_assign_supervisor_hostel as service_override_assign_supervisor_hostel,
)

router = APIRouter(prefix="/api/v1/admin/supervisors", tags=["supervisors"])


@router.post("/", response_model=SupervisorOut, status_code=status.HTTP_201_CREATED)
def create_supervisor(item: SupervisorCreate, db: Session = Depends(get_db)):
    try:
        return service_create_supervisor(db, item)
    except IntegrityError as e:
        db.rollback()
        error_msg = str(e.orig)
        if "supervisor_email" in error_msg:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Supervisor with email '{item.supervisor_email}' already exists")
        if "employee_id" in error_msg:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Supervisor with employee_id '{item.employee_id}' already exists")
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="A supervisor with this information already exists")


@router.get("/", response_model=List[SupervisorOut])
def read_supervisors(skip: int = 0, limit: int = 100, name: Optional[str] = None, role: Optional[str] = None, department: Optional[str] = None, db: Session = Depends(get_db)):
    return service_list_supervisors(db, skip=skip, limit=limit, name=name, role=role, department=department)


@router.get("/{employee_id}", response_model=SupervisorOut)
def read_supervisor(employee_id: str, db: Session = Depends(get_db)):
    sup = service_get_supervisor(db, employee_id)
    if not sup:
        raise HTTPException(status_code=404, detail="Supervisor not found")
    return sup


@router.put("/{employee_id}", response_model=SupervisorOut)
def update_supervisor(employee_id: str, payload: SupervisorUpdate, db: Session = Depends(get_db)):
    try:
        updated = service_update_supervisor(db, employee_id, payload)
        if not updated:
            raise HTTPException(status_code=404, detail="Supervisor not found")
        return updated
    except IntegrityError as e:
        db.rollback()
        error_msg = str(e.orig)
        if "supervisor_email" in error_msg:
            email = getattr(payload, 'supervisor_email', None)
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Supervisor with email '{email}' already exists" if email else "A supervisor with this email already exists")
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="A supervisor with this information already exists")


@router.delete("/{employee_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_supervisor(employee_id: str, db: Session = Depends(get_db)):
    ok = service_delete_supervisor(db, employee_id)
    if not ok:
        raise HTTPException(status_code=404, detail="Supervisor not found")
    return None


@router.post("/{employee_id}/assign-hostel", status_code=status.HTTP_204_NO_CONTENT)
def assign_hostel(employee_id: str, hostel_id: str, db: Session = Depends(get_db)):
    service_assign_supervisor_hostel(db, employee_id, hostel_id)
    return None


@router.get("/{employee_id}/hostels")
def list_hostels(employee_id: str, db: Session = Depends(get_db)):
    return service_list_supervisor_hostels(db, employee_id)


@router.get("/{employee_id}/activity")
def activity(employee_id: str, db: Session = Depends(get_db)):
    return service_list_supervisor_activity(db, employee_id)


# Admin overrides
@router.post("/overrides", response_model=AdminOverrideOut, status_code=status.HTTP_201_CREATED)
def create_override(payload: AdminOverrideCreate, db: Session = Depends(get_db)):
    try:
        return service_create_admin_override(db, payload.admin_employee_id, payload.target_supervisor_id, payload.action, payload.details)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.post("/{employee_id}/override/assign-hostel", status_code=status.HTTP_204_NO_CONTENT)
def override_assign_hostel(employee_id: str, new_hostel_id: str, admin_employee_id: str, db: Session = Depends(get_db)):
    try:
        service_override_assign_supervisor_hostel(db, admin_employee_id, employee_id, new_hostel_id)
        return None
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\transactions.py ---
# from fastapi import APIRouter, Depends, HTTPException, status
# from fastapi.responses import StreamingResponse
# from sqlalchemy.orm import Session
# from app.database import get_db
# from app.models.payment_models import Payment, Transaction, TransactionType, PaymentStatus
# from app.schemas.payment_schemas import TransactionResponse, PartialPaymentRequest, RefundRequest
# from app.services.payment_services import generate_reference_id
# from app.utils.pdf_generator import generate_pdf_receipt

# router = APIRouter()


# # ✅ Full Payment Processing
# @router.post("/{payment_id}/process", response_model=TransactionResponse)
# def process_full_payment(payment_id: int, db: Session = Depends(get_db)):
#     payment = db.query(Payment).filter(Payment.id == payment_id).first()
#     if not payment:
#         raise HTTPException(status_code=404, detail="Payment not found")

#     if payment.status == PaymentStatus.COMPLETED:
#         raise HTTPException(status_code=400, detail="Payment already completed")

#     remaining = payment.amount - payment.paid_amount
#     transaction = Transaction(
#         payment_id=payment.id,
#         amount=remaining,
#         transaction_type=TransactionType.PAYMENT,
#         reference_id=generate_reference_id(),
#     )

#     payment.paid_amount = payment.amount
#     payment.status = PaymentStatus.COMPLETED

#     db.add(transaction)
#     db.commit()
#     db.refresh(transaction)
#     return transaction


# # ✅ Partial Payment Processing
# @router.post("/{payment_id}/partial", response_model=TransactionResponse)
# def process_partial_payment(payment_id: int, request: PartialPaymentRequest, db: Session = Depends(get_db)):
#     payment = db.query(Payment).filter(Payment.id == payment_id).first()
#     if not payment:
#         raise HTTPException(status_code=404, detail="Payment not found")

#     if payment.status == PaymentStatus.COMPLETED:
#         raise HTTPException(status_code=400, detail="Payment already completed")

#     remaining = payment.amount - payment.paid_amount
#     if request.amount > remaining:
#         raise HTTPException(status_code=400, detail=f"Amount exceeds remaining balance of ${remaining:.2f}")

#     transaction = Transaction(
#         payment_id=payment.id,
#         amount=request.amount,
#         transaction_type=TransactionType.PARTIAL_PAYMENT,
#         reference_id=generate_reference_id(),
#     )

#     payment.paid_amount += request.amount
#     payment.status = PaymentStatus.COMPLETED if payment.paid_amount >= payment.amount else PaymentStatus.PARTIAL

#     db.add(transaction)
#     db.commit()
#     db.refresh(transaction)
#     return transaction


# # ✅ Refund Payment
# @router.post("/{payment_id}/refund", response_model=TransactionResponse)
# def refund_payment(payment_id: int, request: RefundRequest, db: Session = Depends(get_db)):
#     payment = db.query(Payment).filter(Payment.id == payment_id).first()
#     if not payment:
#         raise HTTPException(status_code=404, detail="Payment not found")

#     if payment.paid_amount == 0:
#         raise HTTPException(status_code=400, detail="No amount paid to refund")

#     refund_amount = request.amount if request.amount else payment.paid_amount
#     if refund_amount > payment.paid_amount:
#         raise HTTPException(status_code=400, detail=f"Refund amount exceeds paid amount of ${payment.paid_amount:.2f}")

#     transaction = Transaction(
#         payment_id=payment.id,
#         amount=refund_amount,
#         transaction_type=TransactionType.REFUND,
#         reference_id=generate_reference_id(),
#     )

#     payment.paid_amount -= refund_amount
#     payment.status = PaymentStatus.REFUNDED if payment.paid_amount == 0 else PaymentStatus.PARTIAL

#     db.add(transaction)
#     db.commit()
#     db.refresh(transaction)
#     return transaction


# # ✅ Download Receipt (PDF)
# @router.get("/{payment_id}/receipt/{transaction_id}")
# def download_receipt(payment_id: int, transaction_id: int, db: Session = Depends(get_db)):
#     payment = db.query(Payment).filter(Payment.id == payment_id).first()
#     if not payment:
#         raise HTTPException(status_code=404, detail="Payment not found")

#     transaction = db.query(Transaction).filter(
#         Transaction.id == transaction_id,
#         Transaction.payment_id == payment_id
#     ).first()
#     if not transaction:
#         raise HTTPException(status_code=404, detail="Transaction not found")

#     pdf_buffer = generate_pdf_receipt(payment, transaction)

#     return StreamingResponse(
#         pdf_buffer,
#         media_type="application/pdf",
#         headers={
#             "Content-Disposition": f"attachment; filename=receipt_{transaction.reference_id}.pdf"
#         },
#     )


# # ✅ Get all transactions for a payment
# @router.get("/{payment_id}/transactions", response_model=list[TransactionResponse])
# def get_payment_transactions(payment_id: int, db: Session = Depends(get_db)):
#     payment = db.query(Payment).filter(Payment.id == payment_id).first()
#     if not payment:
#         raise HTTPException(status_code=404, detail="Payment not found")
#     return payment.transactions
# app/api/v1/routers/transactions.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.core.database import SessionLocal,get_db
from app.schemas.payment_schemas import PaymentCreate, TransactionResponse
from app.services.payment_services import PaymentService

router = APIRouter()

# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()

@router.post("/process", response_model=TransactionResponse)
def process_payment(payment: PaymentCreate, db: Session = Depends(get_db)):
    try:
        txn = PaymentService.process_payment(
            db=db,
            invoice_id=payment.invoice_id,
            amount=payment.amount,
            payment_method=payment.payment_method,
            payment_gateway=payment.payment_gateway,
            gateway_transaction_id=payment.gateway_transaction_id,
            notes=payment.notes
        )
        return txn
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{transaction_id}", response_model=TransactionResponse)
def get_transaction(transaction_id: int, db: Session = Depends(get_db)):
    tx = db.query(__import__("app").models.payment_models.Transaction).filter(__import__("app").models.payment_models.Transaction.id == transaction_id).first()
    if not tx:
        raise HTTPException(status_code=404, detail="Transaction not found")
    return tx


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\waitlist.py ---
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime
from typing import List, Optional

# ✔ FIX 1 — correct dependency import
from app.dependencies import get_db

from app.models.waitlist import Waitlist as WaitlistModel
from app.models.rooms import Room
from app.models.booking import Booking, BookingStatus

# ✔ FIX 2 — required for SOW-based locking
from app.services.booking_lock_service import BookingLockService

from app.schemas.waitlist import (
    WaitlistCreate,
    WaitlistResponse,
    PromoteResponse,
)

router = APIRouter(prefix="/waitlist", tags=["Waitlist"])


def is_room_available_for_range(db: Session, room_id: int, check_in: datetime, check_out: datetime) -> bool:
    conflict = (
        db.query(Booking)
        .filter(
            Booking.room_id == room_id,
            Booking.status == BookingStatus.confirmed.value,
            Booking.check_in < check_out,
            Booking.check_out > check_in,
        )
        .first()
    )
    return conflict is None


@router.post("/", response_model=WaitlistResponse, status_code=status.HTTP_201_CREATED)
def add_to_waitlist(payload: WaitlistCreate, db: Session = Depends(get_db)):
    exists = (
        db.query(WaitlistModel)
        .filter(
            WaitlistModel.hostel_id == payload.hostel_id,
            WaitlistModel.room_type == payload.room_type,
            WaitlistModel.visitor_id == payload.visitor_id,
        )
        .first()
    )
    if exists:
        raise HTTPException(status_code=400, detail="Visitor already on waitlist for this room type")

    top = (
        db.query(WaitlistModel)
        .filter(
            WaitlistModel.hostel_id == payload.hostel_id,
            WaitlistModel.room_type == payload.room_type,
        )
        .order_by(WaitlistModel.priority.desc())
        .first()
    )
    next_priority = (top.priority + 1) if top else 1

    wl = WaitlistModel(
        hostel_id=payload.hostel_id,
        room_type=payload.room_type,
        visitor_id=payload.visitor_id,
        priority=next_priority,
        created_at=datetime.utcnow(),
    )

    db.add(wl)
    db.commit()
    db.refresh(wl)
    return wl


@router.get("/", response_model=List[WaitlistResponse])
def list_waitlist(hostel_id: Optional[int] = None, room_type: Optional[str] = None, db: Session = Depends(get_db)):
    q = db.query(WaitlistModel)
    if hostel_id is not None:
        q = q.filter(WaitlistModel.hostel_id == hostel_id)
    if room_type is not None:
        q = q.filter(WaitlistModel.room_type == room_type)

    q = q.order_by(WaitlistModel.priority.asc(), WaitlistModel.created_at.asc())
    return q.all()


@router.delete("/{waitlist_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_from_waitlist(waitlist_id: int, db: Session = Depends(get_db)):
    wl = db.query(WaitlistModel).filter(WaitlistModel.id == waitlist_id).first()
    if not wl:
        raise HTTPException(status_code=404, detail="Waitlist entry not found")

    db.delete(wl)
    db.commit()
    return None


@router.post("/{waitlist_id}/promote", response_model=PromoteResponse)
def promote_waitlist_entry(waitlist_id: int, target_room_id: Optional[int] = None, db: Session = Depends(get_db)):
    wl = db.query(WaitlistModel).filter(WaitlistModel.id == waitlist_id).first()
    if not wl:
        raise HTTPException(status_code=404, detail="Waitlist entry not found")

    if target_room_id:
        candidate_rooms = db.query(Room).filter(Room.id == target_room_id, Room.hostel_id == wl.hostel_id).all()
        if not candidate_rooms:
            raise HTTPException(status_code=404, detail="Target room not found in the same hostel")
    else:
        candidate_rooms = (
            db.query(Room)
            .filter(Room.hostel_id == wl.hostel_id, Room.room_type == wl.room_type)
            .order_by(Room.available_beds.desc())
            .all()
        )

    promoted = False
    created_booking = None
    reason = None

    for room in candidate_rooms:

        # ✔ FIX 3 — use your project's official lock service
        locked_room = BookingLockService.lock_room(db, room.id)

        if not locked_room:
            continue

        if locked_room.available_beds <= 0:
            reason = "No available beds"
            continue

        check_in = datetime.utcnow()
        check_out = datetime(check_in.year + 1, check_in.month, check_in.day)

        conflict = (
            db.query(Booking)
            .filter(
                Booking.room_id == locked_room.id,
                Booking.status == BookingStatus.confirmed.value,
                Booking.check_in < check_out,
                Booking.check_out > check_in,
            )
            .first()
        )
        if conflict:
            reason = "Conflicting booking exists"
            continue

        try:
            new_booking = Booking(
                visitor_id=wl.visitor_id,
                hostel_id=wl.hostel_id,
                room_id=locked_room.id,
                check_in=check_in,
                check_out=check_out,
                amount_paid=0.0,
                status=BookingStatus.confirmed.value,
                created_at=datetime.utcnow(),
            )

            db.add(new_booking)
            locked_room.available_beds -= 1
            db.delete(wl)

            db.commit()
            db.refresh(new_booking)

            promoted = True
            created_booking = new_booking
            reason = "Promoted"
            break

        except Exception as e:
            db.rollback()
            reason = str(e)
            continue

    if not promoted:
        raise HTTPException(status_code=400, detail=f"Could not promote entry: {reason or 'No room available'}")

    return PromoteResponse(
        promoted=True,
        booking_id=created_booking.id,
        room_id=created_booking.room_id,
        hostel_id=created_booking.hostel_id,
        message="Waitlist entry promoted to confirmed booking"
    )


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\admin\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\login.py ---
"""
JWT issue
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.services.auth_service import AuthService
from app.schemas.auth import UserLogin, Token

router = APIRouter()


@router.post("/login", response_model=Token, status_code=status.HTTP_200_OK)
async def login_user(
    credentials: UserLogin,
    db: Session = Depends(get_db)
):
    """Login and receive JWT tokens"""
    auth_service = AuthService(db)
    return auth_service.login(credentials)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\login_enhanced.py ---
"""
Enhanced login with email/phone and remember me
"""
from fastapi import APIRouter, Depends, HTTPException, status, Response
from sqlalchemy.orm import Session
from datetime import timedelta

from app.core.database import get_db
from app.services.auth_service import AuthService
from app.schemas.auth_enhanced import UserLoginEnhanced
from app.core.security import verify_password, create_access_token, create_refresh_token
from app.config import settings

router = APIRouter()


@router.post("/login", response_model=dict, status_code=status.HTTP_200_OK)
async def login_user_enhanced(
    credentials: UserLoginEnhanced,
    response: Response,
    db: Session = Depends(get_db)
):
    """Login with email/phone and optional remember me"""
    auth_service = AuthService(db)
    
    # Find user by email or phone
    user = None
    
    if '@' in credentials.email_or_phone:
        # Try email
        user = auth_service.user_repo.get_by_email(credentials.email_or_phone)
    else:
        # Try phone number
        users = auth_service.user_repo.get_all()
        for u in users:
            if u.phone_number and credentials.email_or_phone in u.phone_number:
                user = u
                break
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email/phone or password"
        )
    
    # Check if user has password (not social login only)
    if not user.hashed_password:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="This account uses social login. Social login has been disabled by the administrator."
        )
    
    # Verify password
    if not verify_password(credentials.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email/phone or password"
        )
    
    # Check if account is active
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Account is not activated. Please verify your email/phone."
        )
    
    # Set remember me
    user.remember_me = credentials.remember_me
    db.commit()
    
    # Generate tokens with extended expiry for remember me
    expires_delta = None
    if credentials.remember_me:
        expires_delta = timedelta(days=30)  # 30 days for remember me
    
    access_token = create_access_token(
        data={"sub": str(user.id), "role": user.role, "hostel_id": user.hostel_id, "email": user.email},
        expires_delta=expires_delta
    )
    
    # Refresh token always has longer expiry
    refresh_token_expiry = timedelta(days=30) if credentials.remember_me else timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    refresh_token = create_refresh_token(
        data={"sub": str(user.id), "role": user.role}
    )
    
    # Store refresh token
    auth_service.token_repo.create_token(user.id, refresh_token)
    
    # If user asked to be remembered, set an HttpOnly cookie so other tabs can detect login
    # Cookie is set only for 'remember_me' to avoid implicit session cookies.
    response_payload = {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "expires_in": 30 * 24 * 60 * 60 if credentials.remember_me else settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        "user": {
            "id": user.id,
            "email": user.email,
            "username": user.username,
            "full_name": user.full_name,
            "role": user.role
        }
    }

    # Set cookie when remember_me is True so browser tabs can share authentication via HttpOnly cookie
    if credentials.remember_me:
        # Response object may be provided by FastAPI; if not, we won't set cookie
        try:
            response.set_cookie(
                key="access_token",
                value=access_token,
                httponly=True,
                secure=not settings.DEBUG,
                samesite="lax",
                max_age=30 * 24 * 60 * 60
            )
        except Exception:
            # If response object is not available, just continue without cookie
            pass

    return response_payload



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\me.py ---
"""
Get current user information endpoint
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.services.tenant_service import TenantService
from app.core.permissions import get_role_permissions, PERMISSION_MATRIX

router = APIRouter()


@router.get("/me", response_model=dict, status_code=status.HTTP_200_OK, tags=["auth"])
async def get_current_user_info(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get current logged-in user information
    
    Returns the user's profile information based on the JWT token.
    Useful for checking who is logged in, especially when multiple tabs are open.
    
    Requires: Authorization header with Bearer token
    """
    # Get user's accessible hostels if admin
    accessible_hostels = []
    if current_user.role in ["admin", "superadmin"]:
        tenant_service = TenantService(db)
        accessible_hostels = tenant_service.get_user_hostels(current_user.id, current_user.role)
    
    # Get hostel name if hostel_id exists
    hostel_name = None
    if current_user.hostel_id:
        from app.repositories.hostel_repository import HostelRepository
        hostel_repo = HostelRepository(db)
        hostel = hostel_repo.get_by_id(current_user.hostel_id)
        if hostel:
            hostel_name = hostel.name
    
    # compute permissions info for the current role
    role_permissions = set(get_role_permissions(current_user.role))
    # gather all known permissions to present a stable map
    all_permissions = set()
    for perms in PERMISSION_MATRIX.values():
        all_permissions.update(perms)

    permissions_map = {p: (p in role_permissions) for p in sorted(all_permissions)}

    return {
        "id": current_user.id,
        "email": current_user.email,
        "phone_number": current_user.phone_number,
        "country_code": current_user.country_code,
        "username": current_user.username,
        "full_name": current_user.full_name,
        "role": current_user.role,
        "permissions": sorted(role_permissions),
        "permissions_map": permissions_map,
        "hostel_id": current_user.hostel_id,
        "hostel_name": hostel_name,
        "is_active": current_user.is_active,
        "is_email_verified": getattr(current_user, "is_email_verified", False),
        "is_phone_verified": getattr(current_user, "is_phone_verified", False),
        "created_at": current_user.created_at.isoformat() if current_user.created_at else None,
        "updated_at": current_user.updated_at.isoformat() if current_user.updated_at else None,
        "accessible_hostels": accessible_hostels if accessible_hostels else None,
        "remember_me": getattr(current_user, "remember_me", False)
    }




# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\password.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\password_reset.py ---
"""
Password reset endpoints
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.services.password_reset_service import PasswordResetService
from app.schemas.auth_enhanced import (
    PasswordResetRequest,
    PasswordResetVerify,
    PasswordResetComplete
)

router = APIRouter()


@router.post("/forgot-password", response_model=dict, status_code=status.HTTP_200_OK)
async def forgot_password(
    request: PasswordResetRequest,
    debug: bool = False,
    db: Session = Depends(get_db)
):
    """Request password reset"""
    reset_service = PasswordResetService(db)
    return reset_service.create_reset_request(request.email_or_phone, include_debug=debug)


@router.post("/verify-reset-code", response_model=dict, status_code=status.HTTP_200_OK)
async def verify_reset_code(
    request: PasswordResetVerify,
    db: Session = Depends(get_db)
):
    """Verify password reset code or token"""
    reset_service = PasswordResetService(db)
    return reset_service.verify_reset_code(
        request.email_or_phone,
        request.reset_code,
        request.reset_token
    )


@router.post("/reset-password", response_model=dict, status_code=status.HTTP_200_OK)
async def reset_password(
    request: PasswordResetComplete,
    db: Session = Depends(get_db)
):
    """Complete password reset"""
    reset_service = PasswordResetService(db)
    return reset_service.reset_password(
        reset_token=request.reset_token,
        reset_code=request.reset_code,
        email_or_phone=request.email_or_phone,
        new_password=request.new_password
    )



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\password_strength.py ---
"""
Password strength checker endpoint
"""
from fastapi import APIRouter, Query
from app.utils.password_strength import check_password_strength

router = APIRouter()


@router.get("/password-strength", response_model=dict)
async def check_password(
    password: str = Query(..., description="Password to check")
):
    """Check password strength"""
    return check_password_strength(password)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\refresh.py ---
"""
Refresh tokens
"""
from fastapi import APIRouter, Depends, HTTPException, status, Response
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.services.auth_service import AuthService
from app.schemas.auth import RefreshTokenRequest, RefreshTokenResponse

router = APIRouter()


@router.post("/refresh", response_model=RefreshTokenResponse, status_code=status.HTTP_200_OK)
async def refresh_token(
    token_data: RefreshTokenRequest,
    db: Session = Depends(get_db)
):
    """Refresh access token using refresh token"""
    auth_service = AuthService(db)
    return auth_service.refresh_access_token(token_data.refresh_token)



@router.post("/logout", status_code=status.HTTP_200_OK)
async def logout(
    token_data: RefreshTokenRequest,
    response: Response,
    db: Session = Depends(get_db)
):
    """Logout by revoking the provided refresh token and clearing auth cookie if present."""
    auth_service = AuthService(db)
    revoked = auth_service.logout(token_data.refresh_token)
    if not revoked:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Refresh token not found or already revoked")

    # Clear remember-me cookie if set
    try:
        response.delete_cookie("access_token")
    except Exception:
        pass

    return {"message": "Logged out successfully"}



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\register.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\roles.py ---
"""
Superadmin role assignment
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.core.roles import Role
from app.api.deps import role_required, get_current_active_user
from app.models.user import User
from app.services.rbac_service import RBACService
from app.schemas.rbac import RoleAssign

router = APIRouter()


@router.post("/assign-role", response_model=dict, status_code=status.HTTP_200_OK)
async def assign_role(
    assign_data: RoleAssign,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Assign role to user (Superadmin only)"""
    rbac_service = RBACService(db)
    return rbac_service.assign_role(assign_data, current_user.role)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\auth\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\announcement.py ---
# app/api/v1/student/announcement.py

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List

from app.schemas.announcement import AnnouncementRead
from app.core.database import get_db
from app.services.announcement_service import AnnouncementService

router = APIRouter(
    prefix="/student/announcements",
    tags=["Student Announcements"]      # 🔥 Updated Swagger Tag
)

# TEMP placeholder — replace with real user auth logic later
def get_current_student():
    return {"id": 501, "role": "student", "hostel_ids": [1]}


@router.get("/", response_model=List[AnnouncementRead])
def list_announcements(
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_student)
):
    svc = AnnouncementService(session)
    return svc.list_for_student(current_user["hostel_ids"])


@router.get("/{announcement_id}", response_model=AnnouncementRead)
def get_announcement(
    announcement_id: int,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_student)
):
    svc = AnnouncementService(session)
    return svc.get_announcement(announcement_id)


@router.post("/{announcement_id}/acknowledge")
def acknowledge(
    announcement_id: int,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_student)
):
    svc = AnnouncementService(session)
    svc.acknowledge(announcement_id, current_user["id"])
    return {"detail": "Acknowledged"}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\attendance.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\complaints.py ---
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, status, Header
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from pathlib import Path
import aiofiles
import uuid

from app.core.database import get_db
from app.models.complaint import ComplaintStatus
from app.repositories.complaint_repository import ComplaintRepository
from app.services.complaint_service import ComplaintService
from app.schemas.complaint import (
    ComplaintCreate,
    ComplaintResponse,
    ComplaintDetailResponse,
    ComplaintListResponse,
    ComplaintFilter,
    ComplaintFeedback,
    ComplaintReopen,
    ComplaintNoteCreate
)
from app.config import settings

router = APIRouter(prefix="/student/complaints", tags=["Student Complaints"])


@router.post("/", response_model=ComplaintResponse, status_code=status.HTTP_201_CREATED)
async def create_complaint(
    complaint_data: ComplaintCreate,
    db: AsyncSession = Depends(get_db)
):
    """Submit a new complaint"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.create_complaint(complaint_data)
    return complaint


@router.get("/", response_model=ComplaintListResponse)
async def list_student_complaints(
    student_email: str = Header(..., alias="X-User-Email"),
    hostel_name: Optional[str] = None,
    category: Optional[str] = None,
    status_filter: Optional[str] = None,
    page: int = 1,
    page_size: int = 10,
    db: AsyncSession = Depends(get_db)
):
    """List complaints by student email"""
    filters = ComplaintFilter(
        student_email=student_email,
        hostel_name=hostel_name,
        category=category,
        status=status_filter,
        page=page,
        page_size=page_size
    )
    
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaints, total = await service.list_complaints(filters)
    
    total_pages = (total + page_size - 1) // page_size
    
    return {
        "total": total,
        "page": page,
        "page_size": page_size,
        "total_pages": total_pages,
        "complaints": complaints
    }


@router.get("/{complaint_id}", response_model=ComplaintDetailResponse)
async def get_complaint(
    complaint_id: int,
    student_email: str = Header(..., alias="X-User-Email"),
    db: AsyncSession = Depends(get_db)
):
    """Get complaint details with attachments and notes"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    result = await service.get_complaint_with_details(complaint_id)
    
    if not result:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    complaint = result["complaint"]
    
    # Verify student owns the complaint
    if complaint.student_email != student_email:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only view your own complaints"
        )
    
    return {
        **complaint.__dict__,
        "attachments": result["attachments"],
        "notes": result["notes"]
    }


@router.post("/{complaint_id}/attachments", status_code=status.HTTP_201_CREATED)
async def upload_attachment(
    complaint_id: int,
    file: UploadFile = File(...),
    student_email: str = Header(..., alias="X-User-Email"),
    db: AsyncSession = Depends(get_db)
):
    """Upload attachment for a complaint"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.get_complaint(complaint_id)
    
    if not complaint:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    if complaint.student_email != student_email:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only upload attachments to your own complaints"
        )
    
    # Validate file size
    file.file.seek(0, 2)
    file_size = file.file.tell()
    file.file.seek(0)
    
    if file_size > settings.MAX_UPLOAD_SIZE:
        raise HTTPException(
            status_code=400,
            detail=f"File size exceeds maximum allowed size of {settings.MAX_UPLOAD_SIZE} bytes"
        )
    
    # Create upload directory
    upload_dir = Path(settings.UPLOAD_DIR) / str(complaint_id)
    upload_dir.mkdir(parents=True, exist_ok=True)
    
    # Generate unique filename
    file_extension = Path(file.filename).suffix
    unique_filename = f"{uuid.uuid4()}{file_extension}"
    file_path = upload_dir / unique_filename
    
    # Save file
    async with aiofiles.open(file_path, 'wb') as out_file:
        content = await file.read()
        await out_file.write(content)
    
    # Save attachment record
    attachment = await service.add_attachment(
        complaint_id=complaint_id,
        uploaded_by=student_email,
        file_path=str(file_path),
        file_name=file.filename,
        file_type=file.content_type or 'application/octet-stream',
        file_size=file_size
    )
    
    return {
        "message": "File uploaded successfully",
        "attachment_id": attachment.id,
        "file_name": file.filename
    }


@router.post("/{complaint_id}/feedback", response_model=ComplaintResponse)
async def submit_feedback(
    complaint_id: int,
    feedback_data: ComplaintFeedback,
    student_email: str = Header(..., alias="X-User-Email"),
    db: AsyncSession = Depends(get_db)
):
    """Submit feedback for a resolved complaint"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.get_complaint(complaint_id)
    
    if not complaint:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    if complaint.student_email != student_email:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only submit feedback for your own complaints"
        )
    
    if complaint.status not in [ComplaintStatus.RESOLVED, ComplaintStatus.CLOSED]:
        raise HTTPException(
            status_code=400,
            detail="Feedback can only be submitted for resolved complaints"
        )
    
    complaint = await service.submit_feedback(complaint_id, feedback_data)
    return complaint


@router.post("/{complaint_id}/reopen", response_model=ComplaintResponse)
async def reopen_complaint(
    complaint_id: int,
    reopen_data: ComplaintReopen,
    student_email: str = Header(..., alias="X-User-Email"),
    db: AsyncSession = Depends(get_db)
):
    """Reopen a closed complaint"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.get_complaint(complaint_id)
    
    if not complaint:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    if complaint.student_email != student_email:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only reopen your own complaints"
        )
    
    try:
        complaint = await service.reopen_complaint(complaint_id, reopen_data)
        return complaint
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.post("/{complaint_id}/notes", status_code=status.HTTP_201_CREATED)
async def add_note(
    complaint_id: int,
    note: str,
    student_name: str = Header(..., alias="X-User-Name"),
    student_email: str = Header(..., alias="X-User-Email"),
    db: AsyncSession = Depends(get_db)
):
    """Add a note to the complaint"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.get_complaint(complaint_id)
    
    if not complaint:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    if complaint.student_email != student_email:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only add notes to your own complaints"
        )
    
    note_data = ComplaintNoteCreate(
        note=note,
        user_name=student_name,
        user_email=student_email,
        is_internal=False
    )
    
    created_note = await service.add_note(complaint_id, note_data)
    
    return {
        "message": "Note added successfully",
        "note_id": created_note.id
    }

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\leave.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\mess_menu.py ---
from fastapi import APIRouter, Depends, Query, status
from typing import List, Optional
from datetime import date
from app.schemas.mess_menu import (
    MessMenuResponse,
    MenuFeedbackCreate, MenuFeedbackResponse,
    MealPreferenceCreate, MealPreferenceUpdate, MealPreferenceResponse
)
from app.services.mess_menu_service import MessMenuService
from app.dependencies import get_mess_menu_service

router = APIRouter(prefix="/student/mess-menu", tags=["Student - Mess Menu"])


@router.get("/hostel/{hostel_id}", response_model=List[MessMenuResponse])
def view_hostel_menus(
    hostel_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    View mess menus for daily meal planning (Student)
    - See published menus only
    - Filter by date range
    """
    return service.get_menus_by_hostel(
        hostel_id, skip, limit, menu_type=None, start_date=start_date, end_date=end_date
    )


@router.get("/{menu_id}", response_model=MessMenuResponse)
def view_menu_details(
    menu_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    View specific menu details (Student)
    - Menu items, timing, nutritional info
    """
    return service.get_menu(menu_id)


@router.post("/feedback", response_model=MenuFeedbackResponse, status_code=status.HTTP_201_CREATED)
def submit_feedback(
    feedback: MenuFeedbackCreate,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Submit feedback on meal quality (Student)
    - Rate taste, quantity, hygiene
    - Provide comments and suggestions
    """
    return service.create_feedback(feedback)


@router.post("/preferences", response_model=MealPreferenceResponse, status_code=status.HTTP_201_CREATED)
def create_meal_preference(
    preference: MealPreferenceCreate,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Create meal preference profile (Student)
    - Set dietary type (vegetarian, vegan, etc.)
    - Register allergies and medical requirements
    - Specify preferred and disliked items
    """
    return service.create_preference(preference)


@router.get("/preferences/{student_id}/hostel/{hostel_id}", response_model=MealPreferenceResponse)
def get_my_preference(
    student_id: int,
    hostel_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get student's meal preference (Student)
    """
    return service.get_student_preference(student_id, hostel_id)


@router.put("/preferences/{preference_id}", response_model=MealPreferenceResponse)
def update_meal_preference(
    preference_id: int,
    preference_update: MealPreferenceUpdate,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Update meal preference (Student)
    - Modify dietary requirements
    - Update allergies or preferences
    """
    return service.update_preference(preference_id, preference_update)


@router.get("/hostel/{hostel_id}/today", response_model=List[MessMenuResponse])
def get_today_menu(
    hostel_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get today's published menus (Student)
    - Quick access to today's meals
    """
    today = date.today()
    return service.get_menus_by_hostel(
        hostel_id, 
        skip=0, 
        limit=10, 
        start_date=today, 
        end_date=today
    )

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\notification.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.schemas.notification import NotificationCreate, NotificationOut
from app.services.notification_service import NotificationService
from app.core.database import get_db

router = APIRouter(prefix="/student/notifications", tags=["student-notifications"])


@router.post("/notify", response_model=NotificationOut)
def notify_student(payload: NotificationCreate, db: Session = Depends(get_db)):
	svc = NotificationService(db)
	try:
		notif = svc.send_notification(
			recipient_id=payload.recipient_id,
			recipient_type=payload.recipient_type,
			channel=payload.channel,
			subject=payload.subject or "",
			body=payload.body or "",
		)
		return notif
	except Exception as exc:
		raise HTTPException(status_code=500, detail=str(exc))


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\payments.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\profile.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\student\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\announcement.py ---
# app/api/v1/supervisor/announcement.py

from fastapi import APIRouter, Depends, UploadFile, File
from sqlalchemy.orm import Session
from typing import List

from app.schemas.announcement import (
    AnnouncementCreate,
    AnnouncementRead,
    AnnouncementUpdate
)
from app.core.database import get_db
from app.services.announcement_service import AnnouncementService

router = APIRouter(
    prefix="/supervisor/announcements",
    tags=["Supervisor Announcements"]      # 🔥 Role-specific Swagger tag
)

# TEMP placeholder — replace with your real supervisor auth dependency
def get_current_user():
    return {"id": 101, "role": "supervisor"}


@router.post("/", response_model=AnnouncementRead)
def create_announcement(
    payload: AnnouncementCreate,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    svc = AnnouncementService(session)
    return svc.create_announcement(current_user, payload.dict())


@router.put("/{announcement_id}", response_model=AnnouncementRead)
def update_announcement(
    announcement_id: int,
    payload: AnnouncementUpdate,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    svc = AnnouncementService(session)
    return svc.update_announcement(
        current_user,
        announcement_id,
        payload.dict(exclude_unset=True)
    )


@router.post("/{announcement_id}/attach", response_model=AnnouncementRead)
def attach_file(
    announcement_id: int,
    file: UploadFile = File(...),
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    svc = AnnouncementService(session)
    return svc.add_attachment(announcement_id, file, current_user)


@router.delete("/{announcement_id}")
def delete_announcement(
    announcement_id: int,
    session: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    svc = AnnouncementService(session)
    svc.delete_announcement(current_user, announcement_id)
    return {"detail": "Deleted"}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\approvals.py ---
"""
Supervisor approval request endpoints
"""
from typing import List
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.core.roles import Role
from app.api.deps import role_required, get_current_active_user
from app.models.user import User
from app.services.permission_service import PermissionService
from app.schemas.approval import ApprovalRequestCreate

router = APIRouter()


@router.post("/approvals/request", response_model=dict, status_code=status.HTTP_201_CREATED)
async def create_approval_request(
    approval_data: ApprovalRequestCreate,
    current_user: User = Depends(role_required(Role.SUPERVISOR)),
    db: Session = Depends(get_db)
):
    """Create an approval request for an action requiring approval"""
    permission_service = PermissionService(db)
    
    # Check if action requires approval
    if not permission_service.requires_approval(approval_data.action, current_user.role):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="This action does not require approval for your role"
        )
    
    return permission_service.create_approval_request(
        requester_id=current_user.id,
        action=approval_data.action,
        resource_type=approval_data.resource_type,
        resource_id=approval_data.resource_id,
        hostel_id=approval_data.hostel_id or current_user.hostel_id,
        request_details=approval_data.request_details
    )


@router.get("/approvals/my-requests", response_model=List[dict], status_code=status.HTTP_200_OK)
async def get_my_approval_requests(
    current_user: User = Depends(role_required(Role.SUPERVISOR)),
    db: Session = Depends(get_db)
):
    """Get approval requests made by current supervisor"""
    from app.repositories.approval_repository import ApprovalRepository
    approval_repo = ApprovalRepository(db)
    approvals = approval_repo.get_pending_by_requester(current_user.id)
    
    return [
        {
            "id": a.id,
            "action": a.action,
            "resource_type": a.resource_type,
            "resource_id": a.resource_id,
            "status": a.status,
            "created_at": a.created_at,
            "approved_at": a.approved_at
        }
        for a in approvals
    ]


@router.get("/approvals/{approval_id}/status", response_model=dict, status_code=status.HTTP_200_OK)
async def check_approval_status(
    approval_id: int,
    current_user: User = Depends(role_required(Role.SUPERVISOR)),
    db: Session = Depends(get_db)
):
    """Check status of an approval request"""
    permission_service = PermissionService(db)
    return permission_service.check_approval_status(approval_id)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\attendance.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\audit.py ---
"""
Supervisor activity logs
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime

from app.core.database import get_db
from app.core.roles import Role
from app.core.permissions import Permission
from app.api.deps import role_required, permission_required, get_current_active_user, get_user_hostel_ids
from app.core.exceptions import AccessDeniedException
from app.models.user import User
from app.services.audit_service import AuditService
from app.schemas.audit import AuditLogResponse, AuditLogFilter
from app.schemas.audit import AuditLogBase
from fastapi import Body

router = APIRouter()


@router.get("/audit", response_model=List[AuditLogResponse], status_code=status.HTTP_200_OK)
async def get_supervisor_audit_logs(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    hostel_id: Optional[int] = None,
    action: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    current_user: User = Depends(role_required(Role.SUPERVISOR)),
    _perm: User = Depends(permission_required(Permission.VIEW_AUDIT)),
    db: Session = Depends(get_db)
):
    """Get audit logs for supervisor"""
    audit_service = AuditService(db)
    # Ensure supervisor only queries their assigned hostel(s)
    user_hostel_ids = get_user_hostel_ids(current_user.id, current_user.role, db)
    if hostel_id and hostel_id not in user_hostel_ids:
        raise AccessDeniedException("Supervisors can only view logs for their assigned hostel(s)")

    filters = AuditLogFilter(
        user_id=current_user.id,
        hostel_id=hostel_id,
        action=action,
        start_date=start_date,
        end_date=end_date
    )
    
    return audit_service.get_audit_logs(
        viewer_role=current_user.role,
        viewer_user_id=current_user.id,
        skip=skip,
        limit=limit,
        filters=filters
    )


@router.get("/audit/users/{user_id}", response_model=List[AuditLogResponse], status_code=status.HTTP_200_OK)
async def get_supervisor_user_audit_logs(
    user_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    current_user: User = Depends(role_required(Role.SUPERVISOR)),
    _perm: User = Depends(permission_required(Permission.VIEW_AUDIT)),
    db: Session = Depends(get_db)
):
    """Get audit logs for a specific user (supervisor view)"""
    # Ensure supervisor can only view users in their hostel(s)
    user_hostel_ids = get_user_hostel_ids(current_user.id, current_user.role, db)
    # Load the target user to check their hostel
    from app.repositories.user_repository import UserRepository
    target_user = UserRepository(db).get_by_id(user_id)
    if not target_user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
    if target_user.hostel_id and target_user.hostel_id not in user_hostel_ids:
        raise AccessDeniedException("Supervisor cannot view logs for users outside their assigned hostel")

    audit_service = AuditService(db)
    return audit_service.get_user_audit_logs(user_id, skip=skip, limit=limit)


@router.get("/audit/target/{target_id}", response_model=List[AuditLogResponse], status_code=status.HTTP_200_OK)
async def get_supervisor_audit_by_target(
    target_id: str,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    current_user: User = Depends(role_required(Role.SUPERVISOR)),
    db: Session = Depends(get_db)
):
    """Search audit logs by target identifier (supervisor view)"""
    audit_service = AuditService(db)
    return audit_service.get_target_audit_logs(target_id, skip=skip, limit=limit)


@router.post("/audit/logs", response_model=AuditLogResponse, status_code=status.HTTP_201_CREATED)
async def supervisor_create_audit_log(
    payload: AuditLogBase = Body(...),
    current_user: User = Depends(role_required(Role.SUPERVISOR)),
    _perm: User = Depends(permission_required(Permission.CREATE_AUDIT)),
    db: Session = Depends(get_db)
):
    """Create an audit log entry (supervisors can post entries)."""
    # Ensure supervisor may only create logs for their assigned hostel
    user_hostel_ids = get_user_hostel_ids(current_user.id, current_user.role, db)
    target_hostel = payload.hostel_id or current_user.hostel_id
    if target_hostel and target_hostel not in user_hostel_ids:
        raise AccessDeniedException("Supervisor cannot create logs for hostels outside their assignment")

    audit_service = AuditService(db)
    return audit_service.create_audit_log(
        user_id=current_user.id,
        action=payload.action,
        resource=payload.resource,
        hostel_id=target_hostel,
        ip_address=payload.ip_address,
        user_agent=payload.user_agent,
        details=payload.details
    )



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\complaints.py ---
from fastapi import APIRouter, Depends, HTTPException, status, Query, Header
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from datetime import datetime

from app.core.database import get_db
from app.models.complaint import ComplaintStatus
from app.repositories.complaint_repository import ComplaintRepository
from app.services.complaint_service import ComplaintService
from app.schemas.complaint import (
    ComplaintResponse,
    ComplaintDetailResponse,
    ComplaintListResponse,
    ComplaintFilter,
    ComplaintAssignment,
    ComplaintResolution,
    ComplaintUpdate,
    ComplaintNoteCreate,
    SupervisorPerformance
)

router = APIRouter(prefix="/supervisor/complaints", tags=["Supervisor Complaints"])


@router.get("/", response_model=ComplaintListResponse)
async def list_complaints(
    hostel_name: Optional[str] = None,
    category: Optional[str] = None,
    status_filter: Optional[str] = None,
    priority: Optional[str] = None,
    assigned_to_me: bool = False,
    supervisor_email: str = Header(None, alias="X-User-Email"),
    page: int = 1,
    page_size: int = 10,
    db: AsyncSession = Depends(get_db)
):
    """List complaints for supervisor"""
    filters = ComplaintFilter(
        hostel_name=hostel_name,
        category=category,
        status=status_filter,
        priority=priority,
        assigned_to_email=supervisor_email if assigned_to_me else None,
        page=page,
        page_size=page_size
    )
    
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaints, total = await service.list_complaints(filters)
    
    total_pages = (total + page_size - 1) // page_size
    
    return {
        "total": total,
        "page": page,
        "page_size": page_size,
        "total_pages": total_pages,
        "complaints": complaints
    }


@router.get("/{complaint_id}", response_model=ComplaintDetailResponse)
async def get_complaint(
    complaint_id: int,
    db: AsyncSession = Depends(get_db)
):
    """Get complaint details"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    result = await service.get_complaint_with_details(complaint_id)
    
    if not result:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    complaint = result["complaint"]
    
    return {
        **complaint.__dict__,
        "attachments": result["attachments"],
        "notes": result["notes"]
    }


@router.patch("/{complaint_id}", response_model=ComplaintResponse)
async def update_complaint(
    complaint_id: int,
    update_data: ComplaintUpdate,
    db: AsyncSession = Depends(get_db)
):
    """Update complaint details"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.update_complaint(complaint_id, update_data)
    
    if not complaint:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    return complaint


@router.post("/{complaint_id}/assign", response_model=ComplaintResponse)
async def assign_complaint(
    complaint_id: int,
    assignment_data: ComplaintAssignment,
    db: AsyncSession = Depends(get_db)
):
    """Assign complaint to supervisor/staff"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.assign_complaint(complaint_id, assignment_data)
    
    if not complaint:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    return complaint


@router.post("/{complaint_id}/resolve", response_model=ComplaintResponse)
async def resolve_complaint(
    complaint_id: int,
    resolution_data: ComplaintResolution,
    supervisor_email: str = Header(..., alias="X-User-Email"),
    db: AsyncSession = Depends(get_db)
):
    """Mark complaint as resolved"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.get_complaint(complaint_id)
    
    if not complaint:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    # Verify assignment (allow if not assigned or assigned to this supervisor)
    if complaint.assigned_to_email and complaint.assigned_to_email != supervisor_email:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only resolve complaints assigned to you"
        )
    
    if complaint.status not in [ComplaintStatus.IN_PROGRESS, ComplaintStatus.REOPENED, ComplaintStatus.PENDING]:
        raise HTTPException(
            status_code=400,
            detail="Only pending, in-progress or reopened complaints can be resolved"
        )
    
    complaint = await service.resolve_complaint(complaint_id, resolution_data)
    return complaint


@router.post("/{complaint_id}/close", response_model=ComplaintResponse)
async def close_complaint(
    complaint_id: int,
    db: AsyncSession = Depends(get_db)
):
    """Close a resolved complaint"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.get_complaint(complaint_id)
    
    if not complaint:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    try:
        complaint = await service.close_complaint(complaint_id)
        return complaint
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.post("/{complaint_id}/notes", status_code=status.HTTP_201_CREATED)
async def add_note(
    complaint_id: int,
    note: str,
    is_internal: bool = True,
    user_name: str = Header(..., alias="X-User-Name"),
    user_email: str = Header(..., alias="X-User-Email"),
    db: AsyncSession = Depends(get_db)
):
    """Add internal or public note to complaint"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaint = await service.get_complaint(complaint_id)
    
    if not complaint:
        raise HTTPException(status_code=404, detail="Complaint not found")
    
    note_data = ComplaintNoteCreate(
        note=note,
        user_name=user_name,
        user_email=user_email,
        is_internal=is_internal
    )
    
    created_note = await service.add_note(complaint_id, note_data)
    
    return {
        "message": "Note added successfully",
        "note_id": created_note.id
    }


@router.get("/analytics/performance", response_model=SupervisorPerformance)
async def get_my_performance(
    supervisor_email: str = Header(..., alias="X-User-Email"),
    start_date: Optional[datetime] = Query(None),
    end_date: Optional[datetime] = Query(None),
    db: AsyncSession = Depends(get_db)
):
    """Get personal performance metrics"""
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    performance = await service.get_supervisor_performance(
        supervisor_email,
        start_date,
        end_date
    )
    
    return performance


@router.get("/analytics/unresolved")
async def get_unresolved_complaints(
    supervisor_email: str = Header(..., alias="X-User-Email"),
    hostel_name: Optional[str] = None,
    db: AsyncSession = Depends(get_db)
):
    """Get unresolved complaints with aging information"""
    filters = ComplaintFilter(
        hostel_name=hostel_name,
        assigned_to_email=supervisor_email,
        page=1,
        page_size=100
    )
    
    repository = ComplaintRepository(db)
    service = ComplaintService(repository)
    
    complaints, total = await service.list_complaints(filters)
    
    # Filter unresolved
    unresolved = [
        c for c in complaints 
        if c.status not in [ComplaintStatus.RESOLVED, ComplaintStatus.CLOSED]
    ]
    
    # Calculate aging
    now = datetime.utcnow()
    aging_data = []
    
    for complaint in unresolved:
        age_hours = (now - complaint.created_at).total_seconds() / 3600
        sla_breached = complaint.sla_deadline and now > complaint.sla_deadline
        
        aging_data.append({
            "id": complaint.id,
            "title": complaint.title,
            "category": complaint.category.value,
            "priority": complaint.priority.value,
            "status": complaint.status.value,
            "age_hours": round(age_hours, 2),
            "sla_deadline": complaint.sla_deadline,
            "sla_breached": sla_breached,
            "created_at": complaint.created_at
        })
    
    # Sort by age descending
    aging_data.sort(key=lambda x: x['age_hours'], reverse=True)
    
    return {
        "total_unresolved": len(aging_data),
        "complaints": aging_data
    }

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\dashboard.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\maintenance.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\mess_menu.py ---
from fastapi import APIRouter, Depends, Query, status
from typing import List, Optional
from datetime import date
from app.schemas.mess_menu import (
    MessMenuCreate, MessMenuUpdate, MessMenuResponse,
    MenuFeedbackResponse, MealPreferenceResponse
)
from app.services.mess_menu_service import MessMenuService
from app.dependencies import get_mess_menu_service

router = APIRouter(prefix="/supervisor/mess-menu", tags=["Supervisor - Mess Menu"])


@router.post("/", response_model=MessMenuResponse, status_code=status.HTTP_201_CREATED)
def propose_menu(
    menu: MessMenuCreate,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Propose a new menu for admin approval (Supervisor)
    - Daily menu management based on weekly/monthly plans
    - Propose menu modifications
    """
    return service.create_menu(menu)


@router.get("/{menu_id}", response_model=MessMenuResponse)
def get_menu(
    menu_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get specific menu by ID (Supervisor)
    """
    return service.get_menu(menu_id)


@router.get("/hostel/{hostel_id}", response_model=List[MessMenuResponse])
def get_hostel_menus(
    hostel_id: int,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    menu_type: Optional[str] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get all menus for supervised hostel (Supervisor)
    - View and manage daily menus
    """
    return service.get_menus_by_hostel(
        hostel_id, skip, limit, menu_type, start_date, end_date
    )


@router.put("/{menu_id}", response_model=MessMenuResponse)
def update_menu(
    menu_id: int,
    menu_update: MessMenuUpdate,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Update menu for minor modifications (Supervisor)
    - Ingredient substitutions within guidelines
    - Last-minute dietary emergency accommodations
    - Special occasion updates (with pre-approval)
    """
    return service.update_menu(menu_id, menu_update)


@router.post("/{menu_id}/publish", response_model=MessMenuResponse)
def publish_menu(
    menu_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Publish approved menu for students (Supervisor)
    - Make menu visible to students
    """
    return service.publish_menu(menu_id)


@router.get("/{menu_id}/feedback", response_model=List[MenuFeedbackResponse])
def get_menu_feedback(
    menu_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get feedback for a specific menu (Supervisor)
    - Quality monitoring
    - Student satisfaction tracking
    """
    return service.get_menu_feedback(menu_id)


@router.get("/{menu_id}/feedback/summary", response_model=dict)
def get_feedback_summary(
    menu_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get feedback summary with averages (Supervisor)
    - Average ratings for taste, quantity, hygiene
    - Overall satisfaction metrics
    """
    return service.get_feedback_summary(menu_id)


@router.get("/hostel/{hostel_id}/preferences", response_model=List[MealPreferenceResponse])
def get_hostel_preferences(
    hostel_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get all meal preferences for hostel students (Supervisor)
    - Track special dietary requirements
    - Medical conditions registry
    """
    return service.get_hostel_preferences(hostel_id)


@router.get("/hostel/{hostel_id}/dietary-restrictions", response_model=dict)
def get_dietary_restrictions_report(
    hostel_id: int,
    service: MessMenuService = Depends(get_mess_menu_service)
):
    """
    Get dietary restrictions report (Supervisor)
    - Summary for meal planning
    - Allergy and medical requirement overview
    """
    return service.get_dietary_restrictions_report(hostel_id)

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\notification.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.schemas.notification import NotificationCreate, NotificationOut
from app.services.notification_service import NotificationService
from app.core.database import get_db

router = APIRouter(prefix="/supervisor/notifications", tags=["supervisor-notifications"])


@router.post("/notify", response_model=NotificationOut)
def notify_supervisor(payload: NotificationCreate, db: Session = Depends(get_db)):
	svc = NotificationService(db)
	try:
		notif = svc.send_notification(
			recipient_id=payload.recipient_id,
			recipient_type=payload.recipient_type,
			channel=payload.channel,
			subject=payload.subject or "",
			body=payload.body or "",
		)
		return notif
	except Exception as exc:
		raise HTTPException(status_code=500, detail=str(exc))



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\permissions.py ---
"""
Manage Supervisor & Admin permission rules
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.core.roles import Role
from app.api.deps import role_required
from app.models.user import User
from app.services.permission_service import PermissionService
from app.schemas.permission import RolePermissionAssign

router = APIRouter()


# ---------------------------
# Assign Permission to Role
# ---------------------------
@router.post("/permissions/assign", response_model=dict, status_code=status.HTTP_200_OK)
async def assign_permission_to_role(
    assign_data: RolePermissionAssign,
    current_user: User = Depends(role_required(Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Assign permission to role (Superadmin only)"""
    return PermissionService(db).assign_permission_to_role(assign_data)


# ---------------------------
# Get permissions for a role
# ---------------------------
@router.get("/permissions/role/{role}", response_model=dict, status_code=status.HTTP_200_OK)
async def get_role_permissions(
    role: str,
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Return all permissions for a role"""
    return PermissionService(db).get_role_permissions(role)


# ---------------------------
# Get all permissions
# ---------------------------
@router.get("/permissions/all", response_model=List[dict], status_code=status.HTTP_200_OK)
async def get_all_permissions(
    current_user: User = Depends(role_required(Role.ADMIN, Role.SUPERADMIN)),
    db: Session = Depends(get_db)
):
    """Return all available permissions"""
    return PermissionService(db).get_all_permissions()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\reports.py ---
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from datetime import date, datetime, timedelta
from app.core.database import get_db
from app.schemas.reports import AttendanceReport, AttendanceTrend
from app.services.analytics_service import AnalyticsService

router = APIRouter(prefix="/supervisor/reports", tags=["Supervisor Reports"])

@router.get("/daily-summary")
def get_daily_summary(hostel_id: int, report_date: date = None, db: Session = Depends(get_db)):
    """Get end-of-day operational summary"""
    if not report_date:
        report_date = date.today()
    
    # Attendance summary
    attendance = AnalyticsService.get_attendance_report(db, hostel_id, report_date)
    
    # Complaint summary
    from app.models.complaint import Complaint
    from app.models.hostel import Hostel
    
    # Get hostel name
    hostel = db.query(Hostel).filter(Hostel.id == hostel_id).first()
    hostel_name = hostel.hostel_name if hostel else "Unknown"
    
    # Query complaints for this hostel
    complaints_query = db.query(Complaint).filter(
        Complaint.hostel_name == hostel_name,
        Complaint.created_at >= datetime.combine(report_date, datetime.min.time()),
        Complaint.created_at <= datetime.combine(report_date, datetime.max.time())
    ).all()
    
    new_complaints = len([c for c in complaints_query if c.created_at.date() == report_date])
    resolved_complaints = len([c for c in complaints_query if c.resolved_at and c.resolved_at.date() == report_date])
    
    return {
        "date": report_date,
        "hostel_id": hostel_id,
        "attendance": attendance,
        "complaints": {
            "new": new_complaints,
            "resolved": resolved_complaints,
            "pending": len([c for c in complaints_query if c.status == "pending"])
        },
        "generated_at": datetime.utcnow()
    }

@router.get("/weekly-summary")
def get_weekly_summary(hostel_id: int, end_date: date = None, db: Session = Depends(get_db)):
    """Get weekly performance overview"""
    from app.repositories.complaint_repository import ComplaintRepository
    
    if not end_date:
        end_date = date.today()
    
    start_date = end_date - timedelta(days=7)
    
    # Attendance trends
    attendance_trend = AnalyticsService.get_attendance_trends(db, hostel_id, start_date, end_date)
    
    # Complaint stats
    complaint_stats = ComplaintRepository.get_statistics(
        db, [hostel_id],
        datetime.combine(start_date, datetime.min.time()),
        datetime.combine(end_date, datetime.max.time())
    )
    
    return {
        "period": f"{start_date} to {end_date}",
        "hostel_id": hostel_id,
        "attendance_trends": attendance_trend,
        "complaint_statistics": complaint_stats,
        "generated_at": datetime.utcnow()
    }

@router.get("/monthly-performance")
def get_monthly_performance(hostel_id: int, month: int, year: int, db: Session = Depends(get_db)):
    """Get detailed monthly operational analysis"""
    from calendar import monthrange
    from app.services.analytics_service import AnalyticsService
    
    start_date = date(year, month, 1)
    _, last_day = monthrange(year, month)
    end_date = date(year, month, last_day)
    
    # Attendance analysis
    attendance_trend = AnalyticsService.get_attendance_trends(db, hostel_id, start_date, end_date)
    
    # Complaint metrics
    complaint_metrics = AnalyticsService.get_complaint_metrics(db, [hostel_id], start_date, end_date)
    
    # Financial summary (if supervisor has access)
    from sqlalchemy import text
    financial = db.execute(text("""
        SELECT 
            SUM(CASE WHEN transaction_type = 'expense' AND amount <= 10000 THEN amount ELSE 0 END) as approved_expenses
        FROM financial_transactions
        WHERE hostel_id = :hostel_id
        AND transaction_date BETWEEN :start_date AND :end_date
    """), {'hostel_id': hostel_id, 'start_date': start_date, 'end_date': end_date}).first()
    
    return {
        "period": f"{month}/{year}",
        "hostel_id": hostel_id,
        "attendance": attendance_trend,
        "complaints": complaint_metrics[0] if complaint_metrics else None,
        "financial": {
            "approved_expenses": float(financial.approved_expenses or 0)
        },
        "generated_at": datetime.utcnow()
    }

@router.get("/attendance/daily")
def get_daily_attendance(hostel_id: int, report_date: date, db: Session = Depends(get_db)):
    """Get attendance report for specific date"""
    return AnalyticsService.get_attendance_report(db, hostel_id, report_date)

@router.get("/attendance/trends")
def get_attendance_trends(hostel_id: int, start_date: date, end_date: date, 
                         db: Session = Depends(get_db)):
    """Get attendance trends over period"""
    return AnalyticsService.get_attendance_trends(db, hostel_id, start_date, end_date)

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\students.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\supervisor\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\admins.py ---
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session
from typing import List
import logging
from app.core.database import get_db
from app.repositories.admin_repository import AdminRepository
from app.services.admin_service import AdminService

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
from app.schemas.admin_schemas import (
    AdminCreate,
    AdminResponse,
    AdminHostelAssignmentCreate,
    AdminHostelAssignmentResponse,
    BulkAssignmentRequest,
    BulkAssignmentResponse,
    PermissionLevel
)

router = APIRouter(prefix="/admins", tags=["admins"])

def get_admin_service(db: Session = Depends(get_db)) -> AdminService:
    return AdminService(AdminRepository(db))

@router.post("/", response_model=AdminResponse)
async def create_admin(
    request: Request,
    admin: AdminCreate,
    admin_service: AdminService = Depends(get_admin_service)
):
    """Create a new admin."""
    try:
        body = await request.json()
        logger.info(f"Creating admin with data: {body}")
        result = admin_service.create_admin(admin)
        logger.info(f"Admin created successfully: {result}")
        return result
    except Exception as e:
        logger.error(f"Error creating admin: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )

@router.get("/", response_model=List[AdminResponse])
def get_all_admins(
    admin_service: AdminService = Depends(get_admin_service)
):
    """Get all admins."""
    return admin_service.get_all_admins()

@router.get("/{admin_id}", response_model=AdminResponse)
def get_admin(
    admin_id: int,
    admin_service: AdminService = Depends(get_admin_service)
):
    """Get a specific admin by ID."""
    return admin_service.get_admin(admin_id)

@router.post("/{admin_id}/hostels", response_model=AdminHostelAssignmentResponse)
async def assign_hostel_to_admin(
    request: Request,
    admin_id: int,
    assignment: AdminHostelAssignmentCreate,
    admin_service: AdminService = Depends(get_admin_service)
):
    """Assign a hostel to an admin with specific permission level."""
    try:
        body = await request.json()
        logger.info(f"Assigning hostel to admin {admin_id} with data: {body}")
        result = admin_service.assign_hostel(admin_id, assignment)
        logger.info(f"Hostel assignment created successfully: {result}")
        return result
    except Exception as e:
        logger.error(f"Error assigning hostel to admin: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )

@router.post("/bulk-assign", response_model=BulkAssignmentResponse)
async def bulk_assign_hostels(
    request: Request,
    assignment: BulkAssignmentRequest,
    admin_service: AdminService = Depends(get_admin_service)
):
    """Assign multiple hostels to an admin in bulk."""
    try:
        # Log the incoming request body
        body = await request.json()
        logger.info(f"Bulk assigning hostels with data: {body}")
        
        result = admin_service.bulk_assign_hostels(assignment)
        logger.info(f"Bulk assignment successful: {result}")
        return result
    except Exception as e:
        logger.error(f"Error in bulk_assign_hostels endpoint: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )

@router.get("/{admin_id}/hostels", response_model=List[AdminHostelAssignmentResponse])
def get_admin_hostel_assignments(
    admin_id: int,
    admin_service: AdminService = Depends(get_admin_service)
):
    """Get all hostel assignments for an admin."""
    return admin_service.get_admin_hostel_assignments(admin_id)

@router.put("/{admin_id}/hostels/{hostel_id}", response_model=AdminHostelAssignmentResponse)
def update_hostel_permission(
    admin_id: int,
    hostel_id: int,
    permission_level: PermissionLevel,
    admin_service: AdminService = Depends(get_admin_service)
):
    """Update the permission level for a specific hostel assignment."""
    return admin_service.update_hostel_permission(admin_id, hostel_id, permission_level)

@router.delete("/{admin_id}/hostels/{hostel_id}")
def remove_hostel_assignment(
    admin_id: int,
    hostel_id: int,
    admin_service: AdminService = Depends(get_admin_service)
):
    """Remove a hostel assignment from an admin."""
    admin_service.remove_hostel_assignment(admin_id, hostel_id)
    return {"message": "Assignment removed successfully"}

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\analytics.py ---
from fastapi import APIRouter, Depends, status, HTTPException
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.services import analytics_services as hostel_summary_service

router = APIRouter(prefix="/api/analytics", tags=["Analytics"])

@router.get("/{hostel_id}")
def get_hostel_summary(hostel_id: int, db: Session = Depends(get_db)):
    """
    Fetch occupancy rate and revenue for a given hostel using stored procedure.
    """
    data = hostel_summary_service.fetch_hostel_summary(db, hostel_id)
    
    if not data:
        raise HTTPException(status_code=404, detail="No data found for this hostel.")
    
    return {
        "hostel_id": hostel_id,
        "summary": data
    }


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\dashboard.py ---
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.services.dashboard_service import DashboardService
from app.schemas.super_admin_schemas import DashboardResponse
import logging

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/dashboard", tags=["Dashboard"])

@router.get("/", response_model=DashboardResponse)
def get_dashboard(db: Session = Depends(get_db)):
    try:
        data = DashboardService.get_dashboard_and_activities(db)
        return data
    except Exception as e:
        logger.exception('Error fetching dashboard')
        raise HTTPException(status_code=500, detail="Failed to fetch dashboard data")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\hostels.py ---
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from app.core.database import get_db
from app.schemas.super_admin_schemas import HostelCreate, HostelUpdate, HostelUpsert, HostelResponse, SuccessResponse
from app.services.super_admin_service import HostelService
import logging

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/v1/hostels", tags=["Hostels"])

@router.post("/", response_model=HostelResponse, status_code=status.HTTP_201_CREATED)
def create_hostel(payload: HostelCreate, db: Session = Depends(get_db)):
    upsert_data = HostelUpsert(**payload.model_dump(), id=None)
    result = HostelService.upsert_hostel(db, upsert_data)
    if not result:
        raise HTTPException(status_code=400, detail="Failed to create hostel")
    return result

@router.put("/{hostel_id}", response_model=HostelResponse)
def update_hostel(hostel_id: int, payload: HostelUpdate, db: Session = Depends(get_db)):
    existing = HostelService.get_hostel_by_id(db, hostel_id)
    if not existing:
        raise HTTPException(status_code=404, detail="Hostel not found")
    update_data = payload.model_dump(exclude_unset=True)
    merged = {**existing, **update_data}
    upsert = HostelUpsert(**merged, id=hostel_id)
    result = HostelService.upsert_hostel(db, upsert)
    if not result:
        raise HTTPException(status_code=400, detail="Failed to update hostel")
    return result

@router.get("/", response_model=List[HostelResponse])
def list_hostels(skip: int = Query(0, ge=0), limit: int = Query(100, ge=1, le=1000), search: Optional[str] = None, db: Session = Depends(get_db)):
    if search:
        return HostelService.search_hostels(db, search, skip, limit)
    return HostelService.get_all_hostels(db, skip, limit)

@router.get("/{hostel_id}", response_model=HostelResponse)
def get_hostel(hostel_id: int, db: Session = Depends(get_db)):
    res = HostelService.get_hostel_by_id(db, hostel_id)
    if not res:
        raise HTTPException(status_code=404, detail="Hostel not found")
    return res

@router.delete("/{hostel_id}", response_model=SuccessResponse)
def delete_hostel(hostel_id: int, db: Session = Depends(get_db)):
    deleted = HostelService.delete_hostel(db, hostel_id)
    if not deleted:
        raise HTTPException(status_code=404, detail="Hostel not found")
    return SuccessResponse(message="Hostel deleted", data={"id": deleted})


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\report.py ---
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from datetime import date, timedelta
from typing import List
from app.core.database import get_db
from app.schemas.reports import *
from app.services.analytics_service import AnalyticsService

router = APIRouter(prefix="/super-admin/reports", tags=["Super Admin Reports"])

@router.get("/dashboard/multi-hostel", response_model=MultiHostelDashboard)
def get_unified_dashboard(
    hostel_ids: List[int] = Query(...),
    start_date: date = Query(...),
    end_date: date = Query(...),
    db: Session = Depends(get_db)
):
    """Get unified multi-hostel dashboard with aggregate KPIs"""
    return AnalyticsService.get_multi_hostel_dashboard(db, hostel_ids, start_date, end_date)

@router.get("/cross-hostel/revenue-comparison")
def get_revenue_comparison(
    hostel_ids: List[int] = Query(...),
    current_start: date = Query(...),
    current_end: date = Query(...),
    db: Session = Depends(get_db)
):
    """Revenue comparison across multiple properties"""
    days_diff = (current_end - current_start).days
    previous_start = current_start - timedelta(days=days_diff)
    previous_end = current_start - timedelta(days=1)
    
    return AnalyticsService.get_revenue_comparison(
        db, hostel_ids, current_start, current_end, previous_start, previous_end
    )

@router.get("/cross-hostel/occupancy-trends")
def get_occupancy_trends(
    hostel_ids: List[int] = Query(...),
    start_date: date = Query(...),
    end_date: date = Query(...),
    db: Session = Depends(get_db)
):
    """Occupancy trends across multiple hostels"""
    return AnalyticsService.get_occupancy_trends(db, hostel_ids, start_date, end_date)

@router.get("/cross-hostel/complaint-metrics")
def get_complaint_metrics(
    hostel_ids: List[int] = Query(...),
    start_date: date = Query(...),
    end_date: date = Query(...),
    db: Session = Depends(get_db)
):
    """Complaint metrics across multiple hostels"""
    return AnalyticsService.get_complaint_metrics(db, hostel_ids, start_date, end_date)

@router.get("/marketing/analytics")
def get_marketing_analytics(
    hostel_ids: List[int] = Query(...),
    start_date: date = Query(...),
    end_date: date = Query(...),
    db: Session = Depends(get_db)
):
    """Marketing analytics across hostels"""
    return AnalyticsService.get_marketing_analytics(db, hostel_ids, start_date, end_date)

@router.get("/marketing/search-trends")
def get_search_trends(
    start_date: date = Query(...),
    end_date: date = Query(...),
    db: Session = Depends(get_db)
):
    """Search trends and user behavior analytics"""
    from sqlalchemy import text
    
    # Top search queries
    top_queries = db.execute(text("""
        SELECT query_text, COUNT(*) as search_count
        FROM search_queries
        WHERE searched_at BETWEEN :start_date AND :end_date
        AND query_text IS NOT NULL AND query_text != ''
        GROUP BY query_text
        ORDER BY search_count DESC
        LIMIT 10
    """), {
        'start_date': datetime.combine(start_date, datetime.min.time()),
        'end_date': datetime.combine(end_date, datetime.max.time())
    }).fetchall()
    
    # Top cities
    top_cities = db.execute(text("""
        SELECT city, COUNT(*) as search_count
        FROM search_queries
        WHERE searched_at BETWEEN :start_date AND :end_date
        AND city IS NOT NULL
        GROUP BY city
        ORDER BY search_count DESC
        LIMIT 10
    """), {
        'start_date': datetime.combine(start_date, datetime.min.time()),
        'end_date': datetime.combine(end_date, datetime.max.time())
    }).fetchall()
    
    # Daily search volume
    daily_volume = db.execute(text("""
        SELECT DATE(searched_at) as date, COUNT(*) as search_count
        FROM search_queries
        WHERE searched_at BETWEEN :start_date AND :end_date
        GROUP BY DATE(searched_at)
        ORDER BY date
    """), {
        'start_date': datetime.combine(start_date, datetime.min.time()),
        'end_date': datetime.combine(end_date, datetime.max.time())
    }).fetchall()
    
    return {
        "period": f"{start_date} to {end_date}",
        "top_queries": [{"query": row.query_text, "count": row.search_count} for row in top_queries],
        "top_cities": [{"city": row.city, "count": row.search_count} for row in top_cities],
        "daily_volume": [{"date": str(row.date), "count": row.search_count} for row in daily_volume]
    }

@router.get("/marketing/booking-conversion")
def get_booking_conversion_rates(
    hostel_ids: List[int] = Query(None),
    start_date: date = Query(...),
    end_date: date = Query(...),
    db: Session = Depends(get_db)
):
    """Booking conversion rates and revenue attribution"""
    from sqlalchemy import text
    
    where_clause = "WHERE booking_date BETWEEN :start_date AND :end_date"
    params = {
        'start_date': datetime.combine(start_date, datetime.min.time()),
        'end_date': datetime.combine(end_date, datetime.max.time())
    }
    
    if hostel_ids:
        where_clause += " AND hostel_id = ANY(:hostel_ids)"
        params['hostel_ids'] = hostel_ids
    
    bookings = db.execute(text(f"""
        SELECT 
            hostel_id,
            COUNT(*) as total_bookings,
            SUM(CASE WHEN converted THEN 1 ELSE 0 END) as converted_bookings,
            source
        FROM hostel_bookings
        {where_clause}
        GROUP BY hostel_id, source
    """), params).fetchall()
    
    return {
        "period": f"{start_date} to {end_date}",
        "bookings": [
            {
                "hostel_id": row.hostel_id,
                "total_bookings": row.total_bookings,
                "converted_bookings": row.converted_bookings,
                "conversion_rate": (row.converted_bookings / row.total_bookings * 100) if row.total_bookings > 0 else 0,
                "source": row.source
            }
            for row in bookings
        ]
    }

@router.get("/attendance/consolidated", response_model=ConsolidatedAttendanceReport)
def get_consolidated_attendance(
    hostel_ids: List[int] = Query(...),
    start_date: date = Query(...),
    end_date: date = Query(...),
    db: Session = Depends(get_db)
):
    """Consolidated attendance report across multiple hostels"""
    return AnalyticsService.get_consolidated_attendance_report(
        db, hostel_ids, start_date, end_date
    )

@router.get("/attendance/student-history")
def get_student_attendance_history(
    student_id: int,
    start_date: date,
    end_date: date,
    db: Session = Depends(get_db)
):
    """Individual student attendance history"""
    return AnalyticsService.get_student_attendance_history(db, student_id, start_date, end_date)

@router.get("/retention/analysis")
def get_student_retention(
    hostel_ids: List[int] = Query(...),
    db: Session = Depends(get_db)
):
    """Student retention rates and demographic analytics"""
    from sqlalchemy import text
    
    # This is a simplified version - would need proper student tracking
    result = db.execute(text("""
        SELECT 
            hostel_id,
            COUNT(DISTINCT student_id) as total_students,
            AVG(CASE WHEN is_present THEN 100.0 ELSE 0.0 END) as avg_attendance
        FROM attendance
        WHERE hostel_id = ANY(:hostel_ids)
        AND date >= CURRENT_DATE - INTERVAL '90 days'
        GROUP BY hostel_id
    """), {'hostel_ids': hostel_ids}).fetchall()
    
    return {
        "hostels": [
            {
                "hostel_id": row.hostel_id,
                "total_students": row.total_students,
                "average_attendance": float(row.avg_attendance or 0)
            }
            for row in result
        ]
    }

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\reports.py ---
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from typing import Optional, List
from datetime import datetime
from fastapi.responses import StreamingResponse

from app.core.database import get_db
from app.schemas.report_schemas import (
    BookingCreate, BookingResponse, CommissionResponse,
    ReportGenerateRequest, ReportResponse, FinancialSummaryResponse, ReportStatistics
)
from app.services.report_services import (
    book_room, change_booking_status, pay_commission,
    get_financial_summary_service, fetch_recent_reports, fetch_report_statistics,
    fetch_report, export_report_file
)

router = APIRouter()

# Dummy current user
def get_current_user():
    return {"user_id": "admin_001", "username": "admin"}

# Booking endpoints
@router.post("/api/bookings", tags=["Bookings"], status_code=status.HTTP_201_CREATED)
def create_new_booking(
    booking_data: BookingCreate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    booking = book_room(db, booking_data)
    return {"success": True, "data": BookingResponse.model_validate(booking)}

@router.patch("/api/bookings/{booking_id}/status", tags=["Bookings"])
def update_booking(
    booking_id: str,
    status: str,
    payment_status: str,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    booking = change_booking_status(db, booking_id, status, payment_status)
    return {"success": True, "data": BookingResponse.model_validate(booking)}

# Commission endpoints
@router.post("/api/commissions/{commission_id}/pay", tags=["Commissions"])
def pay_commission_endpoint(
    commission_id: str,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    commission = pay_commission(db, commission_id)
    return {"success": True, "data": CommissionResponse.model_validate(commission)}

# Financial summary
@router.get("/api/financial/summary", tags=["Financial"])
def financial_summary(
    start_date: Optional[str] = Query(None),
    end_date: Optional[str] = Query(None),
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    def _parse_date(s: str) -> datetime:
        # Accept ISO format and permissive YYYY-M-D (e.g. 2025-11-1)
        if not s:
            raise ValueError("empty date")
        try:
            return datetime.fromisoformat(s)
        except Exception:
            # Fallback: split and construct (handles single-digit month/day)
            try:
                # allow datetime with time portion (take date part)
                date_part = s.split('T')[0]
                y, m, d = date_part.split('-')
                return datetime(int(y), int(m), int(d))
            except Exception:
                raise HTTPException(status_code=400, detail=f"Invalid date format: {s}")

    if not start_date or not end_date:
        now = datetime.utcnow()
        start = datetime(now.year, now.month, 1)
        from calendar import monthrange
        _, last_day = monthrange(now.year, now.month)
        end = datetime(now.year, now.month, last_day, 23, 59, 59)
    else:
        start = _parse_date(start_date)
        end = _parse_date(end_date)

    summary = get_financial_summary_service(db, start, end)
    return {"success": True, "data": FinancialSummaryResponse(**summary)}

# Report generation
@router.post("/api/reports/generate", tags=["Reports"])
def generate_report(
    request: ReportGenerateRequest,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    report_type = request.report_type
    user_id = current_user["user_id"]

    if report_type == "revenue":
        report = generate_revenue = None
        report = __import__('app.repositories.report_repositories', fromlist=['']).generate_revenue_report(db, request.start_date, request.end_date, user_id)
    elif report_type == "commission":
        report = __import__('app.repositories.report_repositories', fromlist=['']).generate_commission_report(db, request.start_date, request.end_date, user_id)
    else:
        raise HTTPException(status_code=400, detail="Unsupported report type")

    return {"success": True, "data": ReportResponse.model_validate(report)}

@router.get("/api/reports/recent", tags=["Reports"])
def list_recent_reports(
    limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    reports = fetch_recent_reports(db, limit)
    return {"success": True, "data": [ReportResponse.model_validate(r) for r in reports]}

@router.get("/api/reports/statistics", tags=["Reports"])
def get_statistics(
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    stats = fetch_report_statistics(db)
    return {"success": True, "data": ReportStatistics(**stats)}

@router.get("/api/reports/{report_id}", tags=["Reports"])
def get_report(report_id: str, db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):
    report = fetch_report(db, report_id)
    return {"success": True, "data": ReportResponse.model_validate(report)}

# Export endpoints
@router.get("/api/reports/{report_id}/export", tags=["Export"])
def export_report(report_id: str, format: Optional[str] = Query(None), db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):
    report = fetch_report(db, report_id)
    # use requested format if provided
    if format:
        report.export_format = format
    file_stream = export_report_file(report)
    export_format = (report.export_format or "pdf").lower()

    content_type = {
        "pdf": "application/pdf",
        "csv": "text/csv",
        "excel": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    }.get(export_format, "application/octet-stream")

    filename = f"report_{report.id}.{export_format if export_format != 'excel' else 'xlsx'}"

    return StreamingResponse(
        file_stream,
        media_type=content_type,
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )

# Health
@router.get("/health", tags=["System"])
def health_check():
    return {"status": "healthy", "timestamp": datetime.utcnow().isoformat()}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\shift_coordination.py ---
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.schemas.shift_coordination_schemas import (
    ShiftCreate, ShiftScheduleCreate, TaskCreate, TaskUpdate,
    TaskDelegationCreate, HandoverCreate, HandoverItemCreate, CoordinationMeetingCreate
)
from app.services import shift_coordination_service as service

router = APIRouter(
    prefix="/api/shift-coordination",
    tags=["Shift Coordination System"]
)


# ====================== SHIFT =========================
@router.post("/shifts", status_code=status.HTTP_201_CREATED)
def create_shift(shift_data: ShiftCreate, db: Session = Depends(get_db)):
    return service.create_shift_service(db, shift_data)


@router.get("/shifts", status_code=status.HTTP_200_OK)
def get_shifts(db: Session = Depends(get_db)):
    return service.get_shifts_service(db)


# ====================== SCHEDULE =========================
@router.post("/schedules", status_code=status.HTTP_201_CREATED)
def create_shift_schedule(schedule_data: ShiftScheduleCreate, db: Session = Depends(get_db)):
    return service.create_shift_schedule_service(db, schedule_data)


# ====================== TASKS =========================
@router.post("/tasks", status_code=status.HTTP_201_CREATED)
def create_task(task_data: TaskCreate, db: Session = Depends(get_db)):
    return service.create_task_service(db, task_data)


@router.put("/tasks/{task_id}", status_code=status.HTTP_200_OK)
def update_task(task_id: int, update_data: TaskUpdate, db: Session = Depends(get_db)):
    task = service.update_task_service(db, task_id, update_data)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task


# ====================== DELEGATION =========================
@router.post("/tasks/delegate", status_code=status.HTTP_201_CREATED)
def delegate_task(delegation_data: TaskDelegationCreate, db: Session = Depends(get_db)):
    return service.delegate_task_service(db, delegation_data)


# ====================== HANDOVER =========================
@router.post("/handovers", status_code=status.HTTP_201_CREATED)
def create_handover(handover_data: HandoverCreate, db: Session = Depends(get_db)):
    return service.create_handover_service(db, handover_data)


@router.post("/handover-items", status_code=status.HTTP_201_CREATED)
def add_handover_item(item_data: HandoverItemCreate, db: Session = Depends(get_db)):
    return service.add_handover_item_service(db, item_data)


# ====================== COORDINATION MEETINGS =========================
@router.post("/meetings", status_code=status.HTTP_201_CREATED)
def create_meeting(meeting_data: CoordinationMeetingCreate, db: Session = Depends(get_db)):
    return service.create_meeting_service(db, meeting_data)


@router.get("/meetings/{hostel_id}", status_code=status.HTTP_200_OK)
def get_meetings(hostel_id: int, db: Session = Depends(get_db)):
    return service.get_meetings_by_hostel_service(db, hostel_id)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\subscription.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.core.database import get_db
from app import  schemas, services

router = APIRouter(prefix="/subscriptions", tags=["Subscriptions"])

# ───────────────────────────────────────────────────────────────
# PLANS
# ───────────────────────────────────────────────────────────────
@router.post("/plans", response_model=schemas.SubscriptionPlanResponse)
def create_plan(plan: schemas.SubscriptionPlanCreate, db: Session = Depends(get_db)):
    return services.subscription_service.create_plan_service(db, plan)


@router.get("/plans", response_model=list[schemas.SubscriptionPlanResponse])
def list_plans(db: Session = Depends(get_db)):
    return services.subscription_service.list_plans_service(db)


# ───────────────────────────────────────────────────────────────
# SUBSCRIPTIONS
# ───────────────────────────────────────────────────────────────
@router.post("/", response_model=schemas.SubscriptionResponse)
def create_subscription(subscription: schemas.SubscriptionCreate, db: Session = Depends(get_db)):
    try:
        return services.subscription_service.create_subscription_service(db, subscription)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.get("/", response_model=list[schemas.SubscriptionResponse])
def list_subscriptions(db: Session = Depends(get_db)):
    return services.subscription_service.list_subscriptions_service(db)


# ───────────────────────────────────────────────────────────────
# PAYMENTS
# ───────────────────────────────────────────────────────────────
@router.post("/payments", response_model=schemas.PaymentResponse)
def create_payment(payment: schemas.PaymentCreate, db: Session = Depends(get_db)):
    return services.subscription_service.create_payment_service(db, payment)


@router.get("/payments", response_model=list[schemas.PaymentResponse])
def list_payments(subscription_id: str = None, db: Session = Depends(get_db)):
    return services.subscription_service.list_payments_service(db, subscription_id)


# ───────────────────────────────────────────────────────────────
# CHANGES
# ───────────────────────────────────────────────────────────────
@router.post("/changes", response_model=schemas.SubscriptionChangeResponse)
def create_change(change: schemas.SubscriptionChangeCreate, db: Session = Depends(get_db)):
    return services.subscription_service.create_change_service(db, change)


@router.get("/changes/{subscription_id}", response_model=list[schemas.SubscriptionChangeResponse])
def list_changes(subscription_id: str, db: Session = Depends(get_db)):
    return services.subscription_service.list_changes_service(db, subscription_id)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\super_admin\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\auth_router.py ---
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import timedelta, datetime
from app.schemas.auth_schemas import UserRegister, UserResponse, OTPVerify, OTPResend, UserLogin, Token
from app.repositories import auth_repository as repo
from app.services import auth_service as service
from app.utils.helpers import otp_expiry_time
from app.core.database import get_db
from app.dependencies import get_current_user
from app.models.user import OTP

router = APIRouter()
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.schemas.auth_schemas import UserRegister, OTPVerify, OTPResend, Token
from app.schemas.auth_schemas import UserRegister, UserResponse, OTPVerify, OTPResend, Token

from app.repositories import auth_repository as repo
from app.services import auth_service as service
from app.core.database import get_db

router = APIRouter()

@router.post("/register", status_code=status.HTTP_201_CREATED)
async def register(user_data: UserRegister, db: Session = Depends(get_db)):
    if not user_data.email and not user_data.phone:
        raise HTTPException(400, "Email or phone required")
    if user_data.email and repo.get_user_by_email(db, user_data.email):
        raise HTTPException(400, "Email already registered")
    if user_data.phone and repo.get_user_by_phone(db, user_data.phone):
        raise HTTPException(400, "Phone already registered")

    hashed = service.get_password_hash(user_data.password)
    user = repo.create_user(db, name=user_data.name, email=user_data.email, phone=user_data.phone, hashed_password=hashed)

    otp_code = service.generate_otp()
    expires_at = service.otp_expiry_time()
    repo.create_otp(db, user_id=user.id, otp_code=otp_code, expires_at=expires_at, email=user.email, phone=user.phone)

    if user.email:
        await service.send_otp_email(user.email, otp_code)
    if user.phone:
        await service.send_otp_sms(user.phone, otp_code)

    return {"message": "User registered. OTP sent."}

@router.post("/verify-otp", response_model=Token)
async def verify_otp(otp_data: OTPVerify, db: Session = Depends(get_db)):
    otp_record = repo.get_valid_otp(db, otp_data.otp_code, email=otp_data.email, phone=otp_data.phone)
    if not otp_record:
        raise HTTPException(400, "Invalid or expired OTP")

    otp_record.is_used = True
    user = repo.get_user_by_id(db, otp_record.user_id)
    user.is_verified = True
    db.add_all([otp_record, user])
    db.commit()

    token = service.create_access_token({"sub": str(user.id), "email": user.email, "phone": user.phone})
    return {"access_token": token, "token_type": "bearer"}

@router.post("/resend-otp")
async def resend_otp(otp_data: OTPResend, db: Session = Depends(get_db)):
    user = None
    if otp_data.email:
        user = repo.get_user_by_email(db, otp_data.email)
    elif otp_data.phone:
        user = repo.get_user_by_phone(db, otp_data.phone)
    if not user:
        raise HTTPException(404, "User not found")

    repo.invalidate_user_otps(db, user.id)
    otp_code = service.generate_otp()
    expires_at = service.otp_expiry_time()
    repo.create_otp(db, user_id=user.id, otp_code=otp_code, expires_at=expires_at, email=user.email, phone=user.phone)

    if user.email:
        await service.send_otp_email(user.email, otp_code)
    if user.phone:
        await service.send_otp_sms(user.phone, otp_code)

    return {"message": "OTP resent successfully"}

@router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def register(user_data: UserRegister, db: Session = Depends(get_db)):
    if not user_data.email and not user_data.phone:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Either email or phone must be provided")

    if user_data.email:
        existing = repo.get_user_by_email(db, user_data.email)
        if existing:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Email already registered")
    if user_data.phone:
        existing = repo.get_user_by_phone(db, user_data.phone)
        if existing:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Phone number already registered")

    hashed = service.get_password_hash(user_data.password)
    user = repo.create_user(db, name=user_data.name, email=user_data.email, phone=user_data.phone, hashed_password=hashed)

    otp_code = service.generate_otp()
    expires_at = otp_expiry_time()
    repo.create_otp(db, user_id=user.id, otp_code=otp_code, expires_at=expires_at, email=user_data.email, phone=user_data.phone)

    if user_data.email:
        await service.send_otp_email(user_data.email, otp_code)
    if user_data.phone:
        await service.send_otp_sms(user_data.phone, otp_code)

    return user

@router.post("/verify-otp", response_model=Token)
async def verify_otp(otp_data: OTPVerify, db: Session = Depends(get_db)):
    if not otp_data.email and not otp_data.phone:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Either email or phone must be provided")
    
    print(f"\nVerifying OTP: {otp_data.otp_code} for email: {otp_data.email}, phone: {otp_data.phone}")
    
    otp_record = repo.get_valid_otp(db, otp_data.otp_code, email=otp_data.email, phone=otp_data.phone)
    if not otp_record:
        # Let's check if we can find the OTP regardless of usage status
        all_otps = db.query(OTP).filter(OTP.otp_code == otp_data.otp_code).all()
        if all_otps:
            print(f"Found OTPs but they were invalid:")
            for otp in all_otps:
                print(f"OTP: {otp.otp_code}, Used: {otp.is_used}, Expires: {otp.expires_at}, Email: {otp.email}, Phone: {otp.phone}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid OTP")
    
    print(f"Found valid OTP record: {otp_record.otp_code}, Expires: {otp_record.expires_at}")
    
    if datetime.utcnow() > otp_record.expires_at:
        print(f"OTP expired at {otp_record.expires_at}, current time: {datetime.utcnow()}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="OTP has expired")

    # mark used
    otp_record.is_used = True
    db.add(otp_record)
    db.commit()

    # set user verified
    user = repo.get_user_by_id(db, otp_record.user_id)
    user.is_verified = True
    db.add(user)
    db.commit()

    access_token = service.create_access_token({"sub": str(user.id), "email": user.email})
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/resend-otp")
async def resend_otp(otp_data: OTPResend, db: Session = Depends(get_db)):
    if not otp_data.email and not otp_data.phone:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Either email or phone must be provided")
    user = None
    if otp_data.email:
        user = repo.get_user_by_email(db, otp_data.email)
    if otp_data.phone:
        user = repo.get_user_by_phone(db, otp_data.phone)
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")

    otp_code = service.generate_otp()
    expires_at = otp_expiry_time()
    repo.create_otp(db, user_id=user.id, otp_code=otp_code, expires_at=expires_at, email=otp_data.email, phone=otp_data.phone)

    if otp_data.email:
        await service.send_otp_email(otp_data.email, otp_code)
    if otp_data.phone:
        await service.send_otp_sms(otp_data.phone, otp_code)
    return {"message": "OTP sent successfully"}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\bookings.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.dependencies import get_db
from app.schemas.booking import BookingCreate, BookingUpdate, BookingResponse
from app.services.booking_service import BookingService

router = APIRouter(prefix="/visitor/bookings", tags=["Visitor Bookings"])


# ---------------------------------------------------------
# CREATE BOOKING (Visitor)
# ---------------------------------------------------------
@router.post("/", response_model=BookingResponse)
def create_booking(data: BookingCreate, db: Session = Depends(get_db)):
    """
    Visitor booking creation.
    Double-booking prevention and locking are handled in BookingService.
    """
    return BookingService.create_booking(db, data)


# ---------------------------------------------------------
# MODIFY BOOKING (Visitor)
# ---------------------------------------------------------
@router.put("/{booking_id}", response_model=BookingResponse)
def modify_booking(booking_id: int, updates: BookingUpdate, db: Session = Depends(get_db)):
    return BookingService.modify_booking(db, booking_id, updates)


# ---------------------------------------------------------
# CANCEL BOOKING (Visitor)
# ---------------------------------------------------------
@router.delete("/{booking_id}")
def cancel_booking(booking_id: int, db: Session = Depends(get_db)):
    return BookingService.cancel_booking(db, booking_id)


# ---------------------------------------------------------
# GET BOOKING (Visitor)
# ---------------------------------------------------------
@router.get("/{booking_id}", response_model=BookingResponse)
def get_booking(booking_id: int, db: Session = Depends(get_db)):
    booking = BookingService.get_booking(db, booking_id)
    if not booking:
        raise HTTPException(404, "Booking not found")
    return booking


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\booking_calendar.py ---
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from datetime import date, timedelta

from app.dependencies import get_db
from app.models.hostel import Hostel
from app.models.rooms import Room
from app.models.booking import Booking


router = APIRouter(
    prefix="/visitor/calendar",
    tags=["Booking Calendar"]
)


@router.get("/{hostel_id}")
def get_calendar(
    hostel_id: int,
    start_date: date,
    end_date: date,
    db: Session = Depends(get_db)
):
    """
    Returns complete booking calendar for visual UI:
    - Room wise bookings
    - Date wise availability
    - Pending bookings included
    """

    # Validate hostel
    hostel = db.query(Hostel).filter(Hostel.id == hostel_id).first()
    if not hostel:
        raise HTTPException(status_code=404, detail="Hostel not found")

    # Fetch all rooms
    rooms = db.query(Room).filter(Room.hostel_id == hostel_id).all()

    if not rooms:
        raise HTTPException(status_code=404, detail="No rooms found in this hostel")

    # Fetch bookings within date range
    bookings = (
        db.query(Booking)
        .filter(
            Booking.hostel_id == hostel_id,
            Booking.check_in < end_date,
            Booking.check_out > start_date
        )
        .all()
    )

    # Build calendar data
    calendar = {}

    for room in rooms:
        calendar[room.id] = {
            "room_id": room.id,
            "room_type": room.room_type,
            "price": room.price,
            "dates": {}
        }

        current = start_date
        while current <= end_date:
            calendar[room.id]["dates"][current.isoformat()] = {
                "status": "available",
                "booking_id": None
            }
            current += timedelta(days=1)

    # Mark booked dates
    for b in bookings:
        current = b.check_in.date()
        while current < b.check_out.date():
            if current.isoformat() in calendar[b.room_id]["dates"]:
                calendar[b.room_id]["dates"][current.isoformat()] = {
                    "status": b.status.value,
                    "booking_id": b.id
                }
            current += timedelta(days=1)

    return {
        "hostel_id": hostel.id,
        "hostel_name": hostel.name,
        "start_date": start_date,
        "end_date": end_date,
        "rooms": list(calendar.values())
    }


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\booking_router.py ---
from fastapi import APIRouter, Depends, status, HTTPException, Path, Body
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.schemas.booking_schema import BookingCreate, BookingResponse, BookingStatusUpdate
from app.services.booking_service import create_booking, update_booking_status
from app.dependencies import get_current_user

router = APIRouter(tags=["Bookings"])


@router.post("/", response_model=BookingResponse, status_code=status.HTTP_201_CREATED)
def create_booking_request(
    booking_data: BookingCreate,
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    booking = create_booking(db, user_id=current_user.id, booking_data=booking_data)
    return booking


@router.put("/{booking_id}/status", response_model=BookingResponse)
def update_booking_status_route(
    booking_id: int = Path(..., description="Booking ID to update"),
    update_data: BookingStatusUpdate = Body(...),
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    booking = update_booking_status(db, booking_id=booking_id, status=update_data.status)
    if not booking:
        raise HTTPException(status_code=404, detail="Booking not found")
    return booking


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\hostels.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\payment_routers.py ---
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
import os

from app.schemas.payment_schemas import PaymentCreate, PaymentResponse, RefundRequest, RefundResponse, SecurityDepositReleaseRequest, SecurityDepositReleaseResponse, ConfirmationResponse
from app.services import payment_service
from app.core.database import get_db
from app.dependencies import get_current_user
from app.models.user import User
from app.models.payment import Confirmation
from app.utils.invoice import INVOICE_DIR, generate_invoice, send_email_simulation, send_sms_simulation

router = APIRouter()

@router.post("/initiate")
def initiate_payment(
    data: PaymentCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    return payment_service.initiate_payment(db, data, current_user.id)

@router.post("/{payment_id}/confirm", response_model=PaymentResponse)
def confirm_payment(payment_id: int, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    payment = payment_service.confirm_payment(db, payment_id)
    if not payment:
        raise HTTPException(status_code=404, detail="Payment not found")

    # Lookup the confirmation created by the service (if any)
    confirmation = (
        db.query(Confirmation)
        .filter(Confirmation.booking_id == payment.booking_id)
        .order_by(Confirmation.id.desc())
        .first()
    )

    if confirmation:
        # Build invoice PDF and schedule simulated notifications
        invoice_path = os.path.join(INVOICE_DIR, f"{confirmation.confirmation_number}.pdf")

        # Get user details if available
        user = None
        if payment.user_id:
            try:
                user = db.get(User, payment.user_id)
            except Exception:
                user = None

        user_name = user.name if user and getattr(user, "name", None) else "Guest"
        user_email = user.email if user and getattr(user, "email", None) else None
        user_phone = user.phone if user and getattr(user, "phone", None) else None

        # Generate invoice file synchronously (small file)
        generate_invoice(invoice_path, confirmation.confirmation_number, payment.amount, user_name)

        # Schedule background notifications
        if user_email:
            background_tasks.add_task(send_email_simulation, user_email, confirmation.confirmation_number, payment.amount)
        if user_phone:
            background_tasks.add_task(send_sms_simulation, user_phone, confirmation.confirmation_number, payment.amount)

    return payment

@router.get("", response_model=list[PaymentResponse])
def get_all_payments(db: Session = Depends(get_db)):
    return payment_service.get_all_payments(db)

@router.post("/refund", response_model=RefundResponse)
def refund_payment(data: RefundRequest, db: Session = Depends(get_db)):
    return payment_service.refund_payment(db, data)

@router.post("/security-deposit/release", response_model=SecurityDepositReleaseResponse)
def release_security_deposit(data: SecurityDepositReleaseRequest, db: Session = Depends(get_db)):
    result = payment_service.release_security_deposit(db, data)
    if not result:
        raise HTTPException(status_code=404, detail="Payment not found")
    return result

@router.get("/confirmations/{confirmation_number}", response_model=ConfirmationResponse)
def get_confirmation(confirmation_number: str, db: Session = Depends(get_db)):
    confirmation = payment_service.get_confirmation(db, confirmation_number)
    if not confirmation:
        raise HTTPException(status_code=404, detail="Confirmation not found")
    return confirmation


@router.get("/invoice/{confirmation_number}")
def download_invoice(confirmation_number: str):
    invoice_path = os.path.join(INVOICE_DIR, f"{confirmation_number}.pdf")
    if not os.path.isfile(invoice_path):
        raise HTTPException(status_code=404, detail="Invoice not found")
    return FileResponse(invoice_path, media_type="application/pdf", filename=f"{confirmation_number}.pdf")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\profile.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\public.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\public_comparison.py ---
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
import json

from app.dependencies import get_db
from app.models.hostel import Hostel
from app.models.rooms import Room

router = APIRouter(
    prefix="/visitor/compare",
    tags=["Hostel Comparison"]
)


@router.get("/")
def compare_hostels(
    hostel_ids: list[int] = Query(..., description="Provide up to 4 hostel IDs"),
    db: Session = Depends(get_db)
):
    """
    Compare up to 4 hostels and return essential details:
    - Basic info
    - Amenities
    - Pricing (min/max/average price)
    - City / location
    - Room types
    - Availability summary
    - Computed hostel score
    """
    if not 1 <= len(hostel_ids) <= 4:
        raise HTTPException(
            status_code=400,
            detail="You must provide between 1 to 4 hostel IDs."
        )

    hostels = (
        db.query(Hostel)
        .filter(Hostel.id.in_(hostel_ids))
        .all()
    )

    if not hostels:
        raise HTTPException(
            status_code=404,
            detail="No hostels found for the given IDs."
        )

    response = []

    for hostel in hostels:

        # Fetch rooms of hostel
        rooms = db.query(Room).filter(Room.hostel_id == hostel.id).all()

        prices = [r.price for r in rooms if r.price is not None]
        available_beds = sum(r.available_beds for r in rooms)
        available_rooms = len([r for r in rooms if r.available_beds > 0])

        # Convert amenities to list if stored as JSON/string
        amenities_list = []
        if hostel.amenities:
            try:
                amenities_list = json.loads(hostel.amenities)
                if isinstance(amenities_list, str):
                    amenities_list = amenities_list.split(",")
            except Exception:
                amenities_list = hostel.amenities.split(",")

        # Computed score (simple logic)
        hostel_score = 0
        if prices:
            hostel_score += 50
        if amenities_list:
            hostel_score += len(amenities_list) * 2
        if available_beds:
            hostel_score += min(available_beds, 20)

        hostel_data = {
            "id": hostel.id,
            "name": hostel.name,
            "city": hostel.city,
            "pincode": hostel.pincode,
            "description": hostel.description,
            "gender_type": hostel.gender_type,
            "amenities": amenities_list,

            # Pricing
            "min_price": min(prices) if prices else None,
            "max_price": max(prices) if prices else None,
            "avg_price": round(sum(prices) / len(prices), 2) if prices else None,

            # Rooms & Availability
            "total_rooms": len(rooms),
            "room_types": list({r.room_type for r in rooms}),
            "available_beds": available_beds,
            "available_rooms": available_rooms,

            # Scoring
            "hostel_score": hostel_score,

            # Dummy location score until real GPS support
            "distance_dummy_km": 1.0,
        }

        response.append(hostel_data)

    return {
        "count": len(response),
        "hostels": response
    }


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\reviews.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\search.py ---
from fastapi import APIRouter, Depends, Query, Request
from sqlalchemy.orm import Session
from typing import List
from app.core.database import get_db
from app.schemas.search import HostelSearchRequest, HostelSearchResponse, HostelSearchResult, HostelSearchFilters, HostelSearchSort
from app.services.search_service import SearchService

router = APIRouter(prefix="/visitor/search", tags=["Visitor Search"])

@router.post("/hostels", response_model=HostelSearchResponse)
def search_hostels(search_request: HostelSearchRequest, db: Session = Depends(get_db)):
    """Search hostels with filters and sorting (PostgreSQL or Elasticsearch)"""
    
    # Try Elasticsearch first for advanced features
    from app.core.elasticsearch import search_hostels_es, get_elasticsearch
    
    es_results = None
    if get_elasticsearch():
        try:
            filters_dict = search_request.filters.model_dump(exclude_none=True)
            es_results = search_hostels_es(
                query=filters_dict.get('query', ''),
                filters=filters_dict,
                size=search_request.page_size,
                from_=(search_request.page - 1) * search_request.page_size
            )
        except Exception as e:
            print(f"Elasticsearch search failed, falling back to PostgreSQL: {e}")
    
    if es_results:
        # Use Elasticsearch results
        results = []
        for hit in es_results['hits']:
            source = hit['_source']
            # Add distance if available
            if 'sort' in hit and len(hit['sort']) > 0:
                source['distance_km'] = hit['sort'][0]
            results.append(HostelSearchResult(**source))
        
        total_count = es_results['total']
        total_pages = (total_count + search_request.page_size - 1) // search_request.page_size
        
        response = HostelSearchResponse(
            results=results,
            total_count=total_count,
            page=search_request.page,
            page_size=search_request.page_size,
            total_pages=total_pages
        )
        
        # Add facets/aggregations to response
        response.facets = es_results.get('aggregations', {})
        
    else:
        # Fallback to PostgreSQL
        hostels, total_count = SearchService.search_hostels(
            db, 
            search_request.filters, 
            search_request.sort,
            search_request.page,
            search_request.page_size
        )
        
        results = [HostelSearchResult(**hostel) for hostel in hostels]
        total_pages = (total_count + search_request.page_size - 1) // search_request.page_size
        
        response = HostelSearchResponse(
            results=results,
            total_count=total_count,
            page=search_request.page,
            page_size=search_request.page_size,
            total_pages=total_pages
        )
    
    # Log search for analytics
    SearchService.log_search(db, search_request.filters, total_count)
    
    return response

@router.get("/autocomplete")
def autocomplete_search(
    query: str = Query(..., min_length=2),
    field: str = Query("name", regex="^(name|location|city)$"),
    limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db)
):
    """Autocomplete suggestions for hostel search"""
    from app.core.elasticsearch import autocomplete_hostels, get_elasticsearch
    
    if get_elasticsearch():
        suggestions = autocomplete_hostels(query, field, limit)
        if suggestions:
            return {"suggestions": suggestions}
    
    # Fallback to PostgreSQL LIKE search
    from sqlalchemy import text
    
    sql_query = f"""
        SELECT DISTINCT {field}, city
        FROM hostels
        WHERE LOWER({field}) LIKE LOWER(:query)
        LIMIT :limit
    """
    
    results = db.execute(
        text(sql_query),
        {'query': f'%{query}%', 'limit': limit}
    ).fetchall()
    
    return {
        "suggestions": [dict(row._mapping) for row in results]
    }

@router.get("/hostels/{hostel_id}")
def get_hostel_details(hostel_id: int, request: Request, db: Session = Depends(get_db)):
    """Get detailed hostel information"""
    from sqlalchemy import text
    
    hostel = db.execute(text("""
        SELECT * FROM hostels WHERE id = :id
    """), {'id': hostel_id}).first()
    
    if not hostel:
        from fastapi import HTTPException
        raise HTTPException(status_code=404, detail="Hostel not found")
    
    # Log profile view
    visitor_ip = request.client.host if request.client else None
    SearchService.log_profile_view(db, hostel_id, source="direct", visitor_ip=visitor_ip)
    
    return dict(hostel._mapping)

@router.get("/nearby-landmarks")
async def get_nearby_landmarks(
    latitude: float,
    longitude: float,
    radius: int = Query(2000, description="Radius in meters"),
    type: str = Query("point_of_interest", description="Place type")
):
    """Get nearby landmarks using Google Places API"""
    from app.integrations.google_maps import GoogleMapsService
    from app.config import settings
    import httpx
    
    if not settings.GOOGLE_MAPS_API_KEY:
        return {"error": "Google Maps API key not configured", "landmarks": []}
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://maps.googleapis.com/maps/api/place/nearbysearch/json",
                params={
                    "location": f"{latitude},{longitude}",
                    "radius": radius,
                    "type": type,
                    "key": settings.GOOGLE_MAPS_API_KEY
                }
            )
            data = response.json()
            
            if data.get("status") == "OK":
                landmarks = []
                for place in data.get("results", [])[:10]:
                    landmarks.append({
                        "name": place.get("name"),
                        "address": place.get("vicinity"),
                        "types": place.get("types", []),
                        "rating": place.get("rating"),
                        "location": place.get("geometry", {}).get("location")
                    })
                return {"landmarks": landmarks}
            else:
                return {"error": data.get("status"), "landmarks": []}
    except Exception as e:
        return {"error": str(e), "landmarks": []}

@router.get("/directions")
async def get_directions(
    origin_lat: float,
    origin_lng: float,
    dest_lat: float,
    dest_lng: float,
    mode: str = Query("transit", regex="^(driving|walking|bicycling|transit)$")
):
    """Get directions from origin to destination"""
    from app.integrations.google_maps import GoogleMapsService
    from app.config import settings
    import httpx
    
    if not settings.GOOGLE_MAPS_API_KEY:
        return {"error": "Google Maps API key not configured"}
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://maps.googleapis.com/maps/api/directions/json",
                params={
                    "origin": f"{origin_lat},{origin_lng}",
                    "destination": f"{dest_lat},{dest_lng}",
                    "mode": mode,
                    "key": settings.GOOGLE_MAPS_API_KEY
                }
            )
            data = response.json()
            
            if data.get("status") == "OK" and data.get("routes"):
                route = data["routes"][0]
                leg = route["legs"][0]
                
                return {
                    "distance": leg["distance"]["text"],
                    "duration": leg["duration"]["text"],
                    "steps": [
                        {
                            "instruction": step["html_instructions"],
                            "distance": step["distance"]["text"],
                            "duration": step["duration"]["text"]
                        }
                        for step in leg["steps"]
                    ],
                    "overview_polyline": route["overview_polyline"]["points"]
                }
            else:
                return {"error": data.get("status")}
    except Exception as e:
        return {"error": str(e)}

@router.post("/map-bounds")
def search_by_map_bounds(
    ne_lat: float = Query(..., description="Northeast latitude"),
    ne_lng: float = Query(..., description="Northeast longitude"),
    sw_lat: float = Query(..., description="Southwest latitude"),
    sw_lng: float = Query(..., description="Southwest longitude"),
    filters: HostelSearchFilters = None,
    db: Session = Depends(get_db)
):
    """Search hostels within map bounds (viewport-based search)"""
    from sqlalchemy import text
    
    # Build query with bounds filter
    query = """
        SELECT *
        FROM hostels
        WHERE 1=1
    """
    
    params = {
        'ne_lat': ne_lat,
        'ne_lng': ne_lng,
        'sw_lat': sw_lat,
        'sw_lng': sw_lng
    }
    
    # Add additional filters if provided
    if filters:
        if filters.gender:
            query += " AND gender_type = :gender"
            params['gender'] = filters.gender
    
    query += " LIMIT 100"
    
    results = db.execute(text(query), params).fetchall()
    
    return {
        "hostels": [dict(row._mapping) for row in results],
        "count": len(results)
    }

@router.get("/cities")
def get_available_cities(db: Session = Depends(get_db)):
    """Get list of cities with available hostels"""
    from sqlalchemy import text
    # Use COALESCE to prefer hostels.city but fall back to locations.city
    # This ensures hostels seeded with a `location_id` are included
    cities = db.execute(text("""
        SELECT COALESCE(h.city, l.city) AS city, COUNT(*) AS hostel_count
        FROM hostels h
        LEFT JOIN locations l ON h.location_id = l.id
        WHERE COALESCE(h.city, l.city) IS NOT NULL
        GROUP BY COALESCE(h.city, l.city)
        ORDER BY city
    """)).fetchall()

    return [{"city": row.city, "hostel_count": row.hostel_count} for row in cities]

@router.get("/amenities")
def get_available_amenities(db: Session = Depends(get_db)):
    """Get list of all available amenities"""
    from sqlalchemy import text
    
    # Fetch amenities from hostels and split them
    amenities_list = set()
    rows = db.execute(text("""
        SELECT DISTINCT amenities
        FROM hostels
        WHERE amenities IS NOT NULL
        ORDER BY amenities
    """)).fetchall()
    
    for row in rows:
        if row.amenities:
            # Split by comma or other delimiters if stored as text
            items = [item.strip() for item in str(row.amenities).split(',')]
            amenities_list.update(items)
    
    return sorted(list(amenities_list))

@router.get("/facets")
def get_search_facets(db: Session = Depends(get_db)):
    """Get faceted search options (aggregations)"""
    from sqlalchemy import text
    
    # Get all facet data in one go
    facets = {
        "cities": [],
        "areas": [],
        "genders": [],
        "amenities": [],
        "price_ranges": {
            "under_5000": 0,
            "5000_10000": 0,
            "10000_15000": 0,
            "above_15000": 0
        }
    }
    
    # Cities
    cities = db.execute(text("""
        SELECT city, COUNT(*) as count
        FROM hostels WHERE city IS NOT NULL
        GROUP BY city ORDER BY count DESC
    """)).fetchall()
    facets["cities"] = [{"value": r.city, "count": r.count} for r in cities]
    
    # Genders
    genders = db.execute(text("""
        SELECT gender_type, COUNT(*) as count
        FROM hostels WHERE gender_type IS NOT NULL
        GROUP BY gender_type
    """)).fetchall()
    facets["genders"] = [{"value": r.gender_type, "count": r.count} for r in genders]
    
    # Amenities - extract from text field
    amenities_list = {}
    amenities_rows = db.execute(text("""
        SELECT amenities
        FROM hostels WHERE amenities IS NOT NULL
    """)).fetchall()
    
    for row in amenities_rows:
        if row.amenities:
            items = [item.strip() for item in str(row.amenities).split(',')]
            for item in items:
                amenities_list[item] = amenities_list.get(item, 0) + 1
    
    facets["amenities"] = [{"value": k, "count": v} for k, v in sorted(amenities_list.items(), key=lambda x: x[1], reverse=True)[:30]]
    
    # Remove price ranges and areas since they don't have columns
    facets.pop("price_ranges", None)
    facets.pop("areas", None)
    
    return facets

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\simple_payment_router.py ---
from fastapi import APIRouter, BackgroundTasks, HTTPException
from fastapi.responses import FileResponse
import os
from datetime import datetime
from typing import Dict, List

from app.utils.invoice import (
    INVOICE_DIR,
    generate_booking_reference,
    generate_invoice,
    send_email_simulation,
    send_sms_simulation,
)

router = APIRouter()

# In-memory store for quick testing (not persistent, not thread-safe)
bookings_db: Dict[str, List[Dict]] = {}


@router.post("/confirm")
async def confirm_payment(user_email: str, phone: str, amount: float, background_tasks: BackgroundTasks):
    booking_ref = generate_booking_reference()
    invoice_path = os.path.join(INVOICE_DIR, f"{booking_ref}.pdf")

    # Generate invoice PDF
    generate_invoice(invoice_path, booking_ref, amount, user_email)

    # Schedule simulated email and SMS
    background_tasks.add_task(send_email_simulation, user_email, booking_ref, amount)
    background_tasks.add_task(send_sms_simulation, phone, booking_ref, amount)

    # Store booking in-memory
    booking_data = {
        "booking_ref": booking_ref,
        "user_email": user_email,
        "phone": phone,
        "amount": amount,
        "status": "confirmed",
        "invoice_path": invoice_path,
        "timestamp": datetime.utcnow(),
    }
    bookings_db.setdefault(user_email, []).append(booking_data)

    return {
        "booking_reference": booking_ref,
        "amount": amount,
        "status": "confirmed",
        "invoice_path": invoice_path,
    }


@router.get("/history/{user_email}")
async def get_booking_history(user_email: str):
    history = bookings_db.get(user_email)
    if not history:
        raise HTTPException(status_code=404, detail="No bookings found for this user")
    return [
        {
            "booking_ref": b["booking_ref"],
            "amount": b["amount"],
            "status": b["status"],
            "timestamp": b["timestamp"].strftime("%Y-%m-%d %H:%M"),
        }
        for b in history
    ]


@router.get("/transactions/{booking_ref}")
async def get_transaction(booking_ref: str):
    for user_bookings in bookings_db.values():
        for b in user_bookings:
            if b["booking_ref"] == booking_ref:
                return b
    raise HTTPException(status_code=404, detail="Transaction not found")


@router.get("/invoice/{booking_ref}")
async def download_invoice(booking_ref: str):
    # Find invoice path in in-memory store
    for user_bookings in bookings_db.values():
        for b in user_bookings:
            if b["booking_ref"] == booking_ref:
                invoice_path = b["invoice_path"]
                if not os.path.isfile(invoice_path):
                    raise HTTPException(status_code=404, detail="Invoice not found")
                return FileResponse(invoice_path, media_type="application/pdf", filename=f"{booking_ref}.pdf")
    raise HTTPException(status_code=404, detail="Invoice not found")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\waitlist.py ---
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime

from app.dependencies import get_db
from app.core.auth import visitor_required    # 🔐 Visitor Authentication

from app.models.waitlist import Waitlist
from app.schemas.waitlist import WaitlistCreate, WaitlistResponse


router = APIRouter(prefix="/visitor/waitlist", tags=["Visitor Waitlist"])


# ---------------------------------------------------------
# Visitor Add to Waitlist
# ---------------------------------------------------------
@router.post("/", response_model=WaitlistResponse, dependencies=[Depends(visitor_required)])
def add_to_waitlist(payload: WaitlistCreate, db: Session = Depends(get_db)):
    exists = (
        db.query(Waitlist)
        .filter(
            Waitlist.hostel_id == payload.hostel_id,
            Waitlist.room_type == payload.room_type,
            Waitlist.visitor_id == payload.visitor_id,
        )
        .first()
    )
    if exists:
        raise HTTPException(400, "You are already in waitlist for this room type")

    top = (
        db.query(Waitlist)
        .filter(
            Waitlist.hostel_id == payload.hostel_id,
            Waitlist.room_type == payload.room_type,
        )
        .order_by(Waitlist.priority.desc())
        .first()
    )

    next_priority = (top.priority + 1) if top else 1

    wl = Waitlist(
        hostel_id=payload.hostel_id,
        room_type=payload.room_type,
        visitor_id=payload.visitor_id,
        priority=next_priority,
        created_at=datetime.utcnow(),
    )

    db.add(wl)
    db.commit()
    db.refresh(wl)
    return wl


# ---------------------------------------------------------
# Visitor Get Their Own Waitlist Entries
# ---------------------------------------------------------
@router.get("/", response_model=list[WaitlistResponse], dependencies=[Depends(visitor_required)])
def my_waitlist(visitor_id: int, db: Session = Depends(get_db)):
    entries = (
        db.query(Waitlist)
        .filter(Waitlist.visitor_id == visitor_id)
        .order_by(Waitlist.priority.asc(), Waitlist.created_at.asc())
        .all()
    )
    return entries


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\visitor\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\webhooks =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\webhooks\notifications.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\webhooks\payment.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\webhooks\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\webhooks\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v1\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v2 =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v2\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\v2\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\api\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\audit_middleware.py ---
"""
🧾 Audit trail middleware
"""
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from datetime import datetime
from app.repositories.audit_repository import AuditRepository
from app.core.database import get_db


class AuditMiddleware(BaseHTTPMiddleware):
    """Log supervisor/admin actions to audit table"""
    
    async def dispatch(self, request: Request, call_next):
        # Only audit authenticated requests
        if not hasattr(request.state, "user_id"):
            return await call_next(request)
        
        # Only audit admin/supervisor actions
        user_role = getattr(request.state, "user_role", None)
        if user_role not in ["admin", "superadmin", "supervisor"]:
            return await call_next(request)
        
        # Log the request
        db = next(get_db())
        audit_repo = AuditRepository(db)
        
        try:
            audit_repo.create_audit_log(
                user_id=getattr(request.state, "user_id"),
                action=request.method,
                resource=request.url.path,
                hostel_id=getattr(request.state, "active_hostel_id", None),
                ip_address=request.client.host if request.client else None,
            )
        except Exception as e:
            # Don't fail the request if audit logging fails
            pass
        
        response = await call_next(request)
        return response



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\auth.py ---
"""
Authentication decorators and dependencies
"""
from fastapi import Depends, HTTPException, status, Request
from app.core.security import decode_token
from app.core.roles import Role, get_role_level


async def get_current_user(request: Request):
    """Extract current user from request state"""
    user_id = getattr(request.state, 'user_id', None)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    return {"user_id": user_id}


async def admin_required(request: Request):
    """Dependency: Require admin role or higher"""
    user_role = getattr(request.state, 'user_role', None)
    
    if not user_role:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    
    admin_level = get_role_level(Role.ADMIN)
    user_level = get_role_level(user_role)
    
    if user_level < admin_level:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )
    
    return {"user_role": user_role}


async def visitor_required(request: Request):
    """Dependency: Require visitor role or any authenticated user"""
    user_role = getattr(request.state, 'user_role', None)
    
    if not user_role:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    
    return {"user_role": user_role}


async def superadmin_required(request: Request):
    """Dependency: Require superadmin role"""
    user_role = getattr(request.state, 'user_role', None)
    
    if not user_role:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    
    if user_role != Role.SUPERADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Superadmin access required"
        )
    
    return {"user_role": user_role}


async def supervisor_required(request: Request):
    """Dependency: Require supervisor role or higher"""
    user_role = getattr(request.state, 'user_role', None)
    
    if not user_role:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    
    supervisor_level = get_role_level(Role.SUPERVISOR)
    user_level = get_role_level(user_role)
    
    if user_level < supervisor_level:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Supervisor access required"
        )
    
    return {"user_role": user_role}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\auth_middleware.py ---
"""
🧠 Auth + Role verification middleware
"""
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from app.core.security import decode_token
from app.core.roles import get_role_level


class AuthMiddleware(BaseHTTPMiddleware):
    """Verify JWT token and extract user info"""
    
    async def dispatch(self, request: Request, call_next):
        # Skip auth for public endpoints
        if request.url.path in ["/", "/health", "/api/v1/auth/login"]:
            return await call_next(request)
        
        # Extract token from header
        authorization = request.headers.get("Authorization")
        if not authorization or not authorization.startswith("Bearer "):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Missing or invalid authorization header"
            )
        
        token = authorization.split(" ")[1]
        try:
            payload = decode_token(token)
            request.state.user_id = payload.get("sub")
            request.state.user_role = payload.get("role")
            request.state.hostel_id = payload.get("hostel_id")
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )
        
        return await call_next(request)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\cache.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\database.py ---
"""Compatibility shim for database objects.

This module re-exports the engine, SessionLocal, Base, and helper
functions from `app.config` so the rest of the codebase can continue
to import from `app.core.database` while sharing a single Declarative
Base and engine used by the models.
"""

from app.config import engine, SessionLocal, Base, get_db, init_db  # re-export

__all__ = ["engine", "SessionLocal", "Base", "get_db", "init_db"]


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\elasticsearch.py ---
from elasticsearch import Elasticsearch
from app.config import settings
from typing import List, Dict, Any
import logging

# Suppress elasticsearch warnings
logging.getLogger('elastic_transport').setLevel(logging.ERROR)

es_client = None

def get_elasticsearch():
    global es_client
    if es_client is None:
        try:
            es_client = Elasticsearch(
                [settings.ELASTICSEARCH_URL],
                request_timeout=2,  # Faster timeout
                max_retries=0,  # Don't retry
                retry_on_timeout=False
            )
            # Quick ping to test connection
            if not es_client.ping():
                es_client = None
        except Exception as e:
            es_client = None
    return es_client

def init_elasticsearch_indices():
    """Initialize Elasticsearch indices for hostel search"""
    es = get_elasticsearch()
    if not es:
        print("Elasticsearch not available - search will use PostgreSQL")
        return
    
    try:
        index_name = "hostels"
        
        if not es.indices.exists(index=index_name):
            es.indices.create(
                index=index_name,
                body={
                    "settings": {
                        "analysis": {
                            "analyzer": {
                                "autocomplete_analyzer": {
                                    "type": "custom",
                                    "tokenizer": "standard",
                                    "filter": ["lowercase", "autocomplete_filter"]
                                },
                                "fuzzy_analyzer": {
                                    "type": "custom",
                                    "tokenizer": "standard",
                                    "filter": ["lowercase", "asciifolding"]
                                }
                            },
                            "filter": {
                                "autocomplete_filter": {
                                    "type": "edge_ngram",
                                    "min_gram": 2,
                                    "max_gram": 20
                                }
                            }
                        }
                    },
                    "mappings": {
                        "properties": {
                            "id": {"type": "integer"},
                            "name": {
                                "type": "text",
                                "analyzer": "standard",
                                "fields": {
                                    "autocomplete": {
                                        "type": "text",
                                        "analyzer": "autocomplete_analyzer"
                                    },
                                    "fuzzy": {
                                        "type": "text",
                                        "analyzer": "fuzzy_analyzer"
                                    }
                                }
                            },
                            "description": {"type": "text"},
                            "location": {
                                "type": "text",
                                "fields": {
                                    "autocomplete": {
                                        "type": "text",
                                        "analyzer": "autocomplete_analyzer"
                                    }
                                }
                            },
                            "city": {"type": "keyword"},
                            "area": {"type": "keyword"},
                            "pincode": {"type": "keyword"},
                            "gender": {"type": "keyword"},
                            "price_range_min": {"type": "float"},
                            "price_range_max": {"type": "float"},
                            "rating": {"type": "float"},
                            "amenities": {"type": "keyword"},
                            "available_beds": {"type": "integer"},
                            "geo_location": {"type": "geo_point"}
                        }
                    }
                }
            )
        print("Elasticsearch indices initialized successfully")
    except Exception as e:
        print(f"Elasticsearch initialization failed: {e}")
        print("Application will continue without Elasticsearch - search will use PostgreSQL")

def index_hostel(hostel_data: Dict[str, Any]):
    """Index a single hostel to Elasticsearch"""
    es = get_elasticsearch()
    if not es:
        return False
    
    try:
        # Add geo_location point
        if hostel_data.get('latitude') and hostel_data.get('longitude'):
            hostel_data['geo_location'] = {
                'lat': float(hostel_data['latitude']),
                'lon': float(hostel_data['longitude'])
            }
        
        es.index(
            index="hostels",
            id=hostel_data['id'],
            body=hostel_data
        )
        return True
    except Exception as e:
        print(f"Error indexing hostel {hostel_data.get('id')}: {e}")
        return False

def bulk_index_hostels(hostels: List[Dict[str, Any]]):
    """Bulk index hostels to Elasticsearch"""
    es = get_elasticsearch()
    if not es:
        return False
    
    try:
        from elasticsearch.helpers import bulk
        
        actions = []
        for hostel in hostels:
            # Add geo_location point
            if hostel.get('latitude') and hostel.get('longitude'):
                hostel['geo_location'] = {
                    'lat': float(hostel['latitude']),
                    'lon': float(hostel['longitude'])
                }
            
            actions.append({
                '_index': 'hostels',
                '_id': hostel['id'],
                '_source': hostel
            })
        
        success, failed = bulk(es, actions)
        print(f"Elasticsearch bulk index: {success} successful, {len(failed)} failed")
        return True
    except Exception as e:
        print(f"Error bulk indexing hostels: {e}")
        return False

def search_hostels_es(query: str, filters: Dict[str, Any], size: int = 20, from_: int = 0):
    """Advanced search using Elasticsearch"""
    es = get_elasticsearch()
    if not es:
        return None
    
    try:
        # Build Elasticsearch query
        must_conditions = []
        filter_conditions = []
        
        # Full-text search with fuzzy matching
        if query:
            must_conditions.append({
                "multi_match": {
                    "query": query,
                    "fields": ["name^3", "name.fuzzy^2", "description", "location.autocomplete"],
                    "fuzziness": "AUTO",
                    "prefix_length": 1
                }
            })
        
        # Filters
        if filters.get('city'):
            filter_conditions.append({"term": {"city": filters['city']}})
        
        if filters.get('area'):
            filter_conditions.append({"term": {"area": filters['area']}})
        
        if filters.get('gender'):
            filter_conditions.append({"term": {"gender": filters['gender']}})
        
        if filters.get('amenities'):
            for amenity in filters['amenities']:
                filter_conditions.append({"term": {"amenities": amenity}})
        
        # Price range
        if filters.get('min_price') or filters.get('max_price'):
            price_range = {}
            if filters.get('min_price'):
                price_range['gte'] = filters['min_price']
            if filters.get('max_price'):
                price_range['lte'] = filters['max_price']
            filter_conditions.append({"range": {"price_range_min": price_range}})
        
        # Rating
        if filters.get('min_rating'):
            filter_conditions.append({"range": {"rating": {"gte": filters['min_rating']}}})
        
        # Availability
        if filters.get('available_only'):
            filter_conditions.append({"range": {"available_beds": {"gt": 0}}})
        
        # Geo distance filter
        if filters.get('latitude') and filters.get('longitude'):
            filter_conditions.append({
                "geo_distance": {
                    "distance": f"{filters.get('radius_km', 5)}km",
                    "geo_location": {
                        "lat": filters['latitude'],
                        "lon": filters['longitude']
                    }
                }
            })
        
        # Build final query
        es_query = {
            "query": {
                "bool": {
                    "must": must_conditions if must_conditions else [{"match_all": {}}],
                    "filter": filter_conditions
                }
            },
            "size": size,
            "from": from_
        }
        
        # Add geo distance sorting if coordinates provided
        if filters.get('latitude') and filters.get('longitude'):
            es_query["sort"] = [
                {
                    "_geo_distance": {
                        "geo_location": {
                            "lat": filters['latitude'],
                            "lon": filters['longitude']
                        },
                        "order": "asc",
                        "unit": "km"
                    }
                }
            ]
        
        # Add aggregations for faceted search
        es_query["aggs"] = {
            "cities": {"terms": {"field": "city", "size": 50}},
            "areas": {"terms": {"field": "area", "size": 50}},
            "genders": {"terms": {"field": "gender"}},
            "amenities": {"terms": {"field": "amenities", "size": 50}},
            "price_ranges": {
                "range": {
                    "field": "price_range_min",
                    "ranges": [
                        {"to": 5000},
                        {"from": 5000, "to": 10000},
                        {"from": 10000, "to": 15000},
                        {"from": 15000}
                    ]
                }
            }
        }
        
        response = es.search(index="hostels", body=es_query)
        
        return {
            "hits": response['hits']['hits'],
            "total": response['hits']['total']['value'],
            "aggregations": response.get('aggregations', {})
        }
    except Exception as e:
        print(f"Elasticsearch search error: {e}")
        return None

def autocomplete_hostels(query: str, field: str = "name", size: int = 10):
    """Autocomplete suggestions for hostel search"""
    es = get_elasticsearch()
    if not es:
        return []
    
    try:
        response = es.search(
            index="hostels",
            body={
                "query": {
                    "match": {
                        f"{field}.autocomplete": {
                            "query": query,
                            "operator": "and"
                        }
                    }
                },
                "size": size,
                "_source": [field, "city", "area"]
            }
        )
        
        return [hit['_source'] for hit in response['hits']['hits']]
    except Exception as e:
        print(f"Autocomplete error: {e}")
        return []

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\exceptions.py ---
"""
Custom exceptions (AccessDenied, InvalidHostel)
"""
from fastapi import HTTPException, status


class AccessDeniedException(HTTPException):
    """Raised when user doesn't have permission"""
    def __init__(self, detail: str = "Access denied"):
        super().__init__(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail
        )


class InvalidHostelException(HTTPException):
    """Raised when hostel_id is invalid or user doesn't have access"""
    def __init__(self, detail: str = "Invalid hostel or access denied"):
        super().__init__(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail
        )


class RoleNotFoundException(HTTPException):
    """Raised when role doesn't exist"""
    def __init__(self, detail: str = "Role not found"):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=detail
        )


class SessionNotFoundException(HTTPException):
    """Raised when session doesn't exist"""
    def __init__(self, detail: str = "Session not found"):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=detail
        )



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\logger.py ---
"""Simple logger setup for the application."""
from __future__ import annotations

import logging
import os
from logging.handlers import RotatingFileHandler
from pathlib import Path

from app.config import settings


def setup_logger(name: str = "app") -> logging.Logger:
    """Configure and return a logger for the application.

    - Writes rotating file logs to `logs/app.log`.
    - Also emits to console (stderr).
    - Respects `settings.DEBUG` for log level.
    """
    log_level = logging.DEBUG if settings.DEBUG else logging.INFO

    logger = logging.getLogger(name)
    logger.setLevel(log_level)

    # Avoid adding handlers multiple times in interactive / reload environments
    if logger.handlers:
        return logger

    # Ensure logs directory exists
    logs_dir = Path("logs")
    try:
        logs_dir.mkdir(parents=True, exist_ok=True)
    except Exception:
        # If we can't create logs dir, fall back to console-only logging
        pass

    # File handler (rotating)
    try:
        file_handler = RotatingFileHandler(
            filename=str(logs_dir / "app.log"),
            maxBytes=10 * 1024 * 1024,
            backupCount=5,
            encoding="utf-8",
        )
        file_handler.setLevel(log_level)
        file_formatter = logging.Formatter(
            "%(asctime)s | %(levelname)-8s | %(name)s | %(message)s"
        )
        file_handler.setFormatter(file_formatter)
        logger.addHandler(file_handler)
    except Exception:
        # ignore file handler errors
        pass

    # Console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(log_level)
    console_formatter = logging.Formatter(
        "%(asctime)s | %(levelname)-8s | %(message)s"
    )
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)

    # Do not propagate to root logger to avoid duplicate messages
    logger.propagate = False

    return logger


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\middleware.py ---
"""
Middleware manager
"""
import time
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
from app.core.logger import setup_logger

logger = setup_logger()


class LoggingMiddleware(BaseHTTPMiddleware):
    """Log all requests"""
    
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        logger.info(
            f"{request.method} {request.url.path} - {response.status_code} - {process_time:.3f}s"
        )
        return response



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\permissions.py ---
"""
🧩 RBAC permission matrix
"""
from typing import Dict, List, Set
from app.core.roles import Role, RoleHierarchy


class Permission:
    """Permission constants"""
    # User management
    CREATE_USER = "create_user"
    READ_USER = "read_user"
    UPDATE_USER = "update_user"
    DELETE_USER = "delete_user"
    
    # Hostel management
    CREATE_HOSTEL = "create_hostel"
    READ_HOSTEL = "read_hostel"
    UPDATE_HOSTEL = "update_hostel"
    DELETE_HOSTEL = "delete_hostel"
    
    # Session management
    SWITCH_SESSION = "switch_session"
    VIEW_SESSION = "view_session"
    
    # Audit
    VIEW_AUDIT = "view_audit"
    CREATE_AUDIT = "create_audit"
    # Export / reporting
    EXPORT_AUDIT = "export_audit"
    # Subscriptions & finance
    MANAGE_SUBSCRIPTIONS = "manage_subscriptions"
    VIEW_PAYMENTS = "view_payments"
    MANAGE_PAYMENTS = "manage_payments"

    # Supervisor and hostel management
    MANAGE_SUPERVISORS = "manage_supervisors"
    MANAGE_HOSTEL_CONFIG = "manage_hostel_config"

    # Day-to-day operations
    MANAGE_ATTENDANCE = "manage_attendance"
    MANAGE_COMPLAINTS = "manage_complaints"
    CREATE_COMPLAINT = "create_complaint"
    MANAGE_MAINTENANCE = "manage_maintenance"
    MANAGE_ANNOUNCEMENTS = "manage_announcements"

    # Multi-hostel & UI
    MULTI_HOSTEL_DASHBOARD = "multi_hostel_dashboard"
    SWITCH_HOSTEL = "switch_hostel"
    HOSTEL_SELECTOR = "hostel_selector"

    # Supervisor management & delegation
    ASSIGN_SUPERVISOR = "assign_supervisor"
    CONFIGURE_SUPERVISOR_PERMISSIONS = "configure_supervisor_permissions"
    OVERRIDE_SUPERVISOR = "override_supervisor"

    # Supervisor operational permissions
    SUPERVISOR_DASHBOARD_VIEW = "supervisor_dashboard_view"
    SUPERVISOR_RECORD_ATTENDANCE = "supervisor_record_attendance"
    SUPERVISOR_APPROVE_LEAVE = "supervisor_approve_leave"
    SUPERVISOR_CREATE_MAINTENANCE = "supervisor_create_maintenance"
    SUPERVISOR_ASSIGN_MAINTENANCE = "supervisor_assign_maintenance"
    SUPERVISOR_APPROVE_MAINTENANCE_WITHIN_LIMIT = "supervisor_approve_maintenance_within_limit"
    SUPERVISOR_ESCALATE_ISSUE = "supervisor_escalate_issue"
    SUPERVISOR_MODIFY_MENU = "supervisor_modify_menu"
    SUPERVISOR_CREATE_ANNOUNCEMENT = "supervisor_create_announcement"
    SUPERVISOR_VIEW_FINANCIALS_READONLY = "supervisor_view_financials_readonly"
    SUPERVISOR_UPDATE_STUDENT_CONTACT = "supervisor_update_student_contact"
    SUPERVISOR_VIEW_AUDIT = "supervisor_view_audit"

    # Hostel profile & room/booking management
    MANAGE_HOSTEL_LISTINGS = "manage_hostel_listings"
    MANAGE_ROOM_TYPES = "manage_room_types"
    MANAGE_BOOKINGS = "manage_bookings"
    DELETE_BOOKING = "delete_booking"
    MANAGE_WAITLIST = "manage_waitlist"
    MANAGE_STUDENTS = "manage_students"

    # Booking / registration
    INITIATE_BOOKING = "initiate_booking"
    CREATE_REGISTRATION = "create_registration"

    # Visitor / Booking actions
    BROWSE_PUBLIC_HOSTELS = "browse_public_hostels"
    VIEW_HOSTEL_DETAILS = "view_hostel_details"
    SUBMIT_PUBLIC_INQUIRY = "submit_public_inquiry"
    CREATE_BOOKING = "create_booking"
    VIEW_BOOKING = "view_booking"
    MODIFY_BOOKING = "modify_booking"
    CANCEL_BOOKING = "cancel_booking"
    DOWNLOAD_BOOKING_RECEIPT = "download_booking_receipt"
    SAVE_FAVOURITE_HOSTEL = "save_favourite_hostel"
    MANAGE_WISHLIST = "manage_wishlist"
    RATE_HOSTEL = "rate_hostel"
    WRITE_REVIEW = "write_review"
    VOTE_REVIEW = "vote_review"
    REQUEST_CALLBACK = "request_callback"
    NEGOTIATE_PRICE = "negotiate_price"

    # Broad reporting/export
    EXPORT_REPORTS = "export_reports"
    # Reporting & analytics
    VIEW_FINANCIAL_REPORTS = "view_financial_reports"
    VIEW_OPERATIONAL_REPORTS = "view_operational_reports"
    VIEW_MARKETING_REPORTS = "view_marketing_reports"
    VIEW_SUPERVISOR_PERFORMANCE = "view_supervisor_performance"
    VIEW_CONSOLIDATED_REPORTS = "view_consolidated_reports"

    # Profile / announcements
    VIEW_OWN_PROFILE = "view_own_profile"
    VIEW_HOSTEL_ANNOUNCEMENTS = "view_hostel_announcements"
    
    # Permissions management
    MANAGE_PERMISSIONS = "manage_permissions"
    ASSIGN_ROLE = "assign_role"


# Role-Permission Matrix
PERMISSION_MATRIX: Dict[str, Set[str]] = {
    Role.SUPERADMIN: {
        Permission.CREATE_USER,
        Permission.READ_USER,
        Permission.UPDATE_USER,
        Permission.DELETE_USER,
        Permission.CREATE_HOSTEL,
        Permission.READ_HOSTEL,
        Permission.UPDATE_HOSTEL,
        Permission.DELETE_HOSTEL,
        Permission.SWITCH_SESSION,
        Permission.VIEW_SESSION,
        Permission.VIEW_AUDIT,
        Permission.CREATE_AUDIT,
        Permission.EXPORT_AUDIT,
        Permission.EXPORT_REPORTS,
        Permission.MANAGE_PERMISSIONS,
        Permission.ASSIGN_ROLE,
        Permission.CREATE_REGISTRATION,
        Permission.MANAGE_SUBSCRIPTIONS,
        Permission.VIEW_PAYMENTS,
        Permission.MANAGE_PAYMENTS,
        Permission.MANAGE_HOSTEL_CONFIG,
        Permission.MANAGE_SUPERVISORS,
        Permission.VIEW_FINANCIAL_REPORTS,
        Permission.VIEW_OPERATIONAL_REPORTS,
        Permission.VIEW_MARKETING_REPORTS,
        Permission.VIEW_SUPERVISOR_PERFORMANCE,
        Permission.VIEW_CONSOLIDATED_REPORTS,
        Permission.MULTI_HOSTEL_DASHBOARD,
        Permission.SWITCH_HOSTEL,
        Permission.HOSTEL_SELECTOR,
        Permission.ASSIGN_SUPERVISOR,
        Permission.CONFIGURE_SUPERVISOR_PERMISSIONS,
        Permission.OVERRIDE_SUPERVISOR,
        Permission.MANAGE_HOSTEL_LISTINGS,
        Permission.MANAGE_ROOM_TYPES,
        Permission.MANAGE_BOOKINGS,
        Permission.DELETE_BOOKING,
        Permission.MANAGE_WAITLIST,
        Permission.MANAGE_STUDENTS,
        Permission.MANAGE_ANNOUNCEMENTS,
        Permission.MANAGE_ATTENDANCE,
        Permission.MANAGE_COMPLAINTS,
        Permission.MANAGE_MAINTENANCE,
    },
    Role.ADMIN: {
        Permission.READ_USER,
        Permission.UPDATE_USER,
        Permission.READ_HOSTEL,
        Permission.SWITCH_SESSION,
        Permission.VIEW_SESSION,
        Permission.VIEW_AUDIT,
        Permission.CREATE_AUDIT,
        Permission.EXPORT_AUDIT,
        Permission.EXPORT_REPORTS,
        Permission.MANAGE_HOSTEL_CONFIG,
        Permission.MANAGE_SUPERVISORS,
        Permission.MANAGE_SUBSCRIPTIONS,
        Permission.CREATE_REGISTRATION,
        Permission.VIEW_PAYMENTS,
        Permission.VIEW_FINANCIAL_REPORTS,
        Permission.VIEW_OPERATIONAL_REPORTS,
        Permission.VIEW_MARKETING_REPORTS,
        Permission.VIEW_SUPERVISOR_PERFORMANCE,
        Permission.VIEW_CONSOLIDATED_REPORTS,
        Permission.MANAGE_PAYMENTS,
        Permission.MANAGE_ANNOUNCEMENTS,
        Permission.MULTI_HOSTEL_DASHBOARD,
        Permission.SWITCH_HOSTEL,
        Permission.HOSTEL_SELECTOR,
        Permission.ASSIGN_SUPERVISOR,
        Permission.CONFIGURE_SUPERVISOR_PERMISSIONS,
        Permission.MANAGE_HOSTEL_LISTINGS,
        Permission.MANAGE_ROOM_TYPES,
        Permission.MANAGE_BOOKINGS,
        Permission.MANAGE_WAITLIST,
        Permission.MANAGE_STUDENTS,
    },
    Role.SUPERVISOR: {
        Permission.READ_USER,
        Permission.READ_HOSTEL,
        Permission.VIEW_AUDIT,
        Permission.CREATE_AUDIT,
        Permission.MANAGE_ATTENDANCE,
        Permission.MANAGE_COMPLAINTS,
        Permission.MANAGE_MAINTENANCE,
        Permission.MANAGE_ANNOUNCEMENTS,
        # Supervisor operational rights (scoped to assigned hostel)
        Permission.SUPERVISOR_DASHBOARD_VIEW,
        Permission.SUPERVISOR_RECORD_ATTENDANCE,
        Permission.SUPERVISOR_APPROVE_LEAVE,
        Permission.SUPERVISOR_CREATE_MAINTENANCE,
        Permission.SUPERVISOR_ASSIGN_MAINTENANCE,
        Permission.SUPERVISOR_APPROVE_MAINTENANCE_WITHIN_LIMIT,
        Permission.SUPERVISOR_ESCALATE_ISSUE,
        Permission.SUPERVISOR_MODIFY_MENU,
        Permission.SUPERVISOR_CREATE_ANNOUNCEMENT,
        Permission.SUPERVISOR_VIEW_FINANCIALS_READONLY,
        Permission.SUPERVISOR_UPDATE_STUDENT_CONTACT,
        Permission.SUPERVISOR_VIEW_AUDIT,
        Permission.VIEW_SUPERVISOR_PERFORMANCE,
    },
    Role.STUDENT: {
        Permission.READ_USER,
        Permission.READ_HOSTEL,
        Permission.VIEW_OWN_PROFILE,
        Permission.CREATE_COMPLAINT,
        Permission.VIEW_PAYMENTS,
        Permission.VIEW_HOSTEL_ANNOUNCEMENTS,
        Permission.INITIATE_BOOKING,
        Permission.SAVE_FAVOURITE_HOSTEL,
        Permission.MANAGE_WISHLIST,
        Permission.RATE_HOSTEL,
        Permission.WRITE_REVIEW,
    },
    Role.VISITOR: {
        Permission.READ_USER,
        Permission.READ_HOSTEL,
        Permission.CREATE_REGISTRATION,
        Permission.INITIATE_BOOKING,
        Permission.BROWSE_PUBLIC_HOSTELS,
        Permission.VIEW_HOSTEL_DETAILS,
        Permission.SUBMIT_PUBLIC_INQUIRY,
        Permission.CREATE_BOOKING,
        Permission.VIEW_BOOKING,
        Permission.MODIFY_BOOKING,
        Permission.CANCEL_BOOKING,
        Permission.DOWNLOAD_BOOKING_RECEIPT,
        Permission.SAVE_FAVOURITE_HOSTEL,
        Permission.MANAGE_WISHLIST,
        Permission.RATE_HOSTEL,
        Permission.WRITE_REVIEW,
        Permission.VOTE_REVIEW,
        Permission.REQUEST_CALLBACK,
        Permission.NEGOTIATE_PRICE,
    },
}


def has_permission(role: str, permission: str) -> bool:
    """Check if a role has a specific permission"""
    return permission in PERMISSION_MATRIX.get(role, set())


def get_role_permissions(role: str) -> Set[str]:
    """Get all permissions for a role"""
    return PERMISSION_MATRIX.get(role, set())



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\razorpay_client.py ---
import razorpay
from app.config import settings


print("🔍 Loaded Razorpay Key ID:", settings.RAZORPAY_KEY_ID)
print("🔍 Loaded Razorpay Secret:", settings.RAZORPAY_KEY_SECRET)

# Initialize Razorpay client using Pydantic Settings
razorpay_client = razorpay.Client(auth=(
    settings.RAZORPAY_KEY_ID,
    settings.RAZORPAY_KEY_SECRET
))


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\roles.py ---
"""
Role constants & hierarchy
"""
from enum import Enum
from typing import Dict, List


class Role(str, Enum):
    """Role enumeration"""
    SUPERADMIN = "superadmin"
    ADMIN = "admin"
    SUPERVISOR = "supervisor"
    STUDENT = "student"
    VISITOR = "visitor"


# Role hierarchy (higher number = more privileges)
RoleHierarchy: Dict[str, int] = {
    Role.SUPERADMIN: 5,
    Role.ADMIN: 4,
    Role.SUPERVISOR: 3,
    Role.STUDENT: 2,
    Role.VISITOR: 1,
}


def get_role_level(role: str) -> int:
    """Get hierarchy level of a role"""
    return RoleHierarchy.get(role, 0)


def can_manage_role(manager_role: str, target_role: str) -> bool:
    """Check if manager_role can manage target_role"""
    manager_level = get_role_level(manager_role)
    target_level = get_role_level(target_role)
    return manager_level > target_level


def get_all_roles() -> List[str]:
    """Get all available roles"""
    return [role.value for role in Role]



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\security.py ---
"""
Security utilities:
- Safe bcrypt wrapper (handles >72 byte passwords)
- Hash / verify
- JWT access + refresh tokens
- Get current user
"""

import hashlib
import bcrypt
from datetime import datetime, timedelta, timezone
from typing import Optional

from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer

from sqlalchemy.orm import Session
from app.config import settings
from app.models.user import User
from app.core.database import get_db


# ======================
#  BCRYPT SAFE CONTEXT
# ======================

class BcryptContext:
    """
    Custom bcrypt wrapper that safely handles long passwords.
    Anything >72 bytes is pre-hashed with SHA256 and tagged as `sha256$<digest>`.
    """

    def __init__(self):
        self._bcrypt = bcrypt

    def _prepare(self, raw: str) -> bytes:
        raw_bytes = raw.encode("utf-8")
        if len(raw_bytes) > 72:
            digest = hashlib.sha256(raw_bytes).hexdigest()
            return f"sha256${digest}".encode("utf-8")
        return raw_bytes

    def hash(self, password: str) -> str:
        prepared = self._prepare(password)
        hashed = self._bcrypt.hashpw(prepared, self._bcrypt.gensalt())
        return hashed.decode("utf-8")

    def verify(self, plain: str, hashed: str) -> bool:
        try:
            prepared = self._prepare(plain)
            return self._bcrypt.checkpw(prepared, hashed.encode("utf-8"))
        except Exception:
            return False


pwd_context = BcryptContext()


# ======================
#  PASSWORD API
# ======================

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


# ======================
#  JWT TOKENS
# ======================

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="/api/v1/auth/login",
    scheme_name="HTTPBearer",
    auto_error=False
)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()

    expire = datetime.now(timezone.utc) + (
        expires_delta if expires_delta else timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    )

    to_encode.update({"exp": expire, "type": "access"})

    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)


def create_refresh_token(data: dict) -> str:
    to_encode = data.copy()

    expire = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})

    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)


def decode_token(token: str) -> dict:
    try:
        return jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token"
        )


# ======================
#  CURRENT USER
# ======================

async def get_current_user(
    request: Request,
    token: Optional[str] = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:

    # Fallback: read from cookie
    if not token:
        cookie_token = request.cookies.get("access_token")
        if cookie_token:
            token = cookie_token

    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing token. Provide Authorization header or access_token cookie.",
            headers={"WWW-Authenticate": "Bearer"},
        )

    try:
        payload = decode_token(token)
        raw_sub = payload.get("sub")

        if raw_sub is None:
            raise HTTPException(status_code=401, detail="Invalid token")

        user_id = int(raw_sub)

    except Exception:
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user = db.query(User).filter(User.id == user_id).first()

    if not user:
        raise HTTPException(status_code=401, detail="User not found")

    return user


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\tenent_middleware.py ---
"""
🏠 Multi-hostel filtering middleware
"""
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from app.core.roles import Role


class TenantMiddleware(BaseHTTPMiddleware):
    """Filter data by hostel_id for multi-tenant support"""
    
    async def dispatch(self, request: Request, call_next):
        # Superadmin can access all hostels
        if hasattr(request.state, "user_role") and request.state.user_role == Role.SUPERADMIN:
            return await call_next(request)
        
        # Extract hostel_id from request state or query params
        if hasattr(request.state, "hostel_id") and request.state.hostel_id:
            request.state.active_hostel_id = request.state.hostel_id
        else:
            # Try to get from query params for session switching
            hostel_id = request.query_params.get("hostel_id")
            if hostel_id:
                request.state.active_hostel_id = int(hostel_id)
        
        return await call_next(request)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\utils.py ---
"""
Helper utilities (decode JWT, etc.)
"""
from typing import Optional, Dict
from app.core.security import decode_token


def extract_user_info_from_token(token: str) -> Optional[Dict]:
    """Extract user information from JWT token"""
    try:
        payload = decode_token(token)
        return {
            "user_id": payload.get("sub"),
            "role": payload.get("role"),
            "hostel_id": payload.get("hostel_id"),
            "email": payload.get("email"),
        }
    except Exception:
        return None


def get_hostel_id_from_request(request) -> Optional[int]:
    """Extract hostel_id from request state"""
    return getattr(request.state, "active_hostel_id", None) or getattr(request.state, "hostel_id", None)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\core\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations\aws_s3.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations\firebase.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations\google_maps.py ---
import httpx
from app.config import settings

class GoogleMapsService:
    """Google Maps API integration for geocoding and directions"""
    
    @staticmethod
    async def geocode_address(address: str) -> dict:
        """Convert address to latitude/longitude"""
        if not settings.GOOGLE_MAPS_API_KEY:
            return None
        
        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(
                    "https://maps.googleapis.com/maps/api/geocode/json",
                    params={
                        "address": address,
                        "key": settings.GOOGLE_MAPS_API_KEY
                    }
                )
                data = response.json()
                
                if data.get("status") == "OK" and data.get("results"):
                    location = data["results"][0]["geometry"]["location"]
                    return {
                        "latitude": location["lat"],
                        "longitude": location["lng"],
                        "formatted_address": data["results"][0]["formatted_address"]
                    }
            except Exception as e:
                print(f"Geocoding error: {e}")
        
        return None
    
    @staticmethod
    async def get_distance(origin_lat: float, origin_lng: float, 
                          dest_lat: float, dest_lng: float) -> dict:
        """Calculate distance and duration between two points"""
        if not settings.GOOGLE_MAPS_API_KEY:
            return None
        
        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(
                    "https://maps.googleapis.com/maps/api/distancematrix/json",
                    params={
                        "origins": f"{origin_lat},{origin_lng}",
                        "destinations": f"{dest_lat},{dest_lng}",
                        "key": settings.GOOGLE_MAPS_API_KEY
                    }
                )
                data = response.json()
                
                if data.get("status") == "OK" and data.get("rows"):
                    element = data["rows"][0]["elements"][0]
                    if element.get("status") == "OK":
                        return {
                            "distance_meters": element["distance"]["value"],
                            "distance_text": element["distance"]["text"],
                            "duration_seconds": element["duration"]["value"],
                            "duration_text": element["duration"]["text"]
                        }
            except Exception as e:
                print(f"Distance calculation error: {e}")
        
        return None

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations\razorpay.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations\sendgrid.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations\stripe.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations\twilio.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\integrations\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\middleware =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\middleware\audit_trail.py ---
"""
Logs requests to audit table
"""
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from app.core.roles import Role
from app.repositories.audit_repository import AuditRepository
from app.core.database import get_db


class AuditTrailMiddleware(BaseHTTPMiddleware):
    """Log admin/supervisor actions to audit table"""
    
    async def dispatch(self, request: Request, call_next):
        # Only audit authenticated requests
        if not hasattr(request.state, "user_id"):
            return await call_next(request)
        
        # Only audit admin/supervisor/superadmin actions
        user_role = getattr(request.state, "user_role", None)
        if user_role not in [Role.ADMIN, Role.SUPERVISOR, Role.SUPERADMIN]:
            return await call_next(request)
        
        # Skip audit for GET requests (optional - can be enabled)
        if request.method == "GET":
            return await call_next(request)
        
        # Log the request
        try:
            db = next(get_db())
            audit_repo = AuditRepository(db)
            audit_repo.create_audit_log(
                user_id=getattr(request.state, "user_id", None),
                action=request.method,
                resource=str(request.url.path),
                hostel_id=getattr(request.state, "active_hostel_id", None),
                ip_address=request.client.host if request.client else None,
                user_agent=request.headers.get("user-agent"),
            )
        except Exception as e:
            # Log the exception for debugging
            print(f"Audit logging failed: {e}")
            # Don't fail request if audit logging fails
            pass
        
        response = await call_next(request)
        return response



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\middleware\authentication.py ---
"""
JWT authentication middleware
"""
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from app.core.security import decode_token


class AuthenticationMiddleware(BaseHTTPMiddleware):
    """Verify JWT token in request headers"""
    
    # Public endpoints that don't require authentication
    PUBLIC_PATHS = [
    "/",
    "/health",
    "/docs",
    "/redoc",
    "/openapi.json",
    "/api/v1/auth/login",
    "/api/v1/auth/refresh",
    "/api/v1/auth/forgot-password",
    "/api/v1/auth/verify-reset-code",
    "/api/v1/auth/reset-password",
    # Social login endpoints removed per admin request
    "/api/v1/auth/password-strength",
    ]
    
    def is_public_path(self, path: str) -> bool:
        """Check if path is public (doesn't require auth)"""
        # Exact match
        if path in self.PUBLIC_PATHS:
            return True
        # Check if path starts with any public path
        for public_path in self.PUBLIC_PATHS:
            if path.startswith(public_path):
                return True
        return False
    
    async def dispatch(self, request: Request, call_next):
        # Skip auth for public endpoints
        if self.is_public_path(request.url.path):
            return await call_next(request)
        
        # Extract token
        authorization = request.headers.get("Authorization")
        if not authorization or not authorization.startswith("Bearer "):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Missing authorization header",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        token = authorization.split(" ")[1]
        try:
            payload = decode_token(token)
            request.state.user_id = payload.get("sub")
            request.state.user_role = payload.get("role")
            request.state.hostel_id = payload.get("hostel_id")
            request.state.email = payload.get("email")
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        return await call_next(request)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\middleware\role_enforcer.py ---
"""
Role enforcement (RBAC)
"""
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from app.core.roles import Role
from app.core.exceptions import AccessDeniedException


class RoleEnforcerMiddleware(BaseHTTPMiddleware):
    """Enforce role-based access control"""
    
    async def dispatch(self, request: Request, call_next):
        # Skip for public endpoints
        if not hasattr(request.state, "user_role"):
            return await call_next(request)
        
        user_role = request.state.user_role
        
        # Check admin endpoints
        if request.url.path.startswith("/api/v1/admin"):
            if user_role not in [Role.ADMIN, Role.SUPERADMIN]:
                raise AccessDeniedException("Admin access required")
        
        # Check supervisor endpoints
        if request.url.path.startswith("/api/v1/supervisor"):
            if user_role != Role.SUPERVISOR:
                raise AccessDeniedException("Supervisor access required")
        
        return await call_next(request)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\middleware\tenant_filter.py ---
"""
Filters data by hostel_id
"""
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from app.core.roles import Role
from app.core.database import SessionLocal
from app.repositories.session_repository import SessionRepository


class TenantFilterMiddleware(BaseHTTPMiddleware):
    """Filter queries by hostel_id for multi-tenant support"""
    
    async def dispatch(self, request: Request, call_next):
        # Superadmin can access all hostels
        if hasattr(request.state, "user_role") and request.state.user_role == Role.SUPERADMIN:
            request.state.bypass_tenant_filter = True
            return await call_next(request)
        
        # For admins, get active session hostel_id
        active_hostel_id = None
        if hasattr(request.state, "user_id") and hasattr(request.state, "user_role"):
            user_id = request.state.user_id
            user_role = request.state.user_role
            
            # For admins, check active session
            if user_role in [Role.ADMIN, Role.SUPERADMIN]:
                try:
                    db = SessionLocal()
                    session_repo = SessionRepository(db)
                    active_session = session_repo.get_active_session(user_id)
                    if active_session:
                        active_hostel_id = active_session.hostel_id
                    db.close()
                except Exception:
                    pass
        
        # Fallback to token hostel_id
        if not active_hostel_id and hasattr(request.state, "hostel_id") and request.state.hostel_id:
            active_hostel_id = request.state.hostel_id
        
        # Allow query param override for session switching
        hostel_id_param = request.query_params.get("hostel_id")
        if hostel_id_param:
            try:
                active_hostel_id = int(hostel_id_param)
            except ValueError:
                pass
        
        # Set active hostel_id in request state
        if active_hostel_id:
            request.state.active_hostel_id = active_hostel_id
        
        return await call_next(request)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\middleware\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\middleware\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\admin.py ---
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Enum, ForeignKey, UniqueConstraint
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.core.database import Base
from app.models.hostel import Hostel
import enum

class PermissionLevel(str, enum.Enum):
    read = "read"
    write = "write"
    admin = "admin"

class Admin(Base):
    __tablename__ = "admins"

    id = Column(Integer, primary_key=True, index=True)
    admin_name = Column(String, nullable=False)
    email = Column(String, unique=True)
    is_active = Column(Boolean, default=True)
    joined_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    hostel_assignments = relationship("AdminHostelAssignment", back_populates="admin")

class AdminHostelAssignment(Base):
    __tablename__ = "admin_hostel_assignments"

    id = Column(Integer, primary_key=True, index=True)
    admin_id = Column(Integer, ForeignKey("admins.id", ondelete="CASCADE"), nullable=False)
    hostel_id = Column(Integer, ForeignKey("hostels.id", ondelete="CASCADE"), nullable=False)
    permission_level = Column(Enum(PermissionLevel, name='permission_level'), nullable=False, default=PermissionLevel.read)
    assigned_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    admin = relationship("Admin", back_populates="hostel_assignments")
    hostel = relationship("Hostel", back_populates="admin_assignments")
    
    # Unique constraint to prevent duplicate assignments
    __table_args__ = (
        UniqueConstraint('admin_id', 'hostel_id', name='uq_admin_hostel_assignment'),
    )

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\admin_hostel_mapping.py ---
"""
Multi-hostel admin mapping
"""
from sqlalchemy import Column, Integer, ForeignKey, DateTime, UniqueConstraint
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.core.database import Base


class AdminHostelMapping(Base):
    __tablename__ = "admin_hostel_mappings"
    
    id = Column(Integer, primary_key=True, index=True)
    admin_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    admin = relationship("User", back_populates="admin_hostel_mappings")
    hostel = relationship("Hostel", back_populates="admin_hostel_mappings")
    
    # Unique constraint: one admin can only be mapped to a hostel once
    __table_args__ = (UniqueConstraint('admin_id', 'hostel_id', name='unique_admin_hostel'),)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\announcement.py ---
# app/models/announcement.py

from sqlalchemy import Column, Integer, String, Boolean, DateTime, JSON
from sqlalchemy.sql import func
from enum import Enum
from app.core.database import Base


class AnnouncementCategory(str, Enum):
    GENERAL = "general"
    URGENT = "urgent"
    EVENTS = "events"
    RULES = "rules"


class AnnouncementStatus(str, Enum):
    DRAFT = "draft"
    SCHEDULED = "scheduled"
    PUBLISHED = "published"
    ARCHIVED = "archived"


class Announcement(Base):
    __tablename__ = "announcement"

    id = Column(Integer, primary_key=True, index=True)
    announcement_title = Column(String, nullable=False)
    announcement_content = Column(String, nullable=False)
    announcement_category = Column(String, default=AnnouncementCategory.GENERAL.value)
    target_audience = Column(String, default="all")
    scheduled_date = Column(DateTime, nullable=True)
    is_emergency = Column(Boolean, default=False)
    status = Column(String, default=AnnouncementStatus.DRAFT.value)
    attachments = Column(JSON, default=list)
    created_by_id = Column(Integer, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    approved = Column(Boolean, default=False)
    approved_by = Column(Integer, nullable=True)
    approved_at = Column(DateTime, nullable=True)
    read_by = Column(JSON, default=list)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\approval_request.py ---
"""
Approval request model for supervisor actions requiring approval
"""
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean, Text, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum

from app.core.database import Base


class ApprovalStatus(str, enum.Enum):
    """Approval status enumeration"""
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    CANCELLED = "cancelled"


class ApprovalRequest(Base):
    __tablename__ = "approval_requests"
    
    id = Column(Integer, primary_key=True, index=True)
    requester_id = Column(Integer, ForeignKey("users.id"), nullable=False)  # Supervisor requesting
    approver_id = Column(Integer, ForeignKey("users.id"), nullable=True)  # Admin/SuperAdmin approving
    action = Column(String, nullable=False)  # e.g., "update_user", "delete_user"
    resource_type = Column(String, nullable=False)  # e.g., "user", "hostel"
    resource_id = Column(Integer, nullable=True)  # ID of the resource being acted upon
    hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=True)
    status = Column(String, default=ApprovalStatus.PENDING.value, nullable=False)
    request_details = Column(Text, nullable=True)  # JSON string with request details
    approval_notes = Column(Text, nullable=True)  # Notes from approver
    threshold_level = Column(Integer, nullable=False, default=1)  # Approval threshold level required
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    approved_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    requester = relationship("User", foreign_keys=[requester_id], backref="approval_requests_made")
    approver = relationship("User", foreign_keys=[approver_id], backref="approval_requests_approved")
    hostel = relationship("Hostel", back_populates="approval_requests")



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\approval_workflow.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\attendance.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\audit_log.py ---
"""
🧾 Audit logs for supervisor/admin actions
"""
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Text
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.core.database import Base


class AuditLog(Base):
    __tablename__ = "audit_logs"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=True)
    action = Column(String, nullable=False)  # e.g., "GET", "POST", "PUT", "DELETE"
    resource = Column(String, nullable=False)  # e.g., "/api/v1/users"
    ip_address = Column(String, nullable=True)
    user_agent = Column(String, nullable=True)
    details = Column(Text, nullable=True)  # JSON string for additional details
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    user = relationship("User", back_populates="audit_logs")
    hostel = relationship("Hostel", back_populates="audit_logs")



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\base.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\beds.py ---
from enum import Enum
from sqlalchemy import Column, String, Integer, Float, DateTime, Time, func
from sqlalchemy import Enum as SAEnum
from sqlalchemy.schema import Identity

from app.config import Base


class BedStatus(str, Enum):
    AVAILABLE = "available"
    OCCUPIED = "occupied"
    RESERVED = "reserved"
    OUT_OF_SERVICE = "out_of_service"


class Bed(Base):
    __tablename__ = "beds"

    id = Column(Integer, Identity(start=1), primary_key=True)
    hostel_id = Column(String(100), nullable=True)
    bed_number = Column(String(50), nullable=False)
    room_number = Column(String(50), nullable=False)
    bed_status = Column(SAEnum(BedStatus, name="bed_status_enum"), nullable=False, default=BedStatus.AVAILABLE)

    monthly_price = Column(Float, nullable=True)
    quarterly_price = Column(Float, nullable=True)
    annual_price = Column(Float, nullable=True)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\booking.py ---
from sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime, Enum, Float
from sqlalchemy.orm import relationship
from datetime import datetime
from app.core.database import Base
import enum


# BookingStatus used by the booking system (repository/services)
class BookingStatus(enum.Enum):
    pending = "pending"
    confirmed = "confirmed"
    cancelled = "cancelled"
    rejected = "rejected"


# A separate enum for the visitor-facing BookingRequest (keeps older naming)
class BookingRequestStatus(enum.Enum):
    Pending = "Pending"
    Approved = "Approved"
    Rejected = "Rejected"
    Completed = "Completed"


class Booking(Base):
    __tablename__ = "bookings"

    id = Column(Integer, primary_key=True, index=True)
    visitor_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=False)
    room_id = Column(Integer, ForeignKey("rooms.id"), nullable=False)

    check_in = Column(DateTime, nullable=False)
    check_out = Column(DateTime, nullable=False)

    amount_paid = Column(Float, nullable=False, default=0.0)
    status = Column(String, nullable=False, default=BookingStatus.pending.value)  # use simple string for compatibility
    created_at = Column(DateTime, default=datetime.utcnow)

    # relationship to room (used by services)
    room = relationship("Room")


class BookingRequest(Base):
    __tablename__ = "booking_requests"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    full_name = Column(String(100), nullable=False)
    phone_number = Column(String(20), nullable=False)
    email = Column(String(100), nullable=False)
    id_type = Column(String(50), nullable=False)
    id_number = Column(String(50), nullable=False)
    id_document = Column(String(255), nullable=True)
    emergency_contact_name = Column(String(100), nullable=False)
    emergency_contact_number = Column(String(20), nullable=False)
    emergency_contact_relation = Column(String(50), nullable=True)
    special_requirements = Column(Text, nullable=True)
    status = Column(Enum(BookingRequestStatus), default=BookingRequestStatus.Pending)
    created_at = Column(DateTime, default=datetime.utcnow)

    user = relationship("app.models.user.User", back_populates="bookings")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\complaint.py ---
from sqlalchemy import Column, Integer, String, DateTime, Text, Enum, Float, Boolean
from datetime import datetime
import enum
from app.core.database import Base


# ---------------------------------------------------------------------
# ENUM DEFINITIONS
# ---------------------------------------------------------------------
class ComplaintCategory(str, enum.Enum):
    ROOM_MAINTENANCE = "room_maintenance"
    MESS_QUALITY = "mess_quality"
    CLEANLINESS = "cleanliness"
    SECURITY = "security"
    WIFI = "wifi"  # ✅ Added WiFi as a complaint category
    OTHER = "other"


class ComplaintPriority(str, enum.Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"


class ComplaintStatus(str, enum.Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    ESCALATED = "escalated"
    RESOLVED = "resolved"
    CLOSED = "closed"
    REOPENED = "reopened"


# ---------------------------------------------------------------------
# MAIN COMPLAINT MODEL
# ---------------------------------------------------------------------
class Complaint(Base):
    __tablename__ = "complaints"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=False)
    category = Column(Enum(ComplaintCategory), nullable=False)
    priority = Column(Enum(ComplaintPriority), default=ComplaintPriority.MEDIUM)
    status = Column(Enum(ComplaintStatus), default=ComplaintStatus.PENDING)

    # Student Info
    student_name = Column(String(255), nullable=False)
    student_email = Column(String(255), nullable=False)
    hostel_name = Column(String(255), nullable=False)
    room_number = Column(String(50), nullable=True)

    # Assignment Info
    assigned_to_name = Column(String(255), nullable=True)
    assigned_to_email = Column(String(255), nullable=True)

    # Cost and escalation info
    estimated_cost = Column(Float, nullable=True)
    actual_cost = Column(Float, nullable=True)
    is_escalated = Column(Boolean, default=False)
    escalation_reason = Column(Text, nullable=True)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    assigned_at = Column(DateTime, nullable=True)
    in_progress_at = Column(DateTime, nullable=True)
    resolved_at = Column(DateTime, nullable=True)
    closed_at = Column(DateTime, nullable=True)
    sla_deadline = Column(DateTime, nullable=True)

    # Resolution and feedback
    resolution_notes = Column(Text, nullable=True)
    resources_used = Column(Text, nullable=True)
    student_feedback = Column(Text, nullable=True)
    student_rating = Column(Integer, nullable=True)
    is_reopened = Column(Boolean, default=False)
    reopen_reason = Column(Text, nullable=True)

    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


# ---------------------------------------------------------------------
# ATTACHMENTS MODEL
# ---------------------------------------------------------------------
class ComplaintAttachment(Base):
    __tablename__ = "complaint_attachments"

    id = Column(Integer, primary_key=True, index=True)
    complaint_id = Column(Integer, nullable=False, index=True)
    file_path = Column(String(500), nullable=False)
    file_name = Column(String(255), nullable=False)
    file_type = Column(String(50), nullable=False)
    file_size = Column(Integer, nullable=False)
    uploaded_by = Column(String(255), nullable=False)  # email of uploader
    created_at = Column(DateTime, default=datetime.utcnow)


# ---------------------------------------------------------------------
# NOTES MODEL
# ---------------------------------------------------------------------
class ComplaintNote(Base):
    __tablename__ = "complaint_notes"

    id = Column(Integer, primary_key=True, index=True)
    complaint_id = Column(Integer, nullable=False, index=True)
    user_email = Column(String(255), nullable=False)
    user_name = Column(String(255), nullable=False)
    note = Column(Text, nullable=False)
    is_internal = Column(Boolean, default=True)  # Internal or public notes
    created_at = Column(DateTime, default=datetime.utcnow)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\fee_structure_models.py ---
from sqlalchemy import Column, Integer, String, Float, Boolean, ForeignKey, Enum, Text
from sqlalchemy.orm import relationship
from app.core.database import Base
import enum

class FeeFrequency(str, enum.Enum):
    monthly = "monthly"
    quarterly = "quarterly"
    annual = "annual"

# class Hostel(Base):
#     __tablename__ = "hostels"

#     id = Column(Integer, primary_key=True, index=True)
#     name = Column(String(100), nullable=False)
#     address = Column(Text, nullable=True)
#     capacity = Column(Integer, default=0)

#     fee_plans = relationship("FeePlan", back_populates="hostel", cascade="all, delete")
#     deposits = relationship("SecurityDeposit", back_populates="hostel", cascade="all, delete")
#     mess_charges = relationship("MessCharge", back_populates="hostel", cascade="all, delete")
#     services = relationship("AdditionalService", back_populates="hostel", cascade="all, delete")

#     # ✅ Add this line
#     payments = relationship("Payment", back_populates="hostel", cascade="all, delete")
#     invoices = relationship("Invoice", back_populates="hostel")
#     reminder_config = relationship(
#         "ReminderConfiguration",
#         back_populates="hostel",
#         uselist=False,
#         cascade="all, delete-orphan"
#     )



class FeePlan(Base):
    __tablename__ = "fee_plans"
    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, ForeignKey("hostels.id"))
    plan_name = Column(String(100), nullable=False)
    frequency = Column(Enum(FeeFrequency), nullable=False)
    amount = Column(Float, nullable=False)
    room_type = Column(String(50))
    description = Column(Text, nullable=True)

    hostel = relationship("Hostel", back_populates="fee_plans")

class SecurityDeposit(Base):
    __tablename__ = "security_deposits"
    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, ForeignKey("hostels.id"))
    name = Column(String(100))
    amount = Column(Float, nullable=False)
    refundable = Column(Boolean, default=True)
    hostel = relationship("Hostel", back_populates="deposits")

class MessCharge(Base):
    __tablename__ = "mess_charges"
    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, ForeignKey("hostels.id"))
    meal_type = Column(String(50))
    frequency = Column(Enum(FeeFrequency))
    amount = Column(Float, nullable=False)
    is_mandatory = Column(Boolean, default=True)
    hostel = relationship("Hostel", back_populates="mess_charges")

class AdditionalService(Base):
    __tablename__ = "additional_services"
    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, ForeignKey("hostels.id"))
    service_name = Column(String(100))
    amount = Column(Float, nullable=False)
    frequency = Column(Enum(FeeFrequency))
    description = Column(Text, nullable=True)
    hostel = relationship("Hostel", back_populates="services")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\hostel.py ---
from sqlalchemy import (
    Column, Integer, String, Text, Boolean, Numeric, Time,
    TIMESTAMP, ForeignKey, Date
)
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.core.database import Base


# =========================================================
# LOCATION MODEL
# =========================================================
class Location(Base):
    __tablename__ = "locations"

    id = Column(Integer, primary_key=True, index=True)
    city = Column(String(100), nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now(), nullable=False)

    hostels = relationship("Hostel", back_populates="location")


# =========================================================
# HOSTEL MODEL (MERGED VERSION)
# =========================================================
class Hostel(Base):
    __tablename__ = "hostels"

    # ---------------------------------------------------
    # Primary Details
    # ---------------------------------------------------
    id = Column(Integer, primary_key=True, index=True)

    # Unified names
    hostel_name = Column(String(255), nullable=False)      # Main name
    name = Column(String(255), nullable=True)              # Optional alias

    # Address info (merged)
    full_address = Column(Text, nullable=True)
    address = Column(Text, nullable=True)
    city = Column(String(100), nullable=True)
    pincode = Column(String(20), nullable=True)

    # ---------------------------------------------------
    # Metadata / Details
    # ---------------------------------------------------
    description = Column(Text, nullable=True)
    hostel_type = Column(String(100), nullable=True)
    gender_type = Column(String(50), nullable=True)       # Boys / Girls / Co-ed
    amenities = Column(Text, nullable=True)
    rules = Column(Text, nullable=True)

    # Contact
    contact_email = Column(String(255), nullable=True)
    contact_phone = Column(String(20), nullable=True)

    # Check-in/out times
    check_in = Column(Time, nullable=True)
    check_out = Column(Time, nullable=True)

    # ---------------------------------------------------
    # Stats & Capacity
    # ---------------------------------------------------
    total_beds = Column(Integer, nullable=True)
    current_occupancy = Column(Integer, nullable=True)
    monthly_revenue = Column(Numeric(12, 2), nullable=True)

    # Extra merged field
    capacity = Column(Integer, default=0)

    # ---------------------------------------------------
    # Location Link
    # ---------------------------------------------------
    location_id = Column(Integer, ForeignKey("locations.id"), nullable=True)

    # ---------------------------------------------------
    # Visibility
    # ---------------------------------------------------
    visibility = Column(String(10), default="public", nullable=False)
    is_featured = Column(Boolean, default=False, nullable=False)

    # ---------------------------------------------------
    # Timestamp
    # ---------------------------------------------------
    created_at = Column(TIMESTAMP, server_default=func.now(), nullable=False)

    # ---------------------------------------------------
    # Relationships
    # ---------------------------------------------------
    location = relationship("Location", back_populates="hostels")

    # Rooms (from second model + first model → already matching)
    rooms = relationship("Room", back_populates="hostel")

    # Admin mappings
    admin_assignments = relationship(
        "AdminHostelAssignment",
        back_populates="hostel",
        cascade="all, delete-orphan",
    )
    admin_hostel_mappings = relationship("AdminHostelMapping", back_populates="hostel")

    # Financial data
    revenues = relationship("Revenue", back_populates="hostel", cascade="all, delete-orphan")
    occupancies = relationship("Occupancy", back_populates="hostel", cascade="all, delete-orphan")

    users = relationship("User", back_populates="hostel")

    # Extra relationships
    fee_plans = relationship("FeePlan", back_populates="hostel", cascade="all, delete")
    deposits = relationship("SecurityDeposit", back_populates="hostel", cascade="all, delete")
    mess_charges = relationship("MessCharge", back_populates="hostel", cascade="all, delete")
    services = relationship("AdditionalService", back_populates="hostel", cascade="all, delete")

    payments = relationship("Payment", back_populates="hostel", cascade="all, delete")
    invoices = relationship("Invoice", back_populates="hostel")

    reminder_config = relationship(
        "ReminderConfiguration",
        back_populates="hostel",
        uselist=False,
        cascade="all, delete-orphan",
    )

    session_contexts = relationship("SessionContext", back_populates="hostel")
    audit_logs = relationship("AuditLog", back_populates="hostel")
    approval_requests = relationship("ApprovalRequest", back_populates="hostel")


# =========================================================
# REVENUE MODEL
# =========================================================
class Revenue(Base):
    __tablename__ = "revenues"

    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, ForeignKey("hostels.id", ondelete="CASCADE"), nullable=False)
    month = Column(Date, nullable=False)
    revenue = Column(Numeric(12, 2), nullable=False)

    hostel = relationship("Hostel", back_populates="revenues")


# =========================================================
# OCCUPANCY MODEL
# =========================================================
class Occupancy(Base):
    __tablename__ = "occupancies"

    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, ForeignKey("hostels.id", ondelete="CASCADE"), nullable=False)
    month = Column(Date, nullable=False)
    occupancy_rate = Column(Numeric(5, 2), nullable=True)

    hostel = relationship("Hostel", back_populates="occupancies")


# =========================================================
# ACTIVITY LOG MODEL
# =========================================================
class Activity(Base):
    __tablename__ = "activities"

    id = Column(Integer, primary_key=True, index=True)
    entity_name = Column(String(200), nullable=False)
    entity_type = Column(String(100), nullable=False)
    action = Column(String(100), nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now(), nullable=False)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\maintenance.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\mess_menu.py ---
from sqlalchemy import Column, Integer, String, DateTime, Boolean, JSON, Text, ForeignKey, Enum as SQLEnum, Date, Time
from sqlalchemy.orm import relationship
from datetime import datetime
import enum
from app.core.database import Base


class MenuType(str, enum.Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"


class MealType(str, enum.Enum):
    BREAKFAST = "breakfast"
    LUNCH = "lunch"
    SNACKS = "snacks"
    DINNER = "dinner"


class DietType(str, enum.Enum):
    REGULAR = "regular"
    VEGETARIAN = "vegetarian"
    VEGAN = "vegan"
    GLUTEN_FREE = "gluten_free"
    DIABETIC = "diabetic"
    ALLERGEN_FREE = "allergen_free"


class MenuStatus(str, enum.Enum):
    DRAFT = "draft"
    PENDING_APPROVAL = "pending_approval"
    APPROVED = "approved"
    PUBLISHED = "published"
    ARCHIVED = "archived"


class MessMenu(Base):
    __tablename__ = "mess_menus"

    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, nullable=False, index=True)
    menu_type = Column(SQLEnum(MenuType), nullable=False)
    menu_date = Column(Date, nullable=False, index=True)
    meal_type = Column(SQLEnum(MealType), nullable=False)
    
    # Menu Items (JSON format for flexibility)
    items = Column(JSON, nullable=False)  # [{name, description, diet_types}]
    
    # Timing
    serving_time_start = Column(Time, nullable=True)
    serving_time_end = Column(Time, nullable=True)
    
    # Special Diet Support
    diet_types = Column(JSON, nullable=False, default=list)  # List of supported diet types
    
    # Nutritional Information (optional)
    nutritional_info = Column(JSON, nullable=True)  # {calories, protein, carbs, etc}
    
    # Status and Approval
    status = Column(SQLEnum(MenuStatus), default=MenuStatus.DRAFT)
    created_by = Column(Integer, nullable=False)  # User ID
    created_by_role = Column(String(50), nullable=False)  # admin/supervisor
    approved_by = Column(Integer, nullable=True)
    approved_at = Column(DateTime, nullable=True)
    
    # Metadata
    notes = Column(Text, nullable=True)
    is_special_occasion = Column(Boolean, default=False)
    occasion_name = Column(String(200), nullable=True)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    feedbacks = relationship("MenuFeedback", back_populates="menu", cascade="all, delete-orphan")
    preferences = relationship("MealPreference", back_populates="menu", cascade="all, delete-orphan")


class MenuFeedback(Base):
    __tablename__ = "menu_feedbacks"

    id = Column(Integer, primary_key=True, index=True)
    menu_id = Column(Integer, ForeignKey("mess_menus.id", ondelete="CASCADE"), nullable=False)
    student_id = Column(Integer, nullable=False, index=True)
    
    rating = Column(Integer, nullable=False)  # 1-5
    taste_rating = Column(Integer, nullable=True)
    quantity_rating = Column(Integer, nullable=True)
    hygiene_rating = Column(Integer, nullable=True)
    
    comments = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    menu = relationship("MessMenu", back_populates="feedbacks")


class MealPreference(Base):
    __tablename__ = "meal_preferences"

    id = Column(Integer, primary_key=True, index=True)
    student_id = Column(Integer, nullable=False, index=True)
    hostel_id = Column(Integer, nullable=False, index=True)
    menu_id = Column(Integer, ForeignKey("mess_menus.id", ondelete="CASCADE"), nullable=True)
    
    diet_type = Column(SQLEnum(DietType), nullable=False)
    allergies = Column(JSON, nullable=True)  # List of allergens
    medical_requirements = Column(Text, nullable=True)
    
    preferred_items = Column(JSON, nullable=True)  # List of preferred food items
    disliked_items = Column(JSON, nullable=True)   # List of disliked food items
    
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    menu = relationship("MessMenu", back_populates="preferences")

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\notification.py ---
from datetime import datetime
from enum import Enum

from sqlalchemy import (
	Column,
	Integer,
	String,
	Text,
	DateTime,
	ForeignKey,
	Boolean,
)
from sqlalchemy.orm import relationship

from app.config import Base


class Channel(Enum):
	EMAIL = "email"
	SMS = "sms"
	PUSH = "push"


class Notification(Base):
	__tablename__ = "notifications"

	id = Column(Integer, primary_key=True, index=True)
	recipient_id = Column(String(128), index=True, nullable=False)
	recipient_type = Column(String(64), index=True, nullable=False)  # admin/supervisor/student
	channel = Column(String(32), nullable=False)
	subject = Column(String(255), nullable=True)
	body = Column(Text, nullable=True)
	template_id = Column(Integer, ForeignKey("notification_templates.id"), nullable=True)
	sent = Column(Boolean, default=False)
	created_at = Column(DateTime, default=datetime.utcnow)
	sent_at = Column(DateTime, nullable=True)

	attempts = relationship("DeliveryAttempt", back_populates="notification")


class NotificationTemplate(Base):
	__tablename__ = "notification_templates"

	id = Column(Integer, primary_key=True, index=True)
	name = Column(String(128), unique=True, index=True, nullable=False)
	channel = Column(String(32), nullable=False)
	subject_template = Column(String(255), nullable=True)
	body_template = Column(Text, nullable=True)
	created_at = Column(DateTime, default=datetime.utcnow)


class DeliveryAttempt(Base):
	__tablename__ = "notification_attempts"

	id = Column(Integer, primary_key=True, index=True)
	notification_id = Column(Integer, ForeignKey("notifications.id"), nullable=False)
	provider = Column(String(64), nullable=True)
	provider_response = Column(Text, nullable=True)
	success = Column(Boolean, default=False)
	attempted_at = Column(DateTime, default=datetime.utcnow)

	notification = relationship("Notification", back_populates="attempts")


class DeviceToken(Base):
	__tablename__ = "device_tokens"

	id = Column(Integer, primary_key=True, index=True)
	user_id = Column(String(128), index=True, nullable=False)
	platform = Column(String(32), nullable=True)
	token = Column(String(512), nullable=False)
	created_at = Column(DateTime, default=datetime.utcnow)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\password_reset.py ---
"""
Password reset token model
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.core.database import Base


class PasswordResetToken(Base):
    __tablename__ = "password_reset_tokens"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    token = Column(String, unique=True, nullable=False, index=True)
    reset_code = Column(String, nullable=True)  # 6-digit code for SMS
    is_used = Column(Boolean, default=False)
    expires_at = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    used_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    user = relationship("User", back_populates="password_reset_tokens")



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\payment.py ---
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from app.core.database import Base


# ---------------------------------------------------------
# ⭐ Booking Payment Model (renamed to avoid conflict)
# ---------------------------------------------------------
class BookingPayment(Base):
    __tablename__ = "booking_payments"

    id = Column(Integer, primary_key=True, index=True)
    booking_id = Column(Integer, nullable=False)
    user_id = Column(Integer, nullable=True)

    payment_reference = Column(String, unique=True, nullable=True)
    payment_type = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    currency = Column(String, default="INR")

    status = Column(String, default="processing")
    payment_method = Column(String, nullable=True)
    payment_gateway = Column(String, nullable=True)

    gateway_transaction_id = Column(String, nullable=True)
    gateway_order_id = Column(String, nullable=True)

    description = Column(String, nullable=True)

    is_security_deposit = Column(Boolean, default=False)
    security_deposit_refunded = Column(Boolean, default=False)

    initiated_at = Column(DateTime, default=datetime.utcnow)
    completed_at = Column(DateTime, nullable=True)

    # Relationship
    refunds = relationship("BookingRefund", back_populates="payment")


# ---------------------------------------------------------
# ⭐ Booking Refund Model (renamed table)
# ---------------------------------------------------------
class BookingRefund(Base):
    __tablename__ = "booking_refunds"   # ← FIXED NAME

    id = Column(Integer, primary_key=True, index=True)

    payment_id = Column(Integer, ForeignKey("booking_payments.id"))
    refund_reference = Column(String, unique=True)

    amount = Column(Float, nullable=False)
    reason = Column(String, nullable=True)
    status = Column(String, default="completed")

    initiated_at = Column(DateTime, default=datetime.utcnow)
    completed_at = Column(DateTime, default=datetime.utcnow)

    payment = relationship("BookingPayment", back_populates="refunds")


# ---------------------------------------------------------
# ⭐ Confirmation Model
# ---------------------------------------------------------
class Confirmation(Base):
    __tablename__ = "confirmations"

    id = Column(Integer, primary_key=True, index=True)

    booking_id = Column(Integer, nullable=False)
    confirmation_number = Column(String, unique=True)

    confirmation_type = Column(String)
    pdf_content = Column(String)
    email_sent = Column(Boolean, default=False)

    generated_at = Column(DateTime, default=datetime.utcnow)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\payment_models.py ---
from sqlalchemy import Column, Integer, String, Float, DateTime, Enum as SQLEnum, Text, Boolean
from datetime import datetime
from enum import Enum
from app.core.database import Base
from sqlalchemy.orm import relationship
from sqlalchemy import Column, Integer, String, Float, DateTime, Enum as SQLEnum, Text, Boolean, ForeignKey



class PaymentStatus(str, Enum):
    PENDING = "pending"
    INITIATED = "initiated"
    SUCCESS = "success"
    FAILED = "failed"
    REFUNDED = "refunded"
    PARTIALLY_REFUNDED = "partially_refunded"

class PaymentGateway(str, Enum):
    RAZORPAY = "razorpay"
    STRIPE = "stripe"
    PAYTM = "paytm"

class PaymentMethod(str, Enum):
    CARD = "card"
    UPI = "upi"
    NETBANKING = "netbanking"
    WALLET = "wallet"

class Customer(Base):
    __tablename__ = "customers"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, nullable=False)
    phone = Column(String, nullable=True)



from sqlalchemy import ForeignKey

# class Payment(Base):
#     __tablename__ = "payments"

#     id = Column(Integer, primary_key=True, index=True)
#     order_id = Column(String, unique=True, nullable=False, index=True)
#     gateway_order_id = Column(String, unique=True, index=True)
#     payment_id = Column(String, unique=True, index=True)
#     gateway = Column(SQLEnum(PaymentGateway), nullable=False)
#     amount = Column(Float, nullable=False)
#     currency = Column(String, default="INR")
#     status = Column(
#     SQLEnum(PaymentStatus, name="paymentstatus", native_enum=False),
#     default=PaymentStatus.PENDING.value
# )

#     payment_method = Column(SQLEnum(PaymentMethod), nullable=True)

#     user_id = Column(Integer, ForeignKey("customers.id"), nullable=False)
#     hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=False)

#     description = Column(String)
#     notes = Column(Text)
#     created_at = Column(DateTime, default=datetime.utcnow)
#     updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
#     paid_at = Column(DateTime, nullable=True)

#     # ✅ Relationships
#     customer = relationship("Customer")
#     hostel = relationship("Hostel", back_populates="payments")
#     transactions = relationship("Transaction", back_populates="payment", cascade="all, delete-orphan")
#     receipts = relationship("Receipt", back_populates="payment", cascade="all, delete-orphan")



class PaymentWebhook(Base):
    __tablename__ = "payment_webhooks"
    id = Column(Integer, primary_key=True, index=True)
    gateway = Column(SQLEnum(PaymentGateway), nullable=False)
    event_type = Column(String, nullable=False)
    payload = Column(Text, nullable=False)
    payment_id = Column(String, index=True)
    order_id = Column(String, index=True)
    processed = Column(Boolean, default=False)
    processing_error = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    processed_at = Column(DateTime, nullable=True)

class Refund(Base):
    __tablename__ = "refunds"
    id = Column(Integer, primary_key=True, index=True)
    payment_id = Column(String, nullable=False, index=True)
    refund_id = Column(String, unique=True, nullable=False)
    gateway_refund_id = Column(String, unique=True)
    amount = Column(Float, nullable=False)
    reason = Column(String)
    status = Column(String, default="pending")
    gateway_response = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    processed_at = Column(DateTime, nullable=True)
#payments, partial payments, refunds, customers, and generates PDF receipts.
# app/models/payment_models.py
from sqlalchemy import (
    Column, Integer, String, Float, DateTime, Text, Boolean,
    ForeignKey, Enum as SQLEnum
)
from sqlalchemy.orm import relationship
from datetime import datetime
from enum import Enum
from app.core.database import Base


class PaymentStatus(str, Enum):
    PENDING = "pending"
    PARTIAL = "partial"
    SUCCESS = "success"
    FAILED = "failed"
    CANCELLED = "cancelled"


class TransactionType(str, Enum):
    PAYMENT = "payment"
    REFUND = "refund"
    ADJUSTMENT = "adjustment"


class RefundStatus(str, Enum):
    INITIATED = "initiated"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    REJECTED = "rejected"


class Invoice(Base):
    __tablename__ = "invoices"

    id = Column(Integer, primary_key=True, index=True)
    invoice_number = Column(String, unique=True, nullable=False, index=True)
    #user_id = Column(Integer, nullable=False)
    #hostel_id = Column(Integer, nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)  
    hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=False)
    total_amount = Column(Float, nullable=False)
    paid_amount = Column(Float, default=0.0)
    due_amount = Column(Float, nullable=False)
    description = Column(Text)
    items = Column(Text)  # store JSON string
    status = Column(
    SQLEnum(PaymentStatus, name="paymentstatus", native_enum=False),
    default=PaymentStatus.PENDING.value
)

    issue_date = Column(DateTime, default=datetime.utcnow)
    due_date = Column(DateTime, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # ✅ Relationships
    transactions = relationship(
        "Transaction", back_populates="invoice", cascade="all, delete-orphan"
    )
    receipts = relationship(
        "Receipt", back_populates="invoice", cascade="all, delete-orphan"
    )
    user = relationship("User", back_populates="invoices") 
    hostel = relationship("Hostel", back_populates="invoices")
    hostel = relationship("Hostel", back_populates="invoices")
    reminders = relationship("PaymentReminder", back_populates="invoice", cascade="all, delete-orphan")



# -------------------------------------------------------------------
# 💳 TRANSACTION MODEL
# -------------------------------------------------------------------
class Transaction(Base):
    __tablename__ = "transactions"

    id = Column(Integer, primary_key=True, index=True)
    transaction_id = Column(String, unique=True, nullable=False, index=True)
    payment_id = Column(String, ForeignKey("payments.id", ondelete="CASCADE"), nullable=False)

    #payment_id = Column(Integer, ForeignKey("payments.id", ondelete="CASCADE"), nullable=False)

    invoice_id = Column(Integer, ForeignKey("invoices.id", ondelete="CASCADE"), nullable=False)

    transaction_type = Column(SQLEnum(TransactionType), nullable=False)
    amount = Column(Float, nullable=False)
    payment_method = Column(String)
    payment_gateway = Column(String)
    gateway_transaction_id = Column(String)
    status = Column(String, default="success")
    notes = Column(Text)
    processed_by = Column(Integer)
    created_at = Column(DateTime, default=datetime.utcnow)

    # ✅ Relationships
    payment = relationship("Payment", back_populates="transactions")  # this line fixes the error

    invoice = relationship("Invoice", back_populates="transactions")
    receipt = relationship("Receipt", back_populates="transaction", uselist=False, cascade="all, delete-orphan")
    refund_requests = relationship("RefundRequest", back_populates="transaction", cascade="all, delete-orphan")


# -------------------------------------------------------------------
# 🧾 RECEIPT MODEL
# -------------------------------------------------------------------
class Receipt(Base):
    __tablename__ = "receipts"

    id = Column(Integer, primary_key=True, index=True)
    receipt_number = Column(String, unique=True, nullable=False, index=True)
    invoice_id = Column(Integer, ForeignKey("invoices.id", ondelete="CASCADE"), nullable=False)
    transaction_id = Column(Integer, ForeignKey("transactions.id", ondelete="CASCADE"), nullable=False)
    #payment_id = Column(Integer, ForeignKey("payments.id", ondelete="CASCADE"), nullable=False)
    payment_id = Column(String, ForeignKey("payments.id", ondelete="CASCADE"))

    amount = Column(Float, nullable=False)
    pdf_path = Column(String)
    qr_code_data = Column(String)
    is_emailed = Column(Boolean, default=False)
    email_sent_at = Column(DateTime)
    generated_at = Column(DateTime, default=datetime.utcnow)

    # ✅ Relationships
    invoice = relationship("Invoice", back_populates="receipts")
    transaction = relationship("Transaction", back_populates="receipt")
    payment = relationship("Payment", back_populates="receipts")



# -------------------------------------------------------------------
# 💸 REFUND REQUEST MODEL
# -------------------------------------------------------------------
class RefundRequest(Base):
    __tablename__ = "refund_requests"

    id = Column(Integer, primary_key=True, index=True)
    refund_id = Column(String, unique=True, nullable=False, index=True)
    transaction_id = Column(Integer, ForeignKey("transactions.id", ondelete="CASCADE"), nullable=False)
    invoice_id = Column(Integer, ForeignKey("invoices.id", ondelete="CASCADE"), nullable=False)
    refund_amount = Column(Float, nullable=False)
    reason = Column(Text, nullable=False)
    status = Column(
    SQLEnum(RefundStatus, name="refundstatus", native_enum=False),
    default=RefundStatus.INITIATED.value
)

    requested_by = Column(Integer, nullable=False)
    approved_by = Column(Integer)
    rejection_reason = Column(Text)
    gateway_refund_id = Column(String)
    gateway_response = Column(Text)
    requested_at = Column(DateTime, default=datetime.utcnow)
    processed_at = Column(DateTime)
    completed_at = Column(DateTime)

    # ✅ Relationships
    transaction = relationship("Transaction", back_populates="refund_requests")
    invoice = relationship("Invoice")

# -------------------------------------------------------------------
# 🔔 PAYMENT REMINDER MODELS

class ReminderType(str, Enum):
    PRE_DUE = "pre_due"
    DUE_DATE = "due_date"
    OVERDUE = "overdue"
    ESCALATION_1 = "escalation_1"
    ESCALATION_2 = "escalation_2"
    ESCALATION_3 = "escalation_3"
    FINAL_NOTICE = "final_notice"

class ReminderChannel(str, Enum):
    EMAIL = "email"
    SMS = "sms"
    BOTH = "both"

class ReminderStatus(str, Enum):
    PENDING = "pending"
    SENT = "sent"
    FAILED = "failed"
    CANCELLED = "cancelled"



# class User(Base):
#     __tablename__ = "users"
    
#     id = Column(Integer, primary_key=True)
#     name = Column(String, nullable=False)
#     email = Column(String, unique=True, nullable=False)
#     phone = Column(String)
#     hostel_id = Column(Integer, ForeignKey("hostels.id"))
#     email_notifications = Column(Boolean, default=True)
#     sms_notifications = Column(Boolean, default=True)

#     created_at = Column(DateTime, default=datetime.utcnow)

#     invoices = relationship("Invoice", back_populates="user")




class ReminderConfiguration(Base):
    __tablename__ = "reminder_configurations"

    id = Column(Integer, primary_key=True)
    hostel_id = Column(Integer, ForeignKey("hostels.id"), unique=True)

    pre_due_days = Column(String, default="7,3,1")
    pre_due_channels = Column(SQLEnum(ReminderChannel), default=ReminderChannel.EMAIL)

    due_date_enabled = Column(Boolean, default=True)
    due_date_channels = Column(SQLEnum(ReminderChannel), default=ReminderChannel.BOTH)

    overdue_frequency_days = Column(Integer, default=3)
    overdue_channels = Column(SQLEnum(ReminderChannel), default=ReminderChannel.BOTH)

    escalation_enabled = Column(Boolean, default=True)
    escalation_1_days = Column(Integer, default=7)
    escalation_2_days = Column(Integer, default=14)
    escalation_3_days = Column(Integer, default=30)
    final_notice_days = Column(Integer, default=45)

    escalation_emails = Column(String)
    escalation_cc = Column(String)
    max_reminders = Column(Integer, default=10)

    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    hostel = relationship("Hostel", back_populates="reminder_config")



class PaymentReminder(Base):
    __tablename__ = "payment_reminders"

    id = Column(Integer, primary_key=True)
    reminder_id = Column(String, unique=True, nullable=False)

    invoice_id = Column(Integer, ForeignKey("invoices.id"), nullable=False)
    reminder_type = Column(SQLEnum(ReminderType), nullable=False)
    channel = Column(SQLEnum(ReminderChannel), nullable=False)

    recipient_email = Column(String)
    recipient_phone = Column(String)

    subject = Column(String)
    message_body = Column(Text)

    status = Column(SQLEnum(ReminderStatus), default=ReminderStatus.PENDING)
    scheduled_at = Column(DateTime)
    sent_at = Column(DateTime)

    error_message = Column(Text)
    delivery_status = Column(String)

    created_at = Column(DateTime, default=datetime.utcnow)

    invoice = relationship("Invoice", back_populates="reminders")


class ReminderTemplate(Base):
    __tablename__ = "reminder_templates"

    id = Column(Integer, primary_key=True)
    name = Column(String)
    reminder_type = Column(SQLEnum(ReminderType))

    email_subject = Column(String)
    email_body = Column(Text)
    sms_body = Column(String)

    is_default = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\permission.py ---
"""
🔐 Role-based permission matrix
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.sql import func

from app.core.database import Base


class Permission(Base):
    __tablename__ = "permissions"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)
    description = Column(String, nullable=True)
    resource = Column(String, nullable=True)  # e.g., "user", "hostel"
    action = Column(String, nullable=True)  # e.g., "create", "read", "update", "delete"
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())


class RolePermission(Base):
    __tablename__ = "role_permissions"
    
    id = Column(Integer, primary_key=True, index=True)
    role = Column(String, nullable=False)
    permission_id = Column(Integer, ForeignKey("permissions.id"), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\refresh_token.py ---
"""
🔄 Refresh tokens table
"""
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.core.database import Base


class RefreshToken(Base):
    __tablename__ = "refresh_tokens"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    token = Column(String, unique=True, nullable=False)
    is_active = Column(Boolean, default=True)
    expires_at = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Relationships
    user = relationship("User", back_populates="refresh_tokens")



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\reports.py ---
from sqlalchemy import Column, Integer, String, DateTime, Date, Numeric, Boolean, Text, ForeignKey
from datetime import datetime
from app.core.database import Base

class Attendance(Base):
    __tablename__ = "attendance"
    
    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, nullable=False, index=True)
    student_id = Column(Integer, nullable=False, index=True)
    student_name = Column(String(255))
    date = Column(Date, nullable=False, index=True)
    is_present = Column(Boolean, default=True)
    marked_by = Column(String(255))
    marked_at = Column(DateTime, default=datetime.utcnow)
    notes = Column(Text)

class FinancialTransaction(Base):
    __tablename__ = "financial_transactions"
    
    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, nullable=False, index=True)
    student_id = Column(Integer, index=True)
    transaction_type = Column(String(50), nullable=False)  # fee, expense, booking
    category = Column(String(100))
    amount = Column(Numeric(10, 2), nullable=False)
    description = Column(Text)
    transaction_date = Column(Date, nullable=False, index=True)
    payment_status = Column(String(50), default='pending')
    created_at = Column(DateTime, default=datetime.utcnow)

class HostelBooking(Base):
    __tablename__ = "hostel_bookings"
    
    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, nullable=False, index=True)
    student_name = Column(String(255))
    student_email = Column(String(255))
    student_phone = Column(String(20))
    room_type = Column(String(100))
    booking_date = Column(DateTime, default=datetime.utcnow, index=True)
    check_in_date = Column(Date)
    status = Column(String(50), default='pending')  # pending, confirmed, cancelled
    source = Column(String(100))  # website, referral, social_media, etc.
    converted = Column(Boolean, default=False)

class HostelProfileView(Base):
    __tablename__ = "hostel_profile_views"
    
    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, nullable=False, index=True)
    viewed_at = Column(DateTime, default=datetime.utcnow, index=True)
    visitor_ip = Column(String(50))
    source = Column(String(100))  # search, direct, social, etc.
    session_id = Column(String(255))

class SearchQuery(Base):
    __tablename__ = "search_queries"
    
    id = Column(Integer, primary_key=True, index=True)
    query_text = Column(String(500))
    city = Column(String(100), index=True)
    filters = Column(Text)  # JSON string of applied filters
    results_count = Column(Integer)
    searched_at = Column(DateTime, default=datetime.utcnow, index=True)

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\report_models.py ---
from sqlalchemy import (
    Column, String, DateTime, ForeignKey, Numeric, Integer, JSON, Boolean, Enum as SQLEnum
)
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid
import enum

from app.core.database import Base

class BookingStatus(str, enum.Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class PaymentStatus(str, enum.Enum):
    PENDING = "pending"
    PAID = "paid"
    FAILED = "failed"
    REFUNDED = "refunded"

class CommissionStatus(str, enum.Enum):
    PENDING = "pending"
    PAID = "paid"
    PROCESSING = "processing"

class ReportType(str, enum.Enum):
    REVENUE = "revenue"
    COMMISSION = "commission"
    BOOKING = "booking"
    USER_ACTIVITY = "user_activity"
    SUBSCRIPTION = "subscription"
    SYSTEM_PERFORMANCE = "system_performance"

class ExportFormat(str, enum.Enum):
    PDF = "pdf"
    CSV = "csv"
    EXCEL = "excel"

class BookingReport(Base):
    __tablename__ = "booking_reports"

    id = Column(String, primary_key=True, default=lambda: f"book_{uuid.uuid4().hex[:8]}")
    hostel_id = Column(String, nullable=False, index=True)
    hostel_name = Column(String, nullable=False)
    user_id = Column(String, nullable=False, index=True)
    user_name = Column(String, nullable=False)

    room_type = Column(String, nullable=False)
    check_in_date = Column(DateTime, nullable=False)
    check_out_date = Column(DateTime, nullable=False)

    amount = Column(Numeric(10, 2), nullable=False)
    commission_rate = Column(Numeric(5, 4), nullable=False)
    commission_amount = Column(Numeric(10, 2), nullable=False)

    status = Column(SQLEnum(BookingStatus), default=BookingStatus.PENDING)
    payment_status = Column(SQLEnum(PaymentStatus), default=PaymentStatus.PENDING)

    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    commission = relationship("Commission", back_populates="booking", uselist=False)


class Commission(Base):
    __tablename__ = "commissions"

    id = Column(String, primary_key=True, default=lambda: f"comm_{uuid.uuid4().hex[:8]}")
    booking_id = Column(String, ForeignKey('booking_reports.id'), nullable=False, unique=True)

    amount = Column(Numeric(10, 2), nullable=False)
    status = Column(SQLEnum(CommissionStatus), default=CommissionStatus.PENDING)

    earned_date = Column(DateTime, nullable=False)
    paid_date = Column(DateTime, nullable=True)

    hostel_id = Column(String, nullable=False, index=True)
    platform_revenue = Column(Numeric(10, 2), nullable=False)

    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    booking = relationship("BookingReport", back_populates="commission")


class SubscriptionRevenue(Base):
    __tablename__ = "subscription_revenues"

    id = Column(String, primary_key=True, default=lambda: f"subrev_{uuid.uuid4().hex[:8]}")
    subscription_id = Column(String, nullable=False, index=True)
    organization_id = Column(String, nullable=False, index=True)
    organization_name = Column(String, nullable=False)

    amount = Column(Numeric(10, 2), nullable=False)
    plan_name = Column(String, nullable=False)

    billing_date = Column(DateTime, nullable=False, index=True)
    period_start = Column(DateTime, nullable=False)
    period_end = Column(DateTime, nullable=False)

    created_at = Column(DateTime, default=datetime.utcnow)


class Report(Base):
    __tablename__ = "reports"

    id = Column(String, primary_key=True, default=lambda: f"rep_{uuid.uuid4().hex[:8]}")
    name = Column(String, nullable=False)
    report_type = Column(SQLEnum(ReportType), nullable=False)

    start_date = Column(DateTime, nullable=False)
    end_date = Column(DateTime, nullable=False)

    parameters = Column(JSON)
    result_data = Column(JSON)

    file_path = Column(String, nullable=True)
    export_format = Column(SQLEnum(ExportFormat), nullable=True)

    generated_by = Column(String, nullable=False)
    generated_at = Column(DateTime, default=datetime.utcnow, index=True)

    is_automated = Column(Boolean, default=False)
    is_scheduled = Column(Boolean, default=False)


class FinancialSummary(Base):
    __tablename__ = "financial_summaries"

    id = Column(String, primary_key=True, default=lambda: f"finsum_{uuid.uuid4().hex[:8]}")

    period_start = Column(DateTime, nullable=False, index=True)
    period_end = Column(DateTime, nullable=False, index=True)

    total_income = Column(Numeric(10, 2), default=0)
    subscription_revenue = Column(Numeric(10, 2), default=0)
    commission_earned = Column(Numeric(10, 2), default=0)
    pending_payments = Column(Numeric(10, 2), default=0)

    total_bookings = Column(Integer, default=0)
    completed_bookings = Column(Integer, default=0)
    cancelled_bookings = Column(Integer, default=0)

    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\rooms.py ---
from enum import Enum
from sqlalchemy import (
    Column, String, Integer, Float, DateTime, ForeignKey, func
)
from sqlalchemy import Enum as SAEnum
from sqlalchemy.orm import relationship

from app.core.database import Base


# ---------------------------------------------------------
# ENUMS
# ---------------------------------------------------------
class RoomType(str, Enum):
    SINGLE = "single"
    DOUBLE = "double"
    TRIPLE = "triple"
    DORM = "dorm"
    SUITE = "suite"     # Included from earlier version


class MaintenanceStatus(str, Enum):
    OK = "ok"
    NEEDS_MAINTENANCE = "needs_maintenance"
    OUT_OF_SERVICE = "out_of_service"


# ---------------------------------------------------------
# FINAL MERGED ROOM MODEL
# ---------------------------------------------------------
class Room(Base):
    __tablename__ = "rooms"

    # -----------------------------------------------------
    # Primary Key
    # -----------------------------------------------------
    id = Column(Integer, primary_key=True, index=True)

    # -----------------------------------------------------
    # Hostel Link
    # -----------------------------------------------------
    hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=False)

    # -----------------------------------------------------
    # Room Basic Details (Merged)
    # -----------------------------------------------------
    room_number = Column(String(50), nullable=True)   # From version 1

    # Enum room type (advanced)
    room_type = Column(
        SAEnum(RoomType, name="room_type_enum"),
        nullable=False,
        default=RoomType.SINGLE
    )

    # Simple string room_type kept as compatibility? ❌ NO  
    # (Your first version is better — so removed duplicate)

    # -----------------------------------------------------
    # Pricing (Merged)
    # -----------------------------------------------------
    monthly_price = Column(Float, nullable=True)
    quarterly_price = Column(Float, nullable=True)
    annual_price = Column(Float, nullable=True)

    # simple price field (version 2)
    price = Column(Float, nullable=True)  # Optional: for nightly or simplified pricing

    # -----------------------------------------------------
    # Capacity & Beds (Merged)
    # -----------------------------------------------------
    room_capacity = Column(Integer, nullable=False, default=1)   # version 1
    total_beds = Column(Integer, nullable=False, default=1)      # version 2
    available_beds = Column(Integer, nullable=False, default=1)
    availability = Column(Integer, nullable=False, default=0)    # version 1 extra

    # -----------------------------------------------------
    # Amenities
    # -----------------------------------------------------
    amenities = Column(String(1000), nullable=True)

    # -----------------------------------------------------
    # Maintenance
    # -----------------------------------------------------
    maintenance_status = Column(
        SAEnum(MaintenanceStatus, name="maintenance_status_enum"),
        nullable=False,
        default=MaintenanceStatus.OK,
    )

    # -----------------------------------------------------
    # Timestamps
    # -----------------------------------------------------
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)

    # -----------------------------------------------------
    # Relationship → Hostel
    # -----------------------------------------------------
    hostel = relationship("Hostel", back_populates="rooms")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\search.py ---
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Enum
from datetime import datetime
import enum
from app.core.database import Base

class UserRole(str, enum.Enum):
    SUPER_ADMIN = "super_admin"
    ADMIN = "admin"
    SUPERVISOR = "supervisor"
    STUDENT = "student"

class AdminHostelMapping(Base):
    __tablename__ = "admin_hostel_mappings"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, nullable=False, index=True)
    user_name = Column(String(255))
    user_role = Column(Enum(UserRole), nullable=False)
    hostel_id = Column(Integer, nullable=False, index=True)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\session_context.py ---
"""
🧭 Active hostel context per admin
"""
from sqlalchemy import Column, Integer, ForeignKey, DateTime, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.core.database import Base


class SessionContext(Base):
    __tablename__ = "session_contexts"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="session_contexts")
    hostel = relationship("Hostel", back_populates="session_contexts")



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\shift_coordination_models.py ---
from sqlalchemy import Column, Integer, String, ForeignKey, Text, Boolean, Date, DateTime, DECIMAL
from sqlalchemy.orm import relationship
from datetime import datetime
from app.core.database import Base


class Shift(Base):
    __tablename__ = "shifts"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    start_time = Column(String(10))
    end_time = Column(String(10))
    hostel_id = Column(Integer, ForeignKey("hostels.id"))
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    schedules = relationship("ShiftSchedule", back_populates="shift")


class ShiftSchedule(Base):
    __tablename__ = "shift_schedules"

    id = Column(Integer, primary_key=True, index=True)
    admin_id = Column(Integer, ForeignKey("admins.id"))
    shift_id = Column(Integer, ForeignKey("shifts.id"))
    hostel_id = Column(Integer, ForeignKey("hostels.id"))
    scheduled_date = Column(Date, nullable=False)
    status = Column(String(20), default="scheduled")
    check_in_time = Column(DateTime, nullable=True)
    check_out_time = Column(DateTime, nullable=True)
    notes = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    admin = relationship("Admin")
    shift = relationship("Shift", back_populates="schedules")
    handovers_from = relationship("ShiftHandover", foreign_keys="[ShiftHandover.from_schedule_id]", back_populates="from_schedule")
    handovers_to = relationship("ShiftHandover", foreign_keys="[ShiftHandover.to_schedule_id]", back_populates="to_schedule")


class Task(Base):
    __tablename__ = "tasks"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(255), nullable=False)
    description = Column(Text)
    hostel_id = Column(Integer, ForeignKey("hostels.id"))
    assigned_to = Column(Integer, ForeignKey("admins.id"))
    assigned_by = Column(Integer, ForeignKey("admins.id"))
    category = Column(String(50))
    priority = Column(String(20), default="medium")
    status = Column(String(20), default="pending")
    due_date = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    estimated_duration = Column(Integer, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    assignee = relationship("Admin", foreign_keys=[assigned_to])
    assigner = relationship("Admin", foreign_keys=[assigned_by])
    delegations = relationship("TaskDelegation", back_populates="task")
    updates = relationship("TaskUpdate", back_populates="task")


class TaskDelegation(Base):
    __tablename__ = "task_delegations"

    id = Column(Integer, primary_key=True, index=True)
    task_id = Column(Integer, ForeignKey("tasks.id"))
    from_admin_id = Column(Integer, ForeignKey("admins.id"))
    to_admin_id = Column(Integer, ForeignKey("admins.id"))
    reason = Column(Text)
    delegated_at = Column(DateTime, default=datetime.utcnow)
    accepted = Column(Boolean, default=False)
    accepted_at = Column(DateTime, nullable=True)

    task = relationship("Task", back_populates="delegations")


class TaskUpdate(Base):
    __tablename__ = "task_updates"

    id = Column(Integer, primary_key=True, index=True)
    task_id = Column(Integer, ForeignKey("tasks.id"))
    admin_id = Column(Integer, ForeignKey("admins.id"))
    update_type = Column(String(50))
    old_value = Column(Text)
    new_value = Column(Text)
    comment = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)

    task = relationship("Task", back_populates="updates")


class ShiftHandover(Base):
    __tablename__ = "shift_handovers"

    id = Column(Integer, primary_key=True, index=True)
    from_schedule_id = Column(Integer, ForeignKey("shift_schedules.id"))
    to_schedule_id = Column(Integer, ForeignKey("shift_schedules.id"))
    hostel_id = Column(Integer, ForeignKey("hostels.id"))
    handover_time = Column(DateTime, default=datetime.utcnow)
    occupancy_status = Column(Text)
    pending_checkouts = Column(Integer, default=0)
    expected_checkins = Column(Integer, default=0)
    urgent_issues = Column(Text)
    maintenance_required = Column(Text)
    guest_concerns = Column(Text)
    pending_tasks = Column(Text)
    completed_tasks = Column(Text)
    inventory_status = Column(Text)
    cash_handover = Column(DECIMAL(10, 2), nullable=True)
    keys_status = Column(Text)
    notes = Column(Text)
    special_instructions = Column(Text)
    acknowledged = Column(Boolean, default=False)
    acknowledged_at = Column(DateTime, nullable=True)
    acknowledgment_notes = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)

    from_schedule = relationship("ShiftSchedule", foreign_keys=[from_schedule_id], back_populates="handovers_from")
    to_schedule = relationship("ShiftSchedule", foreign_keys=[to_schedule_id], back_populates="handovers_to")
    items = relationship("HandoverItem", back_populates="handover")


class HandoverItem(Base):
    __tablename__ = "handover_items"

    id = Column(Integer, primary_key=True, index=True)
    handover_id = Column(Integer, ForeignKey("shift_handovers.id"))
    item_type = Column(String(50))
    title = Column(String(255))
    description = Column(Text)
    priority = Column(String(20), default="medium")
    status = Column(String(20), default="pending")
    resolved_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    handover = relationship("ShiftHandover", back_populates="items")


class SupervisorCoordination(Base):
    __tablename__ = "supervisor_coordination"

    id = Column(Integer, primary_key=True, index=True)
    hostel_id = Column(Integer, ForeignKey("hostels.id"))
    coordination_date = Column(Date, nullable=False)
    meeting_type = Column(String(50))
    participants = Column(Text)
    agenda = Column(Text)
    discussion_points = Column(Text)
    decisions_made = Column(Text)
    action_items = Column(Text)
    next_meeting = Column(DateTime, nullable=True)
    created_by = Column(Integer, ForeignKey("admins.id"))
    created_at = Column(DateTime, default=datetime.utcnow)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\students.py ---
from enum import Enum
from sqlalchemy import Column, String, Integer, Float, DateTime, Date, Time, Boolean, func, ForeignKey
from sqlalchemy import Enum as SAEnum
from sqlalchemy.schema import Identity

from app.config import Base


class PaymentStatus(str, Enum):
    PAID = "paid"
    PENDING = "pending"
    FAILED = "failed"


class PaymentType(str, Enum):
    RENT = "rent"
    DEPOSIT = "deposit"
    MAINTENANCE = "maintenance"
    UTILITY = "utility"
    LATE_FEE = "late_fee"
    OTHER = "other"


class PaymentMethod(str, Enum):
    CASH = "cash"
    CARD = "card"
    BANK_TRANSFER = "bank_transfer"
    MOBILE_MONEY = "mobile_money"
    CHECK = "check"
    OTHER = "other"


class AttendanceStatus(str, Enum):
    PRESENT = "present"
    ABSENT = "absent"


class AttendanceMode(str, Enum):
    IN_PERSON = "in_person"
    REMOTE = "remote"
    HYBRID = "hybrid"
    LEAVE = "leave"


class Student(Base):
    __tablename__ = "students"

    student_id = Column(String, primary_key=True, index=True)
    student_name = Column(String, nullable=False)
    student_email = Column(String, unique=True, nullable=False)
    student_phone = Column(String, nullable=False)
    date_of_birth = Column(Date, nullable=True)
    guardian_name = Column(String, nullable=True)
    guardian_phone = Column(String, nullable=True)
    emergency_contact = Column(String, nullable=True)
    check_in_date = Column(Date, nullable=True)
    check_out_date = Column(Date, nullable=True)
    room_assignment = Column(String, nullable=True)
    bed_assignment = Column(String, nullable=True)
    status = Column(String, nullable=True)


class StudentStatusHistory(Base):
    """History log for student status changes and transfers."""
    __tablename__ = "student_status_history"

    id = Column(Integer, Identity(start=1), primary_key=True)
    student_id = Column(String, ForeignKey("students.student_id"), nullable=False, index=True)
    event_type = Column(String, nullable=False)  # 'status_change' or 'transfer'
    old_status = Column(String, nullable=True)
    new_status = Column(String, nullable=True)
    old_room = Column(String, nullable=True)
    old_bed = Column(String, nullable=True)
    new_room = Column(String, nullable=True)
    new_bed = Column(String, nullable=True)
    notes = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)


class StudentPayment(Base):
    __tablename__ = "student_payments"

    id = Column(Integer, Identity(start=1), primary_key=True)
    student_id = Column(String, ForeignKey("students.student_id"), nullable=False, index=True)
    payment_type = Column(SAEnum(PaymentType, name="payment_type_enum"), nullable=True)
    amount = Column(Float, nullable=False)
    payment_method = Column(SAEnum(PaymentMethod, name="payment_method_enum"), nullable=True)
    payment_date = Column(Date, nullable=True)
    due_date = Column(Date, nullable=True)
    transaction_id = Column(String, nullable=True)
    currency = Column(String, nullable=True)
    status = Column(String, nullable=False)  # use PaymentStatus values
    method = Column(String, nullable=True)  # kept for backward compatibility
    paid_at = Column(DateTime(timezone=True), nullable=True)  # kept for backward compatibility
    notes = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)


class Attendance(Base):
    __tablename__ = "student_attendance"

    id = Column(Integer, Identity(start=1), primary_key=True)
    student_id = Column(String, ForeignKey("students.student_id"), nullable=False, index=True)
    attendance_date = Column(Date, nullable=False)
    attendance_mode = Column(SAEnum(AttendanceMode, name="attendance_mode_enum"), nullable=True)
    check_in_time = Column(Time, nullable=True)
    check_out_time = Column(Time, nullable=True)
    is_late = Column(Boolean, nullable=True, default=False)
    date = Column(Date, nullable=True)  # kept for backward compatibility
    status = Column(String, nullable=False)  # use AttendanceStatus values
    notes = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)


class StudentDocument(Base):
    __tablename__ = "student_documents"

    id = Column(Integer, Identity(start=1), primary_key=True)
    student_id = Column(String, ForeignKey("students.student_id"), nullable=False, index=True)
    doc_type = Column(String, nullable=True)
    doc_url = Column(String, nullable=False)
    uploaded_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\subscription.py ---
from sqlalchemy import (
    Column, String, DateTime, ForeignKey, Numeric, Integer, JSON, Enum as SQLEnum,
    Boolean, Text
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.core.database import Base
import uuid
import enum
from datetime import datetime
from enum import Enum



class PlanTier(str, enum.Enum):
    free = "free"
    standard = "standard"
    premium = "premium"


class BillingCycle(str, enum.Enum):
    monthly = "monthly"
    yearly = "yearly"

class PaymentGateway(str, Enum):
    RAZORPAY = "razorpay"
    STRIPE = "stripe"
    PAYTM = "paytm"

class PaymentMethod(str, Enum):
    CARD = "card"
    UPI = "upi"
    NETBANKING = "netbanking"
    WALLET = "wallet"

class SubscriptionStatus(str, enum.Enum):
    active = "active"
    inactive = "inactive"
    canceled = "canceled"
    past_due = "past_due"
    trialing = "trialing"


class PaymentStatus(str, enum.Enum):
    pending = "pending"
    succeeded = "succeeded"
    failed = "failed"
    refunded = "refunded"
    initiated = "initiated"
    # SUCCESS = "success"



class PaymentType(str, enum.Enum):
    subscription = "subscription"
    upgrade = "upgrade"
    downgrade = "downgrade"
    refund = "refund"
    proration = "proration"


class ChangeType(str, enum.Enum):
    upgrade = "upgrade"
    downgrade = "downgrade"
    cancel = "cancel"
    reactivate = "reactivate"


class SubscriptionPlan(Base):
    __tablename__ = "subscription_plans"

    id = Column(String, primary_key=True, default=lambda: f"plan_{uuid.uuid4().hex[:8]}")
    name = Column(String, nullable=False)
    tier = Column(SQLEnum(PlanTier, name="plan_tier"), nullable=False, index=True)
    billing_cycle = Column(SQLEnum(BillingCycle, name="billing_cycle"), nullable=False)
    price = Column(Numeric(10, 2), nullable=False)
    currency = Column(String, default="USD")

    # Plan Features
    max_hostels = Column(Integer, nullable=False)
    max_admins = Column(Integer, nullable=False)
    max_students = Column(Integer, nullable=False)
    features = Column(JSON)

    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())

    subscriptions = relationship("Subscription", back_populates="plan")


class Subscription(Base):
    __tablename__ = "subscriptions"

    id = Column(String, primary_key=True, default=lambda: f"sub_{uuid.uuid4().hex[:8]}")
    organization_id = Column(String, nullable=False, index=True)
    organization_name = Column(String, nullable=False)
    email = Column(String, nullable=False)
    plan_id = Column(String, ForeignKey('subscription_plans.id'), nullable=False)

    status = Column(SQLEnum(SubscriptionStatus, name="subscription_status"), default=SubscriptionStatus.active)

    # Billing
    current_period_start = Column(DateTime, nullable=False)
    current_period_end = Column(DateTime, nullable=False)
    trial_end = Column(DateTime, nullable=True)

    # Usage tracking
    current_hostels = Column(Integer, default=0)
    current_admins = Column(Integer, default=0)
    current_students = Column(Integer, default=0)

    cancel_at_period_end = Column(Boolean, default=False)
    canceled_at = Column(DateTime, nullable=True)

    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())

    plan = relationship("SubscriptionPlan", back_populates="subscriptions")
    payments = relationship("Payment", back_populates="subscription", cascade="all, delete-orphan")
    changes = relationship("SubscriptionChange", back_populates="subscription", cascade="all, delete-orphan")


# class Payment(Base):
#     __tablename__ = "payments"

#     id = Column(String, primary_key=True, default=lambda: f"pay_{uuid.uuid4().hex[:8]}")
#     subscription_id = Column(String, ForeignKey('subscriptions.id', ondelete='CASCADE'), nullable=False)

#     hostel_id = Column(Integer, ForeignKey("hostels.id"))        # ADDED
#     hostel = relationship("Hostel", back_populates="payments")

#     amount = Column(Numeric(10, 2), nullable=False)
#     currency = Column(String, default="USD")
#     status = Column(SQLEnum(PaymentStatus, name="payment_status"), default=PaymentStatus.pending)
#     payment_type = Column(SQLEnum(PaymentType, name="payment_type"), default=PaymentType.subscription)

#     payment_method = Column(String)
#     payment_method_last4 = Column(String)

#     description = Column(Text)
#     metadata_ = Column('metadata', JSON)

#     paid_at = Column(DateTime, nullable=True)
#     failed_at = Column(DateTime, nullable=True)
#     refunded_at = Column(DateTime, nullable=True)

#     created_at = Column(DateTime, server_default=func.now())

#     subscription = relationship("Subscription", back_populates="payments")

class Payment(Base):
    __tablename__ = "payments"

    # -----------------------------------
    # IDs
    # -----------------------------------
    id = Column(String, primary_key=True, default=lambda: f"pay_{uuid.uuid4().hex[:8]}")
    order_id = Column(String, unique=True, nullable=True, index=True)            # MERGED
    gateway_order_id = Column(String, unique=True, index=True)                   # MERGED
    payment_id = Column(String, unique=True, index=True)                         # MERGED

    # -----------------------------------
    # Foreign Keys
    # -----------------------------------
    subscription_id = Column(String, ForeignKey("subscriptions.id", ondelete="CASCADE"), nullable=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)         # MERGED
    hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=False)        # FROM BOTH MODELS

    # -----------------------------------
    # Payment Details
    # -----------------------------------
    amount = Column(Numeric(10, 2), nullable=False)                              # BASE MODEL
    currency = Column(String, default="USD")                                     # BASE MODEL

    gateway = Column(SQLEnum(PaymentGateway), nullable=True)                     # MERGED

    status = Column(
        SQLEnum(PaymentStatus, name="payment_status"),
        default=PaymentStatus.pending
    )                                                                             # BASE MODEL

    payment_type = Column(
        SQLEnum(PaymentType, name="payment_type"),
        default=PaymentType.subscription
    )                                                                             # BASE MODEL

    payment_method = Column(String)                                              # BASE MODEL
    payment_method_last4 = Column(String)                                        # BASE MODEL
    payment_method_enum = Column(SQLEnum(PaymentMethod), nullable=True)          # MERGED (renamed)

    # -----------------------------------
    # Metadata & Notes
    # -----------------------------------
    description = Column(Text)
    notes = Column(Text)                                                         # MERGED
    metadata_ = Column("metadata", JSON)

    # -----------------------------------
    # Timestamps
    # -----------------------------------
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    paid_at = Column(DateTime, nullable=True)
    failed_at = Column(DateTime, nullable=True)
    refunded_at = Column(DateTime, nullable=True)

    # -----------------------------------
    # Relationships
    # -----------------------------------
    subscription = relationship("Subscription", back_populates="payments")
    user = relationship("User", back_populates="payments")        # BASE MODEL
    # customer = relationship("Customer")                                           # MERGED
    hostel = relationship("Hostel", back_populates="payments")                    # BOTH MODELS

    transactions = relationship(
        "Transaction",
        back_populates="payment",
        cascade="all, delete-orphan"
    )                                                                             # MERGED

    receipts = relationship(
        "Receipt",
        back_populates="payment",
        cascade="all, delete-orphan"
    )                                                                             # MERGED


class SubscriptionChange(Base):
    __tablename__ = "subscription_changes"

    id = Column(String, primary_key=True, default=lambda: f"change_{uuid.uuid4().hex[:8]}")
    subscription_id = Column(String, ForeignKey('subscriptions.id', ondelete='CASCADE'), nullable=False)

    change_type = Column(SQLEnum(ChangeType, name="change_type"), nullable=False)
    from_plan_id = Column(String, ForeignKey('subscription_plans.id'), nullable=True)
    to_plan_id = Column(String, ForeignKey('subscription_plans.id'), nullable=True)

    proration_amount = Column(Numeric(10, 2), default=0)

    effective_date = Column(DateTime, nullable=False)
    initiated_by = Column(String, nullable=False)
    reason = Column(Text)

    created_at = Column(DateTime, server_default=func.now())

    subscription = relationship("Subscription", back_populates="changes")
    from_plan = relationship("SubscriptionPlan", foreign_keys=[from_plan_id])
    to_plan = relationship("SubscriptionPlan", foreign_keys=[to_plan_id])
  

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\supervisors.py ---
from enum import Enum
from sqlalchemy import Column, String, Integer, DateTime, func, ForeignKey
from sqlalchemy import Enum as SAEnum
from sqlalchemy.schema import Identity

from app.core.database import Base


class SupervisorRole(str, Enum):
    ADMIN = "admin"
    MANAGER = "manager"
    SUPERVISOR = "supervisor"


class Department(str, Enum):
    OPERATIONS = "operations"
    MAINTENANCE = "maintenance"
    ADMISSIONS = "admissions"
    FINANCE = "finance"
    OTHER = "other"


class AccessLevel(str, Enum):
    FULL = "full"
    LIMITED = "limited"
    READ_ONLY = "read_only"


class Supervisor(Base):
    __tablename__ = "supervisors"

    employee_id = Column(String, primary_key=True, index=True)
    supervisor_name = Column(String, nullable=False)
    supervisor_email = Column(String, unique=True, nullable=False)
    supervisor_phone = Column(String, nullable=False)
    role = Column(SAEnum(SupervisorRole, name="supervisor_role_enum"), nullable=False)
    department = Column(SAEnum(Department, name="department_enum"), nullable=True)
    access_level = Column(SAEnum(AccessLevel, name="access_level_enum"), nullable=True)
    permissions = Column(String, nullable=True)
    status = Column(String, nullable=True)
    invitation_status = Column(String, nullable=True)


class SupervisorHostel(Base):
    """Many-to-many relationship between supervisors and hostels."""
    __tablename__ = "supervisor_hostels"

    id = Column(Integer, Identity(start=1), primary_key=True)
    employee_id = Column(String, ForeignKey("supervisors.employee_id"), nullable=False, index=True)
    hostel_id = Column(String(100), nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)


class SupervisorActivity(Base):
    """Activity log for supervisor actions."""
    __tablename__ = "supervisor_activity"

    id = Column(Integer, Identity(start=1), primary_key=True)
    employee_id = Column(String, ForeignKey("supervisors.employee_id"), nullable=False, index=True)
    action = Column(String, nullable=False)
    details = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)


class AdminOverride(Base):
    __tablename__ = "admin_overrides"

    id = Column(Integer, Identity(start=1), primary_key=True)
    admin_employee_id = Column(String, ForeignKey("supervisors.employee_id"), nullable=False)
    target_supervisor_id = Column(String, ForeignKey("supervisors.employee_id"), nullable=True)
    action = Column(String, nullable=False)
    details = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\user.py ---
"""
👤 User model with role & hostel_id
"""
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, DateTime, Enum
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum
from datetime import datetime
from app.core.database import Base
from app.core.roles import Role


class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=True)
    # `phone_number` stores the user's phone number (preferably in E.164 format, e.g. +911234567890)
    phone_number = Column(String, unique=True, index=True, nullable=True)
    country_code = Column(String, nullable=True)  # Country code (e.g., +1, +91)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=True)  # Nullable for social login
    full_name = Column(String, nullable=True)
    role = Column(String, default=Role.VISITOR.value, nullable=False)
    hostel_id = Column(Integer, ForeignKey("hostels.id"), nullable=True)
    is_active = Column(Boolean, default=False)  # Default False until OTP verified
    is_email_verified = Column(Boolean, default=False)
    is_phone_verified = Column(Boolean, default=False)
    profile_picture_url = Column(String, nullable=True)  # Profile picture URL
    # Removed social OAuth columns (social login was disabled/removed)
    remember_me = Column(Boolean, default=False)  # For extended session
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    name = Column(String, nullable=False)
    is_verified = Column(Boolean, default=False)
    
    # Relationships
    hostel = relationship("Hostel", back_populates="users")
    refresh_tokens = relationship("RefreshToken", back_populates="user")
    audit_logs = relationship("AuditLog", back_populates="user")
    admin_hostel_mappings = relationship("AdminHostelMapping", back_populates="admin")
    session_contexts = relationship("SessionContext", back_populates="user")
    password_reset_tokens = relationship("PasswordResetToken", back_populates="user")
    payments = relationship("Payment", back_populates="user")
    invoices = relationship("Invoice", back_populates="user")
    bookings = relationship("BookingRequest", back_populates="user")
    
class OTP(Base):
    __tablename__ = "otps"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), index=True)
    email = Column(String, nullable=True)
    phone = Column(String, nullable=True)
    otp_code = Column(String, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    is_used = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    # relationship
    # user = relationship("app.models.user.User", back_populates="otps")    # Removed to fix mapper error

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\visitor.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\waitlist.py ---
from sqlalchemy import Column, Integer, String, DateTime
from datetime import datetime

from app.core.database import Base


class Waitlist(Base):
    __tablename__ = "waitlist"

    id = Column(Integer, primary_key=True)
    hostel_id = Column(Integer, nullable=False)
    room_type = Column(String, nullable=False)
    visitor_id = Column(Integer, nullable=False)
    priority = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\__init__.py ---

"""
Database models
"""

# Core Models
from app.models.user import User
from app.models.rooms import Room
from app.models.admin import Admin, AdminHostelAssignment
from app.models.hostel import Hostel
from app.models.admin_hostel_mapping import AdminHostelMapping
from app.models.session_context import SessionContext
from app.models.permission import Permission, RolePermission
from app.models.audit_log import AuditLog
from app.models.refresh_token import RefreshToken
from app.models.approval_request import ApprovalRequest
from app.models.password_reset import PasswordResetToken

# Complaint Models
from app.models.complaint import Complaint, ComplaintNote

# Report & Analytics Models
from app.models.reports import (
    Attendance,
    FinancialTransaction,
    HostelBooking,
    HostelProfileView,
    SearchQuery,
)

__all__ = [
    "User",
    "Hostel",
    "AdminHostelMapping",
    "SessionContext",
    "Permission",
    "RolePermission",
    "AuditLog",
    "RefreshToken",
    "ApprovalRequest",
    "PasswordResetToken",
    "Complaint",
    "ComplaintNote",
    "Attendance",
    "FinancialTransaction",
    "HostelBooking",
    "HostelProfileView",
    "SearchQuery",
]
from app.models.fee_structure_models import (
    # Hostel,
    FeePlan,
    SecurityDeposit,
    MessCharge,
    AdditionalService,
    FeeFrequency,
)
from app.models.payment_models import Invoice, Transaction, Receipt, RefundRequest
from app.models.payment_models import Customer, PaymentWebhook, Refund
from app.models.subscription import Payment

__all__ = [
    "Hostel",
    "Room",
    "FeePlan",
    "SecurityDeposit",
    "MessCharge",
    "AdditionalService",
    "FeeFrequency",
    "Invoice",
    "Transaction",
    "Receipt",
    "RefundRequest",
    "Customer",
    "Payment",
    "PaymentWebhook",
    "Refund",
]
 



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\models\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\admin_repository.py ---
from sqlalchemy.orm import Session
from sqlalchemy.sql import select
from typing import List, Optional
from app.models.admin import Admin, AdminHostelAssignment, PermissionLevel
from app.schemas.admin_schemas import AdminCreate, AdminHostelAssignmentCreate

class AdminRepository:
    def __init__(self, db: Session):
        self.db = db

    def create_admin(self, admin: AdminCreate) -> Admin:
        db_admin = Admin(**admin.model_dump())
        self.db.add(db_admin)
        self.db.commit()
        self.db.refresh(db_admin)
        return db_admin

    def get_admin(self, admin_id: int) -> Optional[Admin]:
        return self.db.query(Admin).filter(Admin.id == admin_id).first()

    def get_admin_by_email(self, email: str) -> Optional[Admin]:
        return self.db.query(Admin).filter(Admin.email == email).first()

    def get_all_admins(self) -> List[Admin]:
        return self.db.query(Admin).all()

    def update_admin(self, admin_id: int, admin_data: dict) -> Optional[Admin]:
        db_admin = self.get_admin(admin_id)
        if db_admin:
            for key, value in admin_data.items():
                setattr(db_admin, key, value)
            self.db.commit()
            self.db.refresh(db_admin)
        return db_admin

    def assign_hostel_to_admin(
        self, admin_id: int, assignment: AdminHostelAssignmentCreate
    ) -> AdminHostelAssignment:
        import logging
        logger = logging.getLogger(__name__)
        
        try:
            # Ensure permission_level is in lowercase string format
            permission = assignment.permission_level.value if hasattr(assignment.permission_level, 'value') else str(assignment.permission_level).lower()
            
            db_assignment = AdminHostelAssignment(
                admin_id=admin_id,
                hostel_id=assignment.hostel_id,
                permission_level=permission
            )
            logger.info(f"Creating assignment with permission level: {permission}")
            
            self.db.add(db_assignment)
            self.db.commit()
            self.db.refresh(db_assignment)
            return db_assignment
        except Exception as e:
            logger.error(f"Error in assign_hostel_to_admin: {str(e)}")
            self.db.rollback()
            raise

    def bulk_assign_hostels(
        self, admin_id: int, hostel_ids: List[int], permission_level: PermissionLevel
    ) -> List[AdminHostelAssignment]:
        import logging
        logger = logging.getLogger(__name__)
        
        # Convert permission_level to string value to match the database enum type
        permission = permission_level.value if hasattr(permission_level, 'value') else str(permission_level).lower()
        
        # Use native SQL with ON CONFLICT DO UPDATE to handle existing assignments
        from sqlalchemy import text
        assignments = []
        for hostel_id in hostel_ids:
            stmt = text("""
                INSERT INTO admin_hostel_assignments (admin_id, hostel_id, permission_level)
                VALUES (:admin_id, :hostel_id, :permission_level)
                ON CONFLICT (admin_id, hostel_id) 
                DO UPDATE SET permission_level = :permission_level
                RETURNING *;
            """)
            
            result = self.db.execute(
                stmt,
                {
                    "admin_id": admin_id,
                    "hostel_id": hostel_id,
                    "permission_level": permission
                }
            )
            row = result.fetchone()
            
            # Convert the row to an AdminHostelAssignment model
            assignment = AdminHostelAssignment(
                id=row.id,
                admin_id=row.admin_id,
                hostel_id=row.hostel_id,
                permission_level=row.permission_level,
                assigned_at=row.assigned_at
            )
            assignments.append(assignment)
        
        self.db.commit()
        return assignments

    def get_admin_hostel_assignments(self, admin_id: int) -> List[AdminHostelAssignment]:
        return (
            self.db.query(AdminHostelAssignment)
            .filter(AdminHostelAssignment.admin_id == admin_id)
            .all()
        )

    def update_hostel_permission(
        self, admin_id: int, hostel_id: int, permission_level: PermissionLevel
    ) -> Optional[AdminHostelAssignment]:
        assignment = (
            self.db.query(AdminHostelAssignment)
            .filter(
                AdminHostelAssignment.admin_id == admin_id,
                AdminHostelAssignment.hostel_id == hostel_id
            )
            .first()
        )
        if assignment:
            assignment.permission_level = permission_level
            self.db.commit()
            self.db.refresh(assignment)
        return assignment

    def remove_hostel_assignment(self, admin_id: int, hostel_id: int) -> bool:
        result = (
            self.db.query(AdminHostelAssignment)
            .filter(
                AdminHostelAssignment.admin_id == admin_id,
                AdminHostelAssignment.hostel_id == hostel_id
            )
            .delete()
        )
        self.db.commit()
        return result > 0

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\analytics_repositories.py ---
from sqlalchemy.orm import Session
from sqlalchemy import text

def get_hostel_occupancy_and_revenue(db: Session, hostel_id: int):
    """Call PostgreSQL stored procedure get_hostel_occupancy_and_revenue"""
    query = text("SELECT * FROM get_hostel_occupancy_and_revenue(:hostel_id)")
    result = db.execute(query, {"hostel_id": hostel_id}).fetchall()
    
    # Convert to list of dictionaries for easy JSON serialization
    return [{"occupancy_rate": row[0], "revenue": row[1]} for row in result]


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\announcement_repository.py ---
# app/repositories/announcement_repository.py
from typing import Optional, List
from sqlmodel import Session, select
from app.models.announcement import Announcement, AnnouncementStatus

class AnnouncementRepository:
    def __init__(self, session: Session):
        self.session = session

    def create(self, announcement: Announcement) -> Announcement:
        self.session.add(announcement)
        self.session.commit()
        self.session.refresh(announcement)
        return announcement

    def get(self, announcement_id: int) -> Optional[Announcement]:
        return self.session.get(Announcement, announcement_id)

    def update(self, announcement: Announcement) -> Announcement:
        self.session.add(announcement)
        self.session.commit()
        self.session.refresh(announcement)
        return announcement

    def delete(self, announcement: Announcement) -> None:
        self.session.delete(announcement)
        self.session.commit()

    def list_all(self, limit: int = 100, offset: int = 0) -> List[Announcement]:
        stmt = select(Announcement).order_by(Announcement.created_at.desc()).offset(offset).limit(limit)
        return list(self.session.execute(stmt).scalars())

    def list_published(self, limit: int = 100, offset: int = 0) -> List[Announcement]:
        stmt = select(Announcement).where(Announcement.status == AnnouncementStatus.PUBLISHED).order_by(Announcement.created_at.desc()).offset(offset).limit(limit)
        return list(self.session.execute(stmt).scalars())

    def list_scheduled_due(self):
        from datetime import datetime
        stmt = select(Announcement).where(Announcement.status == AnnouncementStatus.SCHEDULED, Announcement.scheduled_date <= datetime.utcnow())
        return list(self.session.execute(stmt).scalars())


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\approval_repository.py ---
"""
Approval request repository
"""
from sqlalchemy.orm import Session
from typing import Optional, List
from app.models.approval_request import ApprovalRequest, ApprovalStatus
from app.schemas.approval import ApprovalRequestCreate, ApprovalRequestUpdate


class ApprovalRepository:
    def __init__(self, db: Session):
        self.db = db
    
    def create(self, requester_id: int, approval_data: ApprovalRequestCreate) -> ApprovalRequest:
        """Create new approval request"""
        approval_request = ApprovalRequest(
            requester_id=requester_id,
            action=approval_data.action,
            resource_type=approval_data.resource_type,
            resource_id=approval_data.resource_id,
            hostel_id=approval_data.hostel_id,
            request_details=approval_data.request_details,
            threshold_level=approval_data.threshold_level,
            status=ApprovalStatus.PENDING.value
        )
        self.db.add(approval_request)
        self.db.commit()
        self.db.refresh(approval_request)
        return approval_request
    
    def get_by_id(self, approval_id: int) -> Optional[ApprovalRequest]:
        """Get approval request by ID"""
        return self.db.query(ApprovalRequest).filter(ApprovalRequest.id == approval_id).first()
    
    def get_pending_by_requester(self, requester_id: int) -> List[ApprovalRequest]:
        """Get pending approval requests for a requester"""
        return self.db.query(ApprovalRequest).filter(
            ApprovalRequest.requester_id == requester_id,
            ApprovalRequest.status == ApprovalStatus.PENDING.value
        ).order_by(ApprovalRequest.created_at.desc()).all()
    
    def get_pending_for_approver(self, approver_role_level: int, hostel_id: Optional[int] = None) -> List[ApprovalRequest]:
        """Get pending approval requests that approver can handle"""
        query = self.db.query(ApprovalRequest).filter(
            ApprovalRequest.status == ApprovalStatus.PENDING.value,
            ApprovalRequest.threshold_level <= approver_role_level
        )
        if hostel_id:
            query = query.filter(ApprovalRequest.hostel_id == hostel_id)
        return query.order_by(ApprovalRequest.created_at.desc()).all()
    
    def approve(self, approval_id: int, approver_id: int, notes: Optional[str] = None) -> Optional[ApprovalRequest]:
        """Approve a request"""
        approval = self.get_by_id(approval_id)
        if not approval or approval.status != ApprovalStatus.PENDING.value:
            return None
        
        from datetime import datetime
        approval.status = ApprovalStatus.APPROVED.value
        approval.approver_id = approver_id
        approval.approval_notes = notes
        approval.approved_at = datetime.utcnow()
        
        self.db.commit()
        self.db.refresh(approval)
        return approval
    
    def reject(self, approval_id: int, approver_id: int, notes: Optional[str] = None) -> Optional[ApprovalRequest]:
        """Reject a request"""
        approval = self.get_by_id(approval_id)
        if not approval or approval.status != ApprovalStatus.PENDING.value:
            return None
        
        from datetime import datetime
        approval.status = ApprovalStatus.REJECTED.value
        approval.approver_id = approver_id
        approval.approval_notes = notes
        approval.approved_at = datetime.utcnow()
        
        self.db.commit()
        self.db.refresh(approval)
        return approval



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\attendance_repository.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\audit_repository.py ---
"""
Insert/view audit logs
"""
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
from app.models.audit_log import AuditLog
from app.schemas.audit import AuditLogFilter


class AuditRepository:
    def __init__(self, db: Session):
        self.db = db
    
    def create_audit_log(
        self,
        user_id: int,
        action: str,
        resource: str,
        hostel_id: Optional[int] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        details: Optional[str] = None
    ) -> AuditLog:
        """Create audit log entry"""
        audit_log = AuditLog(
            user_id=user_id,
            hostel_id=hostel_id,
            action=action,
            resource=resource,
            ip_address=ip_address,
            user_agent=user_agent,
            details=details
        )
        self.db.add(audit_log)
        self.db.commit()
        self.db.refresh(audit_log)
        return audit_log
    
    def get_by_id(self, audit_id: int) -> Optional[AuditLog]:
        """Get audit log by ID"""
        return self.db.query(AuditLog).filter(AuditLog.id == audit_id).first()
    
    def get_all(
        self,
        skip: int = 0,
        limit: int = 100,
        filters: Optional[AuditLogFilter] = None
    ) -> List[AuditLog]:
        """Get audit logs with optional filters"""
        query = self.db.query(AuditLog)
        
        if filters:
            if filters.user_id:
                query = query.filter(AuditLog.user_id == filters.user_id)
            if filters.hostel_id:
                query = query.filter(AuditLog.hostel_id == filters.hostel_id)
            if filters.action:
                query = query.filter(AuditLog.action == filters.action)
            if filters.start_date:
                query = query.filter(AuditLog.created_at >= filters.start_date)
            if filters.end_date:
                query = query.filter(AuditLog.created_at <= filters.end_date)
        
        return query.order_by(AuditLog.created_at.desc()).offset(skip).limit(limit).all()
    
    def get_by_user(self, user_id: int, skip: int = 0, limit: int = 100) -> List[AuditLog]:
        """Get audit logs for a specific user"""
        return self.db.query(AuditLog).filter(
            AuditLog.user_id == user_id
        ).order_by(AuditLog.created_at.desc()).offset(skip).limit(limit).all()
    
    def get_by_hostel(self, hostel_id: int, skip: int = 0, limit: int = 100) -> List[AuditLog]:
        """Get audit logs for a specific hostel"""
        return self.db.query(AuditLog).filter(
            AuditLog.hostel_id == hostel_id
        ).order_by(AuditLog.created_at.desc()).offset(skip).limit(limit).all()

    def get_by_target(self, target_id: str, skip: int = 0, limit: int = 100) -> List[AuditLog]:
        """Search audit logs by a target identifier.

        This searches both the `resource` column and the `details` JSON/text blob
        for occurrences of the target_id. The search is a simple SQL LIKE match
        to keep implementation lightweight.
        """
        like_pattern = f"%{target_id}%"
        return self.db.query(AuditLog).filter(
            (AuditLog.resource.ilike(like_pattern)) | (AuditLog.details.ilike(like_pattern))
        ).order_by(AuditLog.created_at.desc()).offset(skip).limit(limit).all()



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\auth_repository.py ---
from sqlalchemy.orm import Session
from datetime import datetime
from app.models.user import User, OTP

# ----------- Users ----------
def get_user_by_email(db: Session, email: str):
    return db.query(User).filter(User.email == email).first()

def get_user_by_phone(db: Session, phone: str):
    return db.query(User).filter(User.phone == phone).first()

def get_user_by_id(db: Session, user_id: int):
    return db.query(User).filter(User.id == user_id).first()

def create_user(db: Session, *, name: str, email: str = None, phone: str = None, hashed_password: str = None):
    user = User(name=name, email=email, phone=phone, hashed_password=hashed_password)
    db.add(user)
    db.commit()
    db.refresh(user)
    return user

# ----------- OTP ----------
def create_otp(db: Session, user_id: int, otp_code: str, expires_at: datetime, email: str = None, phone: str = None):
    otp = OTP(user_id=user_id, otp_code=otp_code, expires_at=expires_at, email=email, phone=phone)
    db.add(otp)
    db.commit()
    db.refresh(otp)
    return otp

def get_valid_otp(db: Session, otp_code: str, email: str = None, phone: str = None):
    query = db.query(OTP).filter(
        OTP.otp_code == otp_code,
        OTP.is_used == False,
        OTP.expires_at >= datetime.utcnow()
    )
    if email:
        query = query.filter(OTP.email == email)
    if phone:
        query = query.filter(OTP.phone == phone)
    return query.first()

def invalidate_user_otps(db: Session, user_id: int):
    db.query(OTP).filter(OTP.user_id == user_id, OTP.is_used == False).update({"is_used": True})
    db.commit()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\base_repository.py ---
"""
Base repository with automatic hostel filtering
"""
from typing import Optional, List
from sqlalchemy.orm import Session
from sqlalchemy import Column, Integer
from app.core.roles import Role


class BaseRepository:
    """Base repository with automatic tenant filtering"""
    
    def __init__(self, db: Session, user_role: Optional[str] = None, active_hostel_id: Optional[int] = None, user_hostel_ids: Optional[List[int]] = None):
        self.db = db
        self.user_role = user_role
        self.active_hostel_id = active_hostel_id
        self.user_hostel_ids = user_hostel_ids
    
    def _apply_hostel_filter(self, query, hostel_column: Column):
        """Apply hostel filter to query based on user role and access"""
        # Superadmin bypass
        if self.user_role == Role.SUPERADMIN:
            return query
        
        # If active_hostel_id is set, filter by it
        if self.active_hostel_id:
            return query.filter(hostel_column == self.active_hostel_id)
        
        # If user has assigned hostels (admin), filter by those
        if self.user_hostel_ids:
            return query.filter(hostel_column.in_(self.user_hostel_ids))
        
        # No filter applied (shouldn't happen in normal flow)
        return query
    
    def _validate_hostel_access(self, hostel_id: int) -> bool:
        """Validate if user has access to a specific hostel"""
        # Superadmin has access to all
        if self.user_role == Role.SUPERADMIN:
            return True
        
        # Check if hostel_id is in user's accessible hostels
        if self.user_hostel_ids:
            return hostel_id in self.user_hostel_ids
        
        # Check active hostel
        if self.active_hostel_id:
            return hostel_id == self.active_hostel_id
        
        return False



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\bed_repository.py ---
from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import exc as sa_exc

from app.models.beds import Bed, BedStatus
from app.models.students import Student
from app.schemas.beds import BedCreate, BedUpdate


def create_bed(db: Session, bed_in: BedCreate) -> Bed:
    obj = Bed(**bed_in.dict())
    db.add(obj)
    try:
        db.commit()
        db.refresh(obj)
        return obj
    except sa_exc.ProgrammingError as e:
        db.rollback()
        raise RuntimeError("Database schema not initialized: " + str(e))
    except sa_exc.IntegrityError as e:
        db.rollback()
        raise ValueError("Integrity error: " + str(e))
    except Exception:
        db.rollback()
        raise


def get_bed(db: Session, bed_id: int) -> Optional[Bed]:
    return db.query(Bed).filter(Bed.id == bed_id).first()


def list_beds(db: Session, skip: int = 0, limit: int = 100) -> List[Bed]:
    return db.query(Bed).offset(skip).limit(limit).all()


def list_available_beds(db: Session, room_number: Optional[str] = None, skip: int = 0, limit: int = 100) -> List[Bed]:
    query = db.query(Bed).filter(Bed.bed_status == BedStatus.AVAILABLE)
    if room_number:
        query = query.filter(Bed.room_number == room_number)
    return query.order_by(Bed.room_number, Bed.bed_number).offset(skip).limit(limit).all()


def find_bed_by_room_and_bed_number(db: Session, room_number: str, bed_number: str) -> Optional[Bed]:
    return db.query(Bed).filter(
        Bed.room_number == room_number,
        Bed.bed_number == bed_number
    ).first()


def update_bed(db: Session, bed: Bed, bed_in: BedUpdate) -> Bed:
    for field, value in bed_in.dict(exclude_unset=True).items():
        setattr(bed, field, value)
    db.add(bed)
    db.commit()
    db.refresh(bed)
    return bed


def delete_bed(db: Session, bed: Bed) -> None:
    db.delete(bed)
    db.commit()


def assign_bed_to_student(db: Session, bed: Bed, student_id: str) -> Bed:
    bed.bed_status = BedStatus.OCCUPIED
    db.add(bed)

    student = db.query(Student).filter(Student.student_id == student_id).first()
    if not student:
        raise ValueError("Student not found")

    student.room_assignment = bed.room_number
    student.bed_assignment = bed.bed_number
    db.add(student)

    db.commit()
    db.refresh(bed)
    return bed


def release_bed(db: Session, bed: Bed) -> Bed:
    bed.bed_status = BedStatus.AVAILABLE
    db.add(bed)

    db.query(Student).filter(
        Student.room_assignment == bed.room_number,
        Student.bed_assignment == bed.bed_number
    ).update({
        Student.room_assignment: None,
        Student.bed_assignment: None
    })

    db.commit()
    db.refresh(bed)
    return bed


def transfer_student_to_bed(db: Session, student_id: str, new_bed: Bed) -> Bed:
    student = db.query(Student).filter(Student.student_id == student_id).first()
    if not student:
        raise ValueError("Student not found")

    if student.room_assignment and student.bed_assignment:
        old_bed = find_bed_by_room_and_bed_number(db, student.room_assignment, student.bed_assignment)
        if old_bed:
            old_bed.bed_status = BedStatus.AVAILABLE
            db.add(old_bed)

    new_bed.bed_status = BedStatus.OCCUPIED
    db.add(new_bed)

    student.room_assignment = new_bed.room_number
    student.bed_assignment = new_bed.bed_number
    db.add(student)

    db.commit()
    db.refresh(new_bed)
    return new_bed


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\booking_repository.py ---
from sqlalchemy.orm import Session
from sqlalchemy import and_

from app.models.booking import Booking
from app.schemas.booking import BookingCreate, BookingUpdate


class BookingRepository:

    @staticmethod
    def create(db: Session, data: BookingCreate) -> Booking:
        booking = Booking(
            visitor_id=data.visitor_id,
            hostel_id=data.hostel_id,
            room_id=data.room_id,
            check_in=data.check_in,
            check_out=data.check_out,

            # ⭐ REQUIRED FIELDS ADDED
            amount_paid=data.amount_paid,        # <-- required
            status="pending"                     # <-- required
        )
        db.add(booking)

        # ⭐ REQUIRED COMMIT + REFRESH (must be here)
        db.commit()
        db.refresh(booking)

        return booking

    @staticmethod
    def get_by_id(db: Session, booking_id: int) -> Booking | None:
        return db.query(Booking).filter(Booking.id == booking_id).first()

    # ✅ REQUIRED: Overlapping date check
    @staticmethod
    def check_overlap(db: Session, room_id: int, check_in, check_out) -> Booking | None:
        """
        Returns a booking if there is an overlap.
        Used in modify booking (not in create booking anymore).
        """
        return (
            db.query(Booking)
            .filter(
                Booking.room_id == room_id,
                Booking.check_in < check_out,
                Booking.check_out > check_in,
            )
            .first()
        )

    @staticmethod
    def update(db: Session, booking: Booking, updates: BookingUpdate):
        """
        Update booking with partial fields.
        """
        if updates.check_in is not None:
            booking.check_in = updates.check_in

        if updates.check_out is not None:
            booking.check_out = updates.check_out

        if updates.room_id is not None:
            booking.room_id = updates.room_id

        db.commit()
        db.refresh(booking)
        return booking

    # Optional: used in calendar API
    @staticmethod
    def get_calendar(db: Session, hostel_id: int):
        return (
            db.query(Booking)
            .filter(Booking.hostel_id == hostel_id)
            .all()
        )


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\comparison_repository.py ---
from typing import List
from sqlalchemy.orm import Session
from sqlalchemy import func

from app.models.rooms import Room
from app.models.beds import Bed, BedStatus


def get_hostel_comparison(db: Session, hostel_ids: List[str]) -> List[dict]:
    if not hostel_ids:
        return []

    pricing_rows = (
        db.query(
            Room.hostel_id.label("hostel_id"),
            func.min(Room.monthly_price).label("monthly_min"),
            func.avg(Room.monthly_price).label("monthly_avg"),
            func.max(Room.monthly_price).label("monthly_max"),
            func.min(Room.quarterly_price).label("quarterly_min"),
            func.avg(Room.quarterly_price).label("quarterly_avg"),
            func.max(Room.quarterly_price).label("quarterly_max"),
            func.min(Room.annual_price).label("annual_min"),
            func.avg(Room.annual_price).label("annual_avg"),
            func.max(Room.annual_price).label("annual_max"),
            func.count(Room.id).label("rooms_count"),
        )
        .filter(Room.hostel_id.in_(hostel_ids))
        .group_by(Room.hostel_id)
        .all()
    )

    pricing_map = {r.hostel_id: dict(r._mapping) for r in pricing_rows}

    amenities_map: dict[str, set[str]] = {hid: set() for hid in hostel_ids}
    amen_rows = db.query(Room.hostel_id, Room.amenities).filter(Room.hostel_id.in_(hostel_ids)).all()

    for hid, amen in amen_rows:
        if amen and hid in amenities_map:  # Ensure the hostel_id exists in the map
            parts = [a.strip() for a in amen.split(",") if a.strip()]
            amenities_map[hid].update(parts)

    bed_counts = (
        db.query(Bed.hostel_id, func.count(Bed.id))
        .filter(Bed.hostel_id.in_(hostel_ids))
        .group_by(Bed.hostel_id)
        .all()
    )
    bed_count_map = {hid: cnt for hid, cnt in bed_counts}

    available_beds = (
        db.query(Bed.hostel_id, func.count(Bed.id))
        .filter(
            Bed.hostel_id.in_(hostel_ids),
            Bed.bed_status == BedStatus.AVAILABLE
        )
        .group_by(Bed.hostel_id)
        .all()
    )
    available_beds_map = {hid: cnt for hid, cnt in available_beds}

    results = []

    for hid in hostel_ids:
        p = pricing_map.get(hid, {})

        results.append({
            "hostel_id": str(hid),  # Ensure hostel_id is returned as a string
            "pricing": {
                "monthly_min": p.get("monthly_min"),
                "monthly_avg": float(p.get("monthly_avg")) if p.get("monthly_avg") else None,
                "monthly_max": p.get("monthly_max"),
                "quarterly_min": p.get("quarterly_min"),
                "quarterly_avg": float(p.get("quarterly_avg")) if p.get("quarterly_avg") else None,
                "quarterly_max": p.get("quarterly_max"),
                "annual_min": p.get("annual_min"),
                "annual_avg": float(p.get("annual_avg")) if p.get("annual_avg") else None,
                "annual_max": p.get("annual_max"),
            },
            "amenities": sorted(list(amenities_map.get(hid, set()))),
            "location": None,
            "rooms_count": int(p.get("rooms_count") or 0),
            "beds_count": int(bed_count_map.get(hid, 0)),
            "available_beds": int(available_beds_map.get(hid, 0)),
        })

    return results


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\complaint_repository.py ---
from sqlalchemy.future import select
from sqlalchemy import func, and_
from app.models.complaint import Complaint, ComplaintAttachment, ComplaintNote
from typing import Optional, List, Tuple
from datetime import datetime


class ComplaintRepository:
    def __init__(self, db):
        self.db = db

    # -------------------------------------------------------------------------
    # CRUD OPERATIONS
    # -------------------------------------------------------------------------
    async def create(self, data: dict) -> Complaint:
        complaint = Complaint(**data)
        self.db.add(complaint)
        self.db.commit()
        self.db.refresh(complaint)
        return complaint

    async def get_by_id(self, complaint_id: int) -> Optional[Complaint]:
        result = self.db.execute(select(Complaint).where(Complaint.id == complaint_id))
        return result.scalar_one_or_none()

    async def get_with_details(self, complaint_id: int):
        """Get complaint along with attachments and notes"""
        result = self.db.execute(select(Complaint).where(Complaint.id == complaint_id))
        complaint = result.scalar_one_or_none()
        if not complaint:
            return None

        attachments_result = self.db.execute(
            select(ComplaintAttachment).where(ComplaintAttachment.complaint_id == complaint_id)
        )
        notes_result = self.db.execute(
            select(ComplaintNote).where(ComplaintNote.complaint_id == complaint_id)
        )

        return {
            "complaint": complaint,
            "attachments": attachments_result.scalars().all(),
            "notes": notes_result.scalars().all(),
        }

    async def update(self, complaint_id: int, updates: dict):
        complaint = await self.get_by_id(complaint_id)
        if not complaint:
            return None
        for key, value in updates.items():
            setattr(complaint, key, value)
        self.db.commit()
        self.db.refresh(complaint)
        return complaint

    async def update_fields(self, complaint_id: int, data):
        updates = data if isinstance(data, dict) else data.dict(exclude_unset=True)
        return await self.update(complaint_id, updates)

    # -------------------------------------------------------------------------
    # FILTERING / LISTING
    # -------------------------------------------------------------------------
    async def list(self, filters) -> Tuple[List[Complaint], int]:
        query = select(Complaint)

        if filters.hostel_name:
            query = query.where(Complaint.hostel_name.ilike(f"%{filters.hostel_name}%"))
        if filters.category:
            query = query.where(Complaint.category == filters.category)
        if filters.status:
            query = query.where(Complaint.status == filters.status)
        if filters.student_email:
            query = query.where(Complaint.student_email == filters.student_email)
        if filters.assigned_to_email:
            query = query.where(Complaint.assigned_to_email == filters.assigned_to_email)

        result_total = self.db.execute(query)
        total_list = result_total.scalars().unique().all()
        total = len(total_list)
        query = query.offset((filters.page - 1) * filters.page_size).limit(filters.page_size)

        result = self.db.execute(query.order_by(Complaint.created_at.desc()))
        return result.scalars().all(), total

    # -------------------------------------------------------------------------
    # ATTACHMENTS & NOTES
    # -------------------------------------------------------------------------
    async def add_attachment(
        self, complaint_id: int, uploaded_by: str,
        file_path: str, file_name: str, file_type: str, file_size: int
    ):
        attachment = ComplaintAttachment(
            complaint_id=complaint_id,
            file_path=file_path,
            file_name=file_name,
            file_type=file_type,
            file_size=file_size,
            uploaded_by=uploaded_by
        )
        self.db.add(attachment)
        self.db.commit()
        self.db.refresh(attachment)
        return attachment

    async def add_note(
        self, complaint_id: int, note: str, user_name: str,
        user_email: str, is_internal: bool
    ):
        note_obj = ComplaintNote(
            complaint_id=complaint_id,
            note=note,
            user_name=user_name,
            user_email=user_email,
            is_internal=is_internal
        )
        self.db.add(note_obj)
        self.db.commit()
        self.db.refresh(note_obj)
        return note_obj

    # -------------------------------------------------------------------------
    # ANALYTICS
    # -------------------------------------------------------------------------
    async def get_performance(
        self, supervisor_email: str,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ):
        query = select(Complaint).where(Complaint.assigned_to_email == supervisor_email)
        if start_date:
            query = query.where(Complaint.created_at >= start_date)
        if end_date:
            query = query.where(Complaint.created_at <= end_date)

        result = self.db.execute(query)
        complaints = result.scalars().all()

        resolved = [c for c in complaints if c.status == "resolved"]
        avg_time = None
        if resolved:
            avg_time = sum(
                (c.resolved_at - c.created_at).total_seconds() for c in resolved if c.resolved_at
            ) / len(resolved) / 3600

        return {
            "supervisor_email": supervisor_email,
            "total_complaints": len(complaints),
            "resolved_complaints": len(resolved),
            "average_resolution_time_hours": round(avg_time, 2) if avg_time else None,
        }

    async def get_analytics(
        self,
        hostel_name: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ):
        query = select(Complaint)
        if hostel_name:
            query = query.where(Complaint.hostel_name.ilike(f"%{hostel_name}%"))
        if start_date:
            query = query.where(Complaint.created_at >= start_date)
        if end_date:
            query = query.where(Complaint.created_at <= end_date)

        result = self.db.execute(query)
        complaints = result.scalars().all()

        total = len(complaints)
        category_counts = {}
        status_counts = {}

        for c in complaints:
            category_counts[c.category.value] = category_counts.get(c.category.value, 0) + 1
            status_counts[c.status.value] = status_counts.get(c.status.value, 0) + 1

        return {
            "total_complaints": total,
            "category_distribution": category_counts,
            "status_distribution": status_counts,
        }

    @staticmethod
    def get_statistics(db, hostel_ids, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None):
        """Return aggregated complaint statistics for the given hostel ids and date range.

        Note: complaints are linked to hostels by `hostel_name` in this schema,
        so we look up hostel names for the provided ids and filter complaints by name.
        """
        from app.models.complaint import Complaint
        from app.models.hostel import Hostel

        # Map hostel ids to hostel names
        hostel_names = []
        if hostel_ids:
            hostels = db.query(Hostel).filter(Hostel.id.in_(hostel_ids)).all()
            hostel_names = [h.hostel_name for h in hostels]

        query = db.query(Complaint)
        if hostel_names:
            query = query.filter(Complaint.hostel_name.in_(hostel_names))
        if start_date:
            query = query.filter(Complaint.created_at >= start_date)
        if end_date:
            query = query.filter(Complaint.created_at <= end_date)

        complaints = query.all()

        total = len(complaints)
        resolved_list = [c for c in complaints if c.resolved_at]
        resolved = len(resolved_list)

        avg_hours = 0.0
        if resolved_list:
            avg_hours = sum((c.resolved_at - c.created_at).total_seconds() for c in resolved_list) / len(resolved_list) / 3600
            avg_hours = round(avg_hours, 2)

        # Average student rating where available
        ratings = [c.student_rating for c in complaints if c.student_rating is not None]
        avg_rating = round(sum(ratings) / len(ratings), 2) if ratings else 0.0

        return {
            'total': total,
            'resolved': resolved,
            'average_resolution_hours': avg_hours,
            'average_rating': avg_rating
        }


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\fee_structure_repositorys.py ---
from sqlalchemy.orm import Session
from app import models

class FeeStructureRepository:
    def __init__(self, db: Session):
        self.db = db

    def create(self, model, data):
        obj = model(**data.dict())
        self.db.add(obj)
        self.db.commit()
        self.db.refresh(obj)
        return obj

    def list(self, model):
        return self.db.query(model).all()

    def get(self, model, id: int):
        return self.db.query(model).filter(model.id == id).first()

    def delete(self, model, id: int):
        obj = self.get(model, id)
        if obj:
            self.db.delete(obj)
            self.db.commit()
            return True
        return False


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\hostel_repository.py ---
# from sqlalchemy.orm import Session
# from sqlalchemy import text
# from sqlalchemy.exc import SQLAlchemyError, IntegrityError
# from typing import Optional, List, Dict, Any
# from app.schemas.super_admin_schemas import HostelUpsert
# from app.models.hostel import Hostel
# import logging

# logger = logging.getLogger(__name__)

# class HostelRepository:
#     @staticmethod
#     def upsert_hostel(db: Session, hostel: HostelUpsert) -> Optional[Dict[str, Any]]:
#         """
#         Insert or update a hostel using ORM (avoids DB function dependency).
#         Returns the upserted hostel as a dict.
#         """
#         try:
#             if hostel.id:
#                 # Update existing hostel
#                 existing = db.query(Hostel).filter(Hostel.id == hostel.id).first()
#                 if existing:
#                     for key, value in hostel.dict(exclude_unset=True).items():
#                         if key != 'id':
#                             setattr(existing, key, value)
#                     db.commit()
#                     db.refresh(existing)
#                     result = existing
#                 else:
#                     # ID provided but hostel doesn't exist; treat as insert
#                     result = Hostel(**hostel.dict(exclude_unset=True, exclude={'id'}))
#                     db.add(result)
#                     db.commit()
#                     db.refresh(result)
#             else:
#                 # Insert new hostel
#                 result = Hostel(**hostel.dict(exclude_unset=True, exclude={'id'}))
#                 db.add(result)
#                 db.commit()
#                 db.refresh(result)
            
#             # Return as dict matching the schema
#             return {
#                 'id': result.id,
#                 'hostel_name': result.hostel_name,
#                 'description': result.description,
#                 'full_address': result.full_address,
#                 'hostel_type': result.hostel_type,
#                 'contact_email': result.contact_email,
#                 'contact_phone': result.contact_phone,
#                 'amenities': result.amenities,
#                 'rules': result.rules,
#                 'check_in': result.check_in,
#                 'check_out': result.check_out,
#                 'total_beds': result.total_beds,
#                 'current_occupancy': result.current_occupancy,
#                 'monthly_revenue': result.monthly_revenue,
#                 'visibility': result.visibility,
#                 'is_featured': result.is_featured,
#                 'created_at': result.created_at,
#                 'location_id': result.location_id,
#             }
#         except IntegrityError as e:
#             db.rollback()
#             logger.error(f'Integrity error during upsert: {e}')
#             raise ValueError('Integrity error during upsert')
#         except SQLAlchemyError as e:
#             db.rollback()
#             logger.error(f'Database error during upsert: {e}')
#             raise

#     @staticmethod
#     def get_all_hostels(db: Session, skip: int = 0, limit: int = 100):
#         q = text('SELECT * FROM hostels ORDER BY id DESC LIMIT :limit OFFSET :skip;')
#         r = db.execute(q, {'limit': limit, 'skip': skip})
#         return r.mappings().all()

#     @staticmethod
#     def get_total_hostels_count(db: Session) -> int:
#         r = db.execute(text('SELECT COUNT(*) FROM hostels;'))
#         return r.scalar() or 0

#     @staticmethod
#     def get_hostel_by_id(db: Session, hostel_id: int):
#         r = db.execute(text('SELECT * FROM hostels WHERE id = :id;'), {'id': hostel_id})
#         return r.mappings().first()

#     @staticmethod
#     def delete_hostel(db: Session, hostel_id: int):
#         try:
#             r = db.execute(text('DELETE FROM hostels WHERE id = :id RETURNING id;'), {'id': hostel_id})
#             deleted = r.scalar()
#             if deleted:
#                 db.commit()
#             else:
#                 db.rollback()
#             return deleted
#         except IntegrityError:
#             db.rollback()
#             raise ValueError('Cannot delete hostel with related records')
#         except SQLAlchemyError:
#             db.rollback()
#             raise

#     @staticmethod
#     def search_hostels(db: Session, search_term: str, skip: int = 0, limit: int = 100):
#         q = text("""
#             SELECT h.*, l.city FROM hostels h
#             LEFT JOIN locations l ON h.location_id = l.id
#             WHERE h.hostel_name ILIKE :s OR h.full_address ILIKE :s OR l.city ILIKE :s
#             ORDER BY h.id DESC LIMIT :limit OFFSET :skip;
#         """)
#         r = db.execute(q, {'s': f'%{search_term}%', 'limit': limit, 'skip': skip})
#         return r.mappings().all()
from sqlalchemy.orm import Session
from sqlalchemy import text
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from typing import Optional, List, Dict, Any
from app.schemas.super_admin_schemas import HostelUpsert
from app.models.hostel import Hostel
from app.models.admin_hostel_mapping import AdminHostelMapping
import logging

logger = logging.getLogger(__name__)

class HostelRepository:
    def __init__(self, db: Session):
        """Store DB session for use in repository methods."""
        self.db = db

    def upsert_hostel(self, hostel: HostelUpsert) -> Optional[Dict[str, Any]]:
        """Insert or update hostel (ORM-based)."""
        db = self.db
        try:
            if hostel.id:
                existing = db.query(Hostel).filter(Hostel.id == hostel.id).first()
                if existing:
                    for key, value in hostel.dict(exclude_unset=True).items():
                        if key != 'id':
                            setattr(existing, key, value)
                    db.commit()
                    db.refresh(existing)
                    result = existing
                else:
                    result = Hostel(**hostel.dict(exclude_unset=True, exclude={'id'}))
                    db.add(result)
                    db.commit()
                    db.refresh(result)
            else:
                result = Hostel(**hostel.dict(exclude_unset=True, exclude={'id'}))
                db.add(result)
                db.commit()
                db.refresh(result)

            return result.__dict__

        except IntegrityError as e:
            db.rollback()
            # Provide a clearer message for common FK violations (e.g., invalid location_id)
            msg = str(e.orig) if hasattr(e, 'orig') else str(e)
            logger.error(f'Integrity error during upsert: {msg}')
            if 'foreign key' in msg.lower() or 'violates foreign key constraint' in msg.lower():
                raise ValueError('Integrity error during upsert: invalid foreign key (check location_id)')
            raise ValueError(f'Integrity error during upsert: {msg}')
        except SQLAlchemyError as e:
            db.rollback()
            logger.error(f'Database error during upsert: {e}')
            raise

    def get_all_hostels(self, skip: int = 0, limit: int = 100):
        db = self.db
        q = text('SELECT * FROM hostels ORDER BY id DESC LIMIT :limit OFFSET :skip;')
        r = db.execute(q, {'limit': limit, 'skip': skip})
        return r.mappings().all()

    # Compatibility method expected by services: return ORM objects
    def get_all(self, skip: int = 0, limit: int = 100):
        db = self.db
        return db.query(Hostel).order_by(Hostel.id.desc()).offset(skip).limit(limit).all()

    def get_total_hostels_count(self) -> int:
        db = self.db
        r = db.execute(text('SELECT COUNT(*) FROM hostels;'))
        return r.scalar() or 0

    def get_hostel_by_id(self, hostel_id: int):
        db = self.db
        r = db.execute(text('SELECT * FROM hostels WHERE id = :id;'), {'id': hostel_id})
        return r.mappings().first()

    # Compatibility: return ORM object
    def get_by_id(self, hostel_id: int):
        db = self.db
        return db.query(Hostel).filter(Hostel.id == hostel_id).first()

    def delete_hostel(self, hostel_id: int):
        db = self.db
        try:
            r = db.execute(text('DELETE FROM hostels WHERE id = :id RETURNING id;'), {'id': hostel_id})
            deleted = r.scalar()
            if deleted:
                db.commit()
            else:
                db.rollback()
            return deleted
        except IntegrityError:
            db.rollback()
            raise ValueError('Cannot delete hostel with related records')
        except SQLAlchemyError:
            db.rollback()
            raise

    def search_hostels(self, search_term: str, skip: int = 0, limit: int = 100):
        db = self.db
        q = text("""
            SELECT h.*, l.city FROM hostels h
            LEFT JOIN locations l ON h.location_id = l.id
            WHERE h.hostel_name ILIKE :s OR h.full_address ILIKE :s OR l.city ILIKE :s
            ORDER BY h.id DESC LIMIT :limit OFFSET :skip;
        """)
        r = db.execute(q, {'s': f'%{search_term}%', 'limit': limit, 'skip': skip})
        return r.mappings().all()

    def get_by_admin(self, admin_id: int):
        db = self.db
        # Join AdminHostelMapping to fetch Hostel ORM objects for given admin
        return db.query(Hostel).join(AdminHostelMapping, Hostel.id == AdminHostelMapping.hostel_id).filter(AdminHostelMapping.admin_id == admin_id).all()

    def assign_admin(self, admin_id: int, hostel_id: int):
        db = self.db
        # Idempotent assign: do nothing if mapping exists
        existing = db.query(AdminHostelMapping).filter(AdminHostelMapping.admin_id == admin_id, AdminHostelMapping.hostel_id == hostel_id).first()
        if existing:
            return existing
        mapping = AdminHostelMapping(admin_id=admin_id, hostel_id=hostel_id)
        db.add(mapping)
        try:
            db.commit()
            db.refresh(mapping)
            return mapping
        except IntegrityError:
            db.rollback()
            # Race or constraint: try to return existing mapping
            return db.query(AdminHostelMapping).filter(AdminHostelMapping.admin_id == admin_id, AdminHostelMapping.hostel_id == hostel_id).first()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\invoice_repositorys.py ---
# # app/repositories/invoice_repository.py
# from sqlalchemy.orm import Session
# from typing import Optional
# from app.models.payment_models import Invoice
# from datetime import datetime

# class InvoiceRepository:
#     """Data access layer for invoice operations"""
    
#     def __init__(self, db: Session):
#         self.db = db
    
#     def get_by_id(self, invoice_id: int) -> Optional[Invoice]:
#         """Fetch invoice by ID"""
#         return self.db.query(Invoice).filter(Invoice.id == invoice_id).first()
    
#     def update_payment_status(self, invoice: Invoice, paid_amount: float, due_amount: float, status: str):
#         """Update invoice payment details"""
#         invoice.paid_amount = paid_amount
#         invoice.due_amount = due_amount
#         invoice.status = status
#         invoice.updated_at = datetime.utcnow()
#         self.db.flush()
#         return invoice


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\ledger_repositorys.py ---
# from sqlalchemy.orm import Session
# from sqlalchemy import func, extract
# from typing import List, Optional, Dict
# from datetime import date
# from app.models.fee_structure_models import Hostel
# from app.models.payment_models import Transaction, Invoice, Customer

# class LedgerRepository:
#     def __init__(self, db: Session):
#         self.db = db

#     def get_complete_transaction_history(
#         self,
#         start_date: Optional[date],
#         end_date: Optional[date],
#         hostel_id: Optional[int],
#         user_id: Optional[int],     # 🔥 Changed
#         transaction_type: Optional[str],
#         limit: int,
#         offset: int
#     ):
#         query = self.db.query(Transaction).join(Invoice)

#         if start_date:
#             query = query.filter(Transaction.created_at >= start_date)

#         if end_date:
#             query = query.filter(Transaction.created_at <= end_date)

#         if hostel_id:
#             query = query.filter(Invoice.hostel_id == hostel_id)

#         if user_id:
#             query = query.filter(Invoice.user_id == user_id)   # 🔥 Changed

#         if transaction_type:
#             query = query.filter(Transaction.transaction_type == transaction_type)

#         total = query.count()
#         rows = query.order_by(Transaction.created_at.desc()).limit(limit).offset(offset).all()
#         return rows, total

#     def get_outstanding_payments(self, hostel_id: Optional[int], overdue_only: bool):
#         query = self.db.query(Invoice).filter(Invoice.due_amount > 0)

#         if hostel_id:
#             query = query.filter(Invoice.hostel_id == hostel_id)

#         if overdue_only:
#             query = query.filter(Invoice.due_date < date.today())

#         return query.order_by(Invoice.due_date).all()

#     def get_user_ledger(self, user_id: int):   # 🔥 Renamed from get_student_ledger
#         user = self.db.query(Customer).filter(Customer.id == user_id).first()
#         if not user:
#             return None

#         invoices = self.db.query(Invoice).filter(Invoice.user_id == user_id).all()

#         return {
#             "user": user,
#             "invoices": invoices,
#             "summary": {
#                 "total_billed": sum(i.total_amount for i in invoices),
#                 "total_paid": sum(i.paid_amount for i in invoices),
#                 "total_outstanding": sum(i.due_amount for i in invoices),
#             }
#         }


# class ReportRepository:
#     def __init__(self, db: Session):
#         self.db = db

#     def get_revenue_by_hostel(self, start_date, end_date):
#         query = self.db.query(
#             Hostel.id,
#             Hostel.name,
#             # Hostel.code,
#             func.sum(Invoice.total_amount).label("total_billed"),
#             func.sum(Invoice.paid_amount).label("total_collected"),
#             func.sum(Invoice.due_amount).label("total_outstanding")
#         ).join(Invoice)

#         if start_date:
#             query = query.filter(Invoice.created_at >= start_date)
#         if end_date:
#             query = query.filter(Invoice.created_at <= end_date)

#         query = query.group_by(Hostel.id, Hostel.name, Hostel.name)
#         rows = query.all()

#         return [
#             {
#                 "hostel_id": r.id,
#                 "hostel_name": r.name,
#                 # "hostel_code": r.code,
#                 "total_billed": float(r.total_billed or 0),
#                 "total_collected": float(r.total_collected or 0),
#                 "total_outstanding": float(r.total_outstanding or 0),
#             }
#             for r in rows
#         ]
from sqlalchemy.orm import Session
from sqlalchemy import func, extract
from typing import Optional
from datetime import date

from app.models.hostel import Hostel
from app.models.payment_models import Transaction, Invoice, Customer


class LedgerRepository:
    def __init__(self, db: Session):
        self.db = db

    def get_complete_transaction_history(
        self,
        start_date: Optional[date],
        end_date: Optional[date],
        hostel_id: Optional[int],
        user_id: Optional[int],
        transaction_type: Optional[str],
        limit: int,
        offset: int
    ):
        query = self.db.query(Transaction).join(Invoice)

        if start_date:
            query = query.filter(Transaction.created_at >= start_date)

        if end_date:
            query = query.filter(Transaction.created_at <= end_date)

        if hostel_id:
            query = query.filter(Invoice.hostel_id == hostel_id)

        if user_id:
            query = query.filter(Invoice.user_id == user_id)

        if transaction_type:
            query = query.filter(Transaction.transaction_type == transaction_type)

        total = query.count()
        rows = (
            query.order_by(Transaction.created_at.desc())
                 .limit(limit)
                 .offset(offset)
                 .all()
        )

        return rows, total

    def get_outstanding_payments(self, hostel_id: Optional[int], overdue_only: bool):
        query = self.db.query(Invoice).filter(Invoice.due_amount > 0)

        if hostel_id:
            query = query.filter(Invoice.hostel_id == hostel_id)

        if overdue_only:
            query = query.filter(Invoice.due_date < date.today())

        return query.order_by(Invoice.due_date).all()

    def get_user_ledger(self, user_id: int):
        user = self.db.query(Customer).filter(Customer.id == user_id).first()
        if not user:
            return None

        invoices = self.db.query(Invoice).filter(Invoice.user_id == user_id).all()

        return {
            "user": user,
            "invoices": invoices,
            "summary": {
                "total_billed": sum(invoice.total_amount for invoice in invoices),
                "total_paid": sum(invoice.paid_amount for invoice in invoices),
                "total_outstanding": sum(invoice.due_amount for invoice in invoices),
            }
        }


# class ReportRepository:
#     def __init__(self, db: Session):
#         self.db = db

#     def get_revenue_by_hostel(self, start_date, end_date):
#         query = self.db.query(
#             Hostel.id,
#             Hostel.name,
#             func.sum(Invoice.total_amount).label("total_billed"),
#             func.sum(Invoice.paid_amount).label("total_collected"),
#             func.sum(Invoice.due_amount).label("total_outstanding"),
#         ).join(Invoice)

#         if start_date:
#             query = query.filter(Invoice.created_at >= start_date)

#         if end_date:
#             query = query.filter(Invoice.created_at <= end_date)

#         query = query.group_by(Hostel.id, Hostel.name)
#         rows = query.all()

#         return [
#             {
#                 "hostel_id": r.id,
#                 "hostel_name": r.name,
#                 "total_billed": float(r.total_billed or 0),
#                 "total_collected": float(r.total_collected or 0),
#                 "total_outstanding": float(r.total_outstanding or 0),
#             }
#             for r in rows
#         ]

#     # ------------------------------------------------------------
#     # 📌 Monthly Revenue Report (Correctly inside the class)
#     # ------------------------------------------------------------
#     def get_monthly_revenue_report(self, year: int, hostel_id: int = None):
#         query = self.db.query(
#             extract("month", Invoice.created_at).label("month"),
#             func.sum(Invoice.total_amount).label("total_billed"),
#             func.sum(Invoice.paid_amount).label("total_collected"),
#             func.count(Invoice.id).label("invoice_count"),
#         ).filter(extract("year", Invoice.created_at) == year)

#         if hostel_id:
#             query = query.filter(Invoice.hostel_id == hostel_id)

#         query = query.group_by("month").order_by("month")
#         rows = query.all()

#         return [
#             {
#                 "month": int(r.month),
#                 "total_billed": float(r.total_billed or 0),
#                 "total_collected": float(r.total_collected or 0),
#                 "invoice_count": r.invoice_count,
#                 "collection_rate": (
#                     (float(r.total_collected or 0) / float(r.total_billed or 1)) * 100
#                 ),
#             }
#             for r in rows
#         ]
    

#     # You can add: get_payment_method_breakdown() here if needed
class ReportRepository:
    def __init__(self, db: Session):
        self.db = db

    def get_revenue_by_hostel(self, start_date, end_date):
        query = self.db.query(
            Hostel.id,
            Hostel.hostel_name,
            func.sum(Invoice.total_amount).label("total_billed"),
            func.sum(Invoice.paid_amount).label("total_collected"),
            func.sum(Invoice.due_amount).label("total_outstanding")
        ).join(Invoice)

        if start_date:
            query = query.filter(Invoice.created_at >= start_date)
        if end_date:
            query = query.filter(Invoice.created_at <= end_date)

        query = query.group_by(Hostel.id, Hostel.hostel_name)
        rows = query.all()

        return [
            {
                "hostel_id": r.id,
                "hostel_name": r.hostel_name,
                "total_billed": float(r.total_billed or 0),
                "total_collected": float(r.total_collected or 0),
                "total_outstanding": float(r.total_outstanding or 0),
            }
            for r in rows
        ]

    def get_monthly_revenue_report(self, year: int, hostel_id: int = None):
        query = self.db.query(
            extract("month", Invoice.created_at).label("month"),
            func.sum(Invoice.total_amount).label("total_billed"),
            func.sum(Invoice.paid_amount).label("total_collected"),
            func.count(Invoice.id).label("invoice_count"),
        ).filter(extract("year", Invoice.created_at) == year)

        if hostel_id:
            query = query.filter(Invoice.hostel_id == hostel_id)

        query = query.group_by("month").order_by("month")

        rows = query.all()

        return [
            {
                "month": int(r.month),
                "total_billed": float(r.total_billed or 0),
                "total_collected": float(r.total_collected or 0),
                "invoice_count": r.invoice_count,
                "collection_rate": (
                    (float(r.total_collected or 0) / float(r.total_billed or 1)) * 100
                ),
            }
            for r in rows
        ]

    def get_payment_method_breakdown(self, start_date=None, end_date=None, hostel_id=None):
        from app.models.subscription import Payment

        query = self.db.query(
            Payment.payment_method,
            func.count(Payment.id).label("count"),
            func.sum(Payment.amount).label("total_amount")
        )

        if start_date:
            query = query.filter(Payment.created_at >= start_date)

        if end_date:
            query = query.filter(Payment.created_at <= end_date)

        if hostel_id:
            query = query.filter(Payment.hostel_id == hostel_id)

        query = query.group_by(Payment.payment_method)

        rows = query.all()

        return [
            {
                "payment_method": r.payment_method,
                "count": r.count,
                "total_amount": float(r.total_amount or 0.0)
            }
            for r in rows
        ]


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\maintenance_repository.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\mess_menu_repository.py ---
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func
from typing import List, Optional
from datetime import date, datetime
from app.models.mess_menu import MessMenu, MenuFeedback, MealPreference, MenuStatus, MenuType, MealType
from app.schemas.mess_menu import MessMenuCreate, MessMenuUpdate, MenuFeedbackCreate, MealPreferenceCreate, MealPreferenceUpdate


class MessMenuRepository:
    def __init__(self, db: Session):
        self.db = db

    # CRUD Operations for MessMenu
    def create_menu(self, menu: MessMenuCreate) -> MessMenu:
        db_menu = MessMenu(**menu.dict())
        self.db.add(db_menu)
        self.db.commit()
        self.db.refresh(db_menu)
        return db_menu

    def get_menu_by_id(self, menu_id: int) -> Optional[MessMenu]:
        return self.db.query(MessMenu).filter(MessMenu.id == menu_id).first()

    def get_menus_by_hostel(
        self,
        hostel_id: int,
        skip: int = 0,
        limit: int = 100,
        menu_type: Optional[str] = None,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None
    ) -> List[MessMenu]:
        query = self.db.query(MessMenu).filter(MessMenu.hostel_id == hostel_id)
        
        if menu_type:
            query = query.filter(MessMenu.menu_type == menu_type)
        
        if start_date:
            query = query.filter(MessMenu.menu_date >= start_date)
        
        if end_date:
            query = query.filter(MessMenu.menu_date <= end_date)
        
        return query.order_by(MessMenu.menu_date.desc()).offset(skip).limit(limit).all()

    def get_menu_by_date_and_meal(
        self,
        hostel_id: int,
        menu_date: date,
        meal_type: str
    ) -> Optional[MessMenu]:
        return self.db.query(MessMenu).filter(
            and_(
                MessMenu.hostel_id == hostel_id,
                MessMenu.menu_date == menu_date,
                MessMenu.meal_type == meal_type
            )
        ).first()

    def update_menu(self, menu_id: int, menu_update: MessMenuUpdate) -> Optional[MessMenu]:
        db_menu = self.get_menu_by_id(menu_id)
        if not db_menu:
            return None
        
        update_data = menu_update.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_menu, field, value)
        
        db_menu.updated_at = datetime.utcnow()
        self.db.commit()
        self.db.refresh(db_menu)
        return db_menu

    def delete_menu(self, menu_id: int) -> bool:
        db_menu = self.get_menu_by_id(menu_id)
        if not db_menu:
            return False
        
        self.db.delete(db_menu)
        self.db.commit()
        return True

    def approve_menu(self, menu_id: int, approved_by: int) -> Optional[MessMenu]:
        db_menu = self.get_menu_by_id(menu_id)
        if not db_menu:
            return None
        
        db_menu.status = MenuStatus.APPROVED
        db_menu.approved_by = approved_by
        db_menu.approved_at = datetime.utcnow()
        
        self.db.commit()
        self.db.refresh(db_menu)
        return db_menu

    def publish_menu(self, menu_id: int) -> Optional[MessMenu]:
        db_menu = self.get_menu_by_id(menu_id)
        if not db_menu:
            return None
        
        db_menu.status = MenuStatus.PUBLISHED
        self.db.commit()
        self.db.refresh(db_menu)
        return db_menu

    def duplicate_menu(
        self,
        source_menu_id: int,
        target_hostel_id: int,
        target_date: Optional[date] = None
    ) -> Optional[MessMenu]:
        source_menu = self.get_menu_by_id(source_menu_id)
        if not source_menu:
            return None
        
        new_menu_data = {
            "hostel_id": target_hostel_id,
            "menu_type": source_menu.menu_type,
            "menu_date": target_date or source_menu.menu_date,
            "meal_type": source_menu.meal_type,
            "items": source_menu.items,
            "serving_time_start": source_menu.serving_time_start,
            "serving_time_end": source_menu.serving_time_end,
            "diet_types": source_menu.diet_types,
            "nutritional_info": source_menu.nutritional_info,
            "notes": source_menu.notes,
            "is_special_occasion": source_menu.is_special_occasion,
            "occasion_name": source_menu.occasion_name,
            "status": MenuStatus.DRAFT,
            "created_by": source_menu.created_by,
            "created_by_role": source_menu.created_by_role
        }
        
        new_menu = MessMenu(**new_menu_data)
        self.db.add(new_menu)
        self.db.commit()
        self.db.refresh(new_menu)
        return new_menu

    # Feedback Operations
    def create_feedback(self, feedback: MenuFeedbackCreate) -> MenuFeedback:
        db_feedback = MenuFeedback(**feedback.dict())
        self.db.add(db_feedback)
        self.db.commit()
        self.db.refresh(db_feedback)
        return db_feedback

    def get_feedback_by_menu(self, menu_id: int) -> List[MenuFeedback]:
        return self.db.query(MenuFeedback).filter(MenuFeedback.menu_id == menu_id).all()

    def get_feedback_summary(self, menu_id: int) -> dict:
        feedbacks = self.get_feedback_by_menu(menu_id)
        
        if not feedbacks:
            return {
                "total_feedbacks": 0,
                "average_rating": 0,
                "average_taste": 0,
                "average_quantity": 0,
                "average_hygiene": 0
            }
        
        return {
            "total_feedbacks": len(feedbacks),
            "average_rating": sum(f.rating for f in feedbacks) / len(feedbacks),
            "average_taste": sum(f.taste_rating for f in feedbacks if f.taste_rating) / len([f for f in feedbacks if f.taste_rating]) if any(f.taste_rating for f in feedbacks) else 0,
            "average_quantity": sum(f.quantity_rating for f in feedbacks if f.quantity_rating) / len([f for f in feedbacks if f.quantity_rating]) if any(f.quantity_rating for f in feedbacks) else 0,
            "average_hygiene": sum(f.hygiene_rating for f in feedbacks if f.hygiene_rating) / len([f for f in feedbacks if f.hygiene_rating]) if any(f.hygiene_rating for f in feedbacks) else 0
        }

    # Meal Preference Operations
    def create_preference(self, preference: MealPreferenceCreate) -> MealPreference:
        db_preference = MealPreference(**preference.dict())
        self.db.add(db_preference)
        self.db.commit()
        self.db.refresh(db_preference)
        return db_preference

    def get_preference_by_student(self, student_id: int, hostel_id: int) -> Optional[MealPreference]:
        return self.db.query(MealPreference).filter(
            and_(
                MealPreference.student_id == student_id,
                MealPreference.hostel_id == hostel_id,
                MealPreference.is_active == True
            )
        ).first()

    def get_preferences_by_hostel(self, hostel_id: int) -> List[MealPreference]:
        return self.db.query(MealPreference).filter(
            and_(
                MealPreference.hostel_id == hostel_id,
                MealPreference.is_active == True
            )
        ).all()

    def update_preference(
        self,
        preference_id: int,
        preference_update: MealPreferenceUpdate
    ) -> Optional[MealPreference]:
        db_preference = self.db.query(MealPreference).filter(
            MealPreference.id == preference_id
        ).first()
        
        if not db_preference:
            return None
        
        update_data = preference_update.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_preference, field, value)
        
        db_preference.updated_at = datetime.utcnow()
        self.db.commit()
        self.db.refresh(db_preference)
        return db_preference

    def get_students_with_dietary_restrictions(self, hostel_id: int) -> List[MealPreference]:
        return self.db.query(MealPreference).filter(
            and_(
                MealPreference.hostel_id == hostel_id,
                MealPreference.is_active == True,
                or_(
                    MealPreference.allergies.isnot(None),
                    MealPreference.medical_requirements.isnot(None)
                )
            )
        ).all()

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\notification_repository.py ---
from typing import Optional, List

from sqlalchemy.orm import Session

from app.models.notification import (
	Notification,
	NotificationTemplate,
	DeliveryAttempt,
	DeviceToken,
)


class NotificationRepository:
	def __init__(self, db: Session):
		self.db = db

	def create_notification(self, notification: Notification) -> Notification:
		self.db.add(notification)
		self.db.commit()
		self.db.refresh(notification)
		return notification

	def get_notification(self, notification_id: int) -> Optional[Notification]:
		return self.db.query(Notification).filter(Notification.id == notification_id).one_or_none()

	def list_notifications(self, limit: int = 100) -> List[Notification]:
		return self.db.query(Notification).order_by(Notification.created_at.desc()).limit(limit).all()

	def create_template(self, template: NotificationTemplate) -> NotificationTemplate:
		self.db.add(template)
		self.db.commit()
		self.db.refresh(template)
		return template

	def get_template_by_name(self, name: str) -> Optional[NotificationTemplate]:
		return self.db.query(NotificationTemplate).filter(NotificationTemplate.name == name).one_or_none()

	def get_template(self, template_id: int) -> Optional[NotificationTemplate]:
		return self.db.query(NotificationTemplate).filter(NotificationTemplate.id == template_id).one_or_none()

	def list_templates(self, limit: int = 100):
		return self.db.query(NotificationTemplate).order_by(NotificationTemplate.created_at.desc()).limit(limit).all()

	def update_template(self, template: NotificationTemplate, data: dict) -> NotificationTemplate:
		for k, v in data.items():
			setattr(template, k, v)
		self.db.add(template)
		self.db.commit()
		self.db.refresh(template)
		return template

	def delete_template(self, template: NotificationTemplate) -> None:
		self.db.delete(template)
		self.db.commit()

	def create_attempt(self, attempt: DeliveryAttempt) -> DeliveryAttempt:
		self.db.add(attempt)
		self.db.commit()
		self.db.refresh(attempt)
		return attempt

	def save_device_token(self, token: DeviceToken) -> DeviceToken:
		self.db.add(token)
		self.db.commit()
		self.db.refresh(token)
		return token


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\payment_repository.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\payment_repositorys.py ---
# app/repositories/payment_repository.py
from sqlalchemy.orm import Session
from app.models.payment_models import Invoice, Transaction, Receipt, RefundRequest

class PaymentRepository:

    @staticmethod
    def create_invoice(db: Session, invoice: Invoice):
        db.add(invoice)
        db.commit()
        db.refresh(invoice)
        return invoice

    @staticmethod
    def get_invoice(db: Session, invoice_id: int):
        return db.query(Invoice).filter(Invoice.id == invoice_id).first()

    @staticmethod
    def list_user_invoices(db: Session, user_id: int, status=None):
        q = db.query(Invoice).filter(Invoice.user_id == user_id)
        if status:
            q = q.filter(Invoice.status == status)
        return q.order_by(Invoice.created_at.desc()).all()

    @staticmethod
    def save_transaction(db: Session, txn: Transaction):
        db.add(txn)
        db.commit()
        db.refresh(txn)
        return txn

    @staticmethod
    def get_transaction(db: Session, transaction_id: int):
        return db.query(Transaction).filter(Transaction.id == transaction_id).first()

    @staticmethod
    def save_receipt(db: Session, receipt: Receipt):
        db.add(receipt)
        db.commit()
        db.refresh(receipt)
        return receipt

    @staticmethod
    def get_receipt_by_transaction(db: Session, transaction_id: int):
        return db.query(Receipt).filter(Receipt.transaction_id == transaction_id).first()

    @staticmethod
    def create_refund_request(db: Session, refund: RefundRequest):
        db.add(refund)
        db.commit()
        db.refresh(refund)
        return refund

    @staticmethod
    def get_refund(db: Session, refund_id: int):
        return db.query(RefundRequest).filter(RefundRequest.id == refund_id).first()

# app/repositories/refund_repository.py
# from sqlalchemy.orm import Session
# from typing import Optional, List
# from app.models.payment_models import RefundRequest, Transaction
# from datetime import datetime

# class RefundRepository:
#     """Data access layer for refund operations"""
    
#     def __init__(self, db: Session):
#         self.db = db
    
#     def get_by_id(self, refund_id: int) -> Optional[RefundRequest]:
#         """Fetch refund by ID"""
#         return self.db.query(RefundRequest).filter(RefundRequest.id == refund_id).first()
    
#     def get_by_refund_id(self, refund_id: str) -> Optional[RefundRequest]:
#         """Fetch refund by refund_id string"""
#         return self.db.query(RefundRequest).filter(RefundRequest.refund_id == refund_id).first()
    
#     def get_pending_refunds(self) -> List[RefundRequest]:
#         """Get all refunds awaiting approval"""
#         return self.db.query(RefundRequest).filter(
#             RefundRequest.status.in_(["initiated", "processing"])
#         ).all()
    
#     def update_status(self, refund: RefundRequest, status: str, **kwargs) -> RefundRequest:
#         """Update refund status and related fields"""
#         refund.status = status
#         for key, value in kwargs.items():
#             if hasattr(refund, key):
#                 setattr(refund, key, value)
#         self.db.flush()
#         return refund
    
#     def create_refund_transaction(self, transaction_data: dict) -> Transaction:
#         """Create a refund transaction record"""
#         txn = Transaction(**transaction_data)
#         self.db.add(txn)
#         self.db.flush()
#         return txn


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\permission_repository.py ---
"""
Permission lookups
"""
from sqlalchemy.orm import Session
from typing import List, Optional
from app.models.permission import Permission, RolePermission


class PermissionRepository:
    def __init__(self, db: Session):
        self.db = db
    
    def get_by_id(self, permission_id: int) -> Optional[Permission]:
        """Get permission by ID"""
        return self.db.query(Permission).filter(Permission.id == permission_id).first()
    
    def get_by_name(self, name: str) -> Optional[Permission]:
        """Get permission by name"""
        return self.db.query(Permission).filter(Permission.name == name).first()
    
    def get_all(self) -> List[Permission]:
        """Get all permissions"""
        return self.db.query(Permission).filter(Permission.is_active == True).all()
    
    def get_role_permissions(self, role: str) -> List[Permission]:
        """Get all permissions for a role"""
        role_perms = self.db.query(RolePermission).filter(
            RolePermission.role == role
        ).all()
        permission_ids = [rp.permission_id for rp in role_perms]
        return self.db.query(Permission).filter(Permission.id.in_(permission_ids)).all()
    
    def assign_permission_to_role(self, role: str, permission_id: int) -> RolePermission:
        """Assign permission to role"""
        # Check if already assigned
        existing = self.db.query(RolePermission).filter(
            RolePermission.role == role,
            RolePermission.permission_id == permission_id
        ).first()
        if existing:
            return existing
        
        role_perm = RolePermission(role=role, permission_id=permission_id)
        self.db.add(role_perm)
        self.db.commit()
        self.db.refresh(role_perm)
        return role_perm
    
    def remove_permission_from_role(self, role: str, permission_id: int) -> bool:
        """Remove permission from role"""
        role_perm = self.db.query(RolePermission).filter(
            RolePermission.role == role,
            RolePermission.permission_id == permission_id
        ).first()
        if not role_perm:
            return False
        self.db.delete(role_perm)
        self.db.commit()
        return True



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\razorpay_repositorys.py ---
from app.models.subscription import Payment
from app.models.payment_models import Customer
from app.models.hostel import Hostel

class RazorpayRepository:

    @staticmethod
    def get_user_by_id(db, user_id: int):
        return db.query(Customer).filter(Customer.id == user_id).first()

    @staticmethod
    def get_hostel_by_id(db, hostel_id: int):
        return db.query(Hostel).filter(Hostel.id == hostel_id).first()

    @staticmethod
    def save_payment(db, payment: Payment):
        db.add(payment)
        db.commit()
        db.refresh(payment)
        return payment


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\report_repositories.py ---
from sqlalchemy.orm import Session
from sqlalchemy import and_, func, desc
from fastapi import HTTPException
from datetime import datetime
from decimal import Decimal

from app.models.report_models import (
    BookingReport, Commission, SubscriptionRevenue, Report, FinancialSummary,
    BookingStatus, PaymentStatus, CommissionStatus, ReportType
)
from app.config import settings

# Booking CRUD
def create_booking(db: Session, booking_data: BookingReport):
    commission_rate = Decimal(str(settings.COMMISSION_RATE))
    commission_amount = booking_data.amount * commission_rate

    db_booking = BookingReport(
        hostel_id=booking_data.hostel_id,
        hostel_name=booking_data.hostel_name,
        user_id=booking_data.user_id,
        user_name=booking_data.user_name,
        room_type=booking_data.room_type,
        check_in_date=booking_data.check_in_date,
        check_out_date=booking_data.check_out_date,
        amount=booking_data.amount,
        commission_rate=commission_rate,
        commission_amount=commission_amount
    )
    db.add(db_booking)
    db.commit()
    db.refresh(db_booking)

    # Create commission record
    commission = Commission(
        booking_id=db_booking.id,
        amount=commission_amount,
        earned_date=datetime.utcnow(),
        hostel_id=booking_data.hostel_id,
        platform_revenue=commission_amount
    )
    db.add(commission)
    db.commit()
    db.refresh(commission)

    return db_booking

def update_booking_status(db: Session, booking_id: str, status: BookingStatus, payment_status: PaymentStatus):
    booking = db.query(BookingReport).filter(BookingReport.id == booking_id).first()
    if not booking:
        raise HTTPException(status_code=404, detail="Booking not found")

    booking.status = status
    booking.payment_status = payment_status

    # Update commission status
    if payment_status == PaymentStatus.PAID and booking.commission:
        booking.commission.status = CommissionStatus.PENDING

    db.commit()
    db.refresh(booking)
    return booking

# Commission CRUD
def get_pending_commissions(db: Session, hostel_id: str = None):
    query = db.query(Commission).filter(Commission.status == CommissionStatus.PENDING)
    if hostel_id:
        query = query.filter(Commission.hostel_id == hostel_id)
    return query.all()

def mark_commission_paid(db: Session, commission_id: str):
    commission = db.query(Commission).filter(Commission.id == commission_id).first()
    if not commission:
        raise HTTPException(status_code=404, detail="Commission not found")
    commission.status = CommissionStatus.PAID
    commission.paid_date = datetime.utcnow()
    db.commit()
    db.refresh(commission)
    return commission

# Financial summary
def calculate_financial_summary(db: Session, start_date: datetime, end_date: datetime):
    subscription_revenue = db.query(func.sum(SubscriptionRevenue.amount)).filter(
        and_(SubscriptionRevenue.billing_date >= start_date,
             SubscriptionRevenue.billing_date <= end_date)
    ).scalar() or Decimal("0.00")

    commission_earned = db.query(func.sum(Commission.amount)).filter(
        and_(Commission.earned_date >= start_date,
             Commission.earned_date <= end_date,
             Commission.status != CommissionStatus.PENDING)
    ).scalar() or Decimal("0.00")

    pending_payments = db.query(func.sum(Commission.amount)).filter(
        Commission.status == CommissionStatus.PENDING
    ).scalar() or Decimal("0.00")

    total_income = subscription_revenue + commission_earned

    total_bookings = db.query(func.count(BookingReport.id)).filter(
        and_(BookingReport.created_at >= start_date, BookingReport.created_at <= end_date)
    ).scalar() or 0

    completed_bookings = db.query(func.count(BookingReport.id)).filter(
        and_(BookingReport.created_at >= start_date,
             BookingReport.created_at <= end_date,
             BookingReport.status == BookingStatus.COMPLETED)
    ).scalar() or 0

    cancelled_bookings = db.query(func.count(BookingReport.id)).filter(
        and_(BookingReport.created_at >= start_date,
             BookingReport.created_at <= end_date,
             BookingReport.status == BookingStatus.CANCELLED)
    ).scalar() or 0

    return {
        "total_income": total_income,
        "subscription_revenue": subscription_revenue,
        "commission_earned": commission_earned,
        "pending_payments": pending_payments,
        "total_bookings": total_bookings,
        "completed_bookings": completed_bookings,
        "cancelled_bookings": cancelled_bookings,
        "period_start": start_date,
        "period_end": end_date
    }

# Report generation
def generate_revenue_report(db: Session, start_date: datetime, end_date: datetime, user_id: str):
    data = calculate_financial_summary(db, start_date, end_date)
    daily_revenue = db.query(
        func.date(BookingReport.created_at).label('date'),
        func.sum(BookingReport.amount).label('revenue'),
        func.sum(BookingReport.commission_amount).label('commission')
    ).filter(
        and_(BookingReport.created_at >= start_date,
             BookingReport.created_at <= end_date,
             BookingReport.payment_status == PaymentStatus.PAID)
    ).group_by(func.date(BookingReport.created_at)).all()

    report = Report(
        name=f"Revenue Report ({start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')})",
        report_type=ReportType.REVENUE,
        start_date=start_date,
        end_date=end_date,
        parameters={"type": "revenue"},
        result_data={
            "summary": {
                "total_income": str(data["total_income"]),
                "subscription_revenue": str(data["subscription_revenue"]),
                "commission_earned": str(data["commission_earned"])
            },
            "daily_breakdown": [
                {"date": str(d.date), "revenue": str(d.revenue), "commission": str(d.commission)}
                for d in daily_revenue
            ]
        },
        generated_by=user_id
    )
    db.add(report)
    db.commit()
    db.refresh(report)
    return report

def generate_commission_report(db: Session, start_date: datetime, end_date: datetime, user_id: str):
    commissions_by_hostel = db.query(
        Commission.hostel_id,
        BookingReport.hostel_name,
        func.sum(Commission.amount).label('total_commission'),
        func.count(Commission.id).label('booking_count')
    ).join(BookingReport).filter(
        and_(Commission.earned_date >= start_date, Commission.earned_date <= end_date)
    ).group_by(Commission.hostel_id, BookingReport.hostel_name).all()

    pending_total = db.query(func.sum(Commission.amount)).filter(
        and_(Commission.earned_date >= start_date,
             Commission.earned_date <= end_date,
             Commission.status == CommissionStatus.PENDING)
    ).scalar() or Decimal("0.00")

    paid_total = db.query(func.sum(Commission.amount)).filter(
        and_(Commission.earned_date >= start_date,
             Commission.earned_date <= end_date,
             Commission.status == CommissionStatus.PAID)
    ).scalar() or Decimal("0.00")

    report = Report(
        name=f"Commission Report ({start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')})",
        report_type=ReportType.COMMISSION,
        start_date=start_date,
        end_date=end_date,
        parameters={"type": "commission"},
        result_data={
            "summary": {
                "total_pending": str(pending_total),
                "total_paid": str(paid_total),
                "total_earned": str(pending_total + paid_total)
            },
            "by_hostel": [
                {"hostel_id": c.hostel_id, "hostel_name": c.hostel_name,
                 "total_commission": str(c.total_commission), "booking_count": c.booking_count}
                for c in commissions_by_hostel
            ]
        },
        generated_by=user_id
    )
    db.add(report)
    db.commit()
    db.refresh(report)
    return report

def get_recent_reports(db: Session, limit: int = 10):
    return db.query(Report).order_by(desc(Report.generated_at)).limit(limit).all()

def get_report_statistics(db: Session):
    now = datetime.utcnow()
    month_start = datetime(now.year, now.month, 1)
    generated_this_month = db.query(func.count(Report.id)).filter(Report.generated_at >= month_start).scalar() or 0
    automated_reports = db.query(func.count(Report.id)).filter(Report.is_automated == True).scalar() or 0
    scheduled_reports = db.query(func.count(Report.id)).filter(Report.is_scheduled == True).scalar() or 0
    return {
        "generated_this_month": generated_this_month,
        "automated_reports": automated_reports,
        "scheduled_reports": scheduled_reports
    }

def get_report_by_id(db: Session, report_id: str):
    return db.query(Report).filter(Report.id == report_id).first()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\room_repository.py ---
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import exc as sa_exc

from app.models.rooms import Room, RoomType, MaintenanceStatus
from app.schemas.rooms import RoomCreate, RoomUpdate


def create_room(db: Session, room_in: RoomCreate) -> Room:
    obj = Room(**room_in.dict())
    db.add(obj)
    try:
        db.commit()
        db.refresh(obj)
        return obj
    except sa_exc.ProgrammingError as e:
        db.rollback()
        raise RuntimeError("Database schema not initialized or table missing: " + str(e))
    except Exception:
        db.rollback()
        raise


def get_room(db: Session, room_id: UUID) -> Optional[Room]:
    return db.query(Room).filter(Room.id == room_id).first()


def list_rooms(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    room_type: Optional[RoomType] = None,
    maintenance_status: Optional[MaintenanceStatus] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    min_capacity: Optional[int] = None,
    only_available: Optional[bool] = None,
    amenities_like: Optional[str] = None,
) -> List[Room]:
    query = db.query(Room)
    if room_type is not None:
        query = query.filter(Room.room_type == room_type)
    if maintenance_status is not None:
        query = query.filter(Room.maintenance_status == maintenance_status)
    if min_capacity is not None:
        query = query.filter(Room.room_capacity >= min_capacity)
    if min_price is not None:
        query = query.filter(Room.monthly_price >= min_price)
    if max_price is not None:
        query = query.filter(Room.monthly_price <= max_price)
    if only_available:
        query = query.filter(Room.availability > 0)
    if amenities_like:
        like = f"%{amenities_like}%"
        query = query.filter(Room.amenities.ilike(like))

    rooms = query.order_by(Room.id).offset(skip).limit(limit).all()

    # Ensure hostel_id is returned as a string
    for room in rooms:
        room.hostel_id = str(room.hostel_id)

    return rooms


def update_room(db: Session, room: Room, room_in: RoomUpdate) -> Room:
    for field, value in room_in.dict(exclude_unset=True).items():
        setattr(room, field, value)
    db.add(room)
    db.commit()
    db.refresh(room)
    return room


def delete_room(db: Session, room: Room) -> None:
    db.delete(room)
    db.commit()


def set_room_maintenance(db: Session, room: Room, status: MaintenanceStatus) -> Room:
    room.maintenance_status = status
    db.add(room)
    db.commit()
    db.refresh(room)
    return room


def set_room_availability(db: Session, room: Room, availability: int) -> Room:
    room.availability = availability
    db.add(room)
    db.commit()
    db.refresh(room)
    return room


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\session_repository.py ---
"""
Active hostel sessions
"""
from sqlalchemy.orm import Session
from typing import Optional, List
from app.models.session_context import SessionContext
from app.schemas.session import SessionContextCreate


class SessionRepository:
    def __init__(self, db: Session):
        self.db = db
    
    def get_active_session(self, user_id: int) -> Optional[SessionContext]:
        """Get active session for user"""
        return self.db.query(SessionContext).filter(
            SessionContext.user_id == user_id,
            SessionContext.is_active == True
        ).first()
    
    def get_all_sessions(self, user_id: int) -> List[SessionContext]:
        """Get all sessions for user"""
        return self.db.query(SessionContext).filter(
            SessionContext.user_id == user_id
        ).order_by(SessionContext.updated_at.desc()).all()
    
    def create_session(self, user_id: int, hostel_id: int) -> SessionContext:
        """Create or activate session"""
        # Deactivate existing sessions
        existing = self.db.query(SessionContext).filter(
            SessionContext.user_id == user_id,
            SessionContext.is_active == True
        ).all()
        for session in existing:
            session.is_active = False
        
        # Check if session already exists
        existing_session = self.db.query(SessionContext).filter(
            SessionContext.user_id == user_id,
            SessionContext.hostel_id == hostel_id
        ).first()
        
        if existing_session:
            existing_session.is_active = True
            self.db.commit()
            self.db.refresh(existing_session)
            return existing_session
        
        # Create new session
        new_session = SessionContext(user_id=user_id, hostel_id=hostel_id, is_active=True)
        self.db.add(new_session)
        self.db.commit()
        self.db.refresh(new_session)
        return new_session
    
    def deactivate_session(self, user_id: int, session_id: int) -> bool:
        """Deactivate a session"""
        session = self.db.query(SessionContext).filter(
            SessionContext.id == session_id,
            SessionContext.user_id == user_id
        ).first()
        if not session:
            return False
        session.is_active = False
        self.db.commit()
        return True



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\shift_coordination_repositories.py ---
from sqlalchemy.orm import Session
from app.models.shift_coordination_models import (
    Shift, ShiftSchedule, Task, TaskDelegation,
    ShiftHandover, HandoverItem, SupervisorCoordination
)


def create_shift(db: Session, shift_data):
    shift = Shift(**shift_data.dict())
    db.add(shift)
    db.commit()
    db.refresh(shift)
    return shift


def get_all_shifts(db: Session):
    return db.query(Shift).all()


def create_shift_schedule(db: Session, schedule_data):
    schedule = ShiftSchedule(**schedule_data.dict())
    db.add(schedule)
    db.commit()
    db.refresh(schedule)
    return schedule


def create_task(db: Session, task_data):
    task = Task(**task_data.dict())
    db.add(task)
    db.commit()
    db.refresh(task)
    return task


def update_task(db: Session, task_id: int, update_data):
    task = db.query(Task).filter(Task.id == task_id).first()
    if not task:
        return None
    for key, value in update_data.dict(exclude_unset=True).items():
        setattr(task, key, value)
    db.commit()
    db.refresh(task)
    return task


def create_task_delegation(db: Session, delegation_data):
    delegation = TaskDelegation(**delegation_data.dict())
    db.add(delegation)
    db.commit()
    db.refresh(delegation)
    return delegation


def create_handover(db: Session, handover_data):
    handover = ShiftHandover(**handover_data.dict())
    db.add(handover)
    db.commit()
    db.refresh(handover)
    return handover


def create_handover_item(db: Session, item_data):
    item = HandoverItem(**item_data.dict())
    db.add(item)
    db.commit()
    db.refresh(item)
    return item


def create_coordination_meeting(db: Session, meeting_data):
    meeting = SupervisorCoordination(**meeting_data.dict())
    db.add(meeting)
    db.commit()
    db.refresh(meeting)
    return meeting


def get_meetings_by_hostel(db: Session, hostel_id: int):
    return db.query(SupervisorCoordination).filter(SupervisorCoordination.hostel_id == hostel_id).all()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\student_repository.py ---
from typing import List, Optional
from datetime import date, datetime, time
from sqlalchemy.orm import Session
from sqlalchemy import text, func

from app.models.students import Student, StudentPayment, Attendance, StudentDocument
from app.schemas.students import StudentCreate, StudentUpdate


def list_students(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    name: Optional[str] = None,
    room: Optional[str] = None,
    payment_status: Optional[str] = None,
    attendance_status: Optional[str] = None,
) -> List[Student]:
    query = db.query(Student)
    
    if name:
        query = query.filter(Student.student_name.ilike(f"%{name}%"))
    if room:
        query = query.filter(Student.room_assignment == room)
    if payment_status:
        query = query.filter(
            db.query(StudentPayment.id)
              .filter(StudentPayment.student_id == Student.student_id, StudentPayment.status == payment_status)
              .exists()
        )
    if attendance_status:
        query = query.filter(
            db.query(Attendance.id)
              .filter(Attendance.student_id == Student.student_id, Attendance.status == attendance_status)
              .exists()
        )

    return query.order_by(Student.student_id).offset(skip).limit(limit).all()


def get_student(db: Session, student_id: str) -> Optional[Student]:
    return db.query(Student).filter(Student.student_id == student_id).first()


def create_student(db: Session, student_in: StudentCreate) -> Student:
    obj = Student(**student_in.dict())
    db.add(obj)
    db.commit()
    db.refresh(obj)
    return obj


def update_student(db: Session, student_id: str, student_in: StudentUpdate) -> Optional[Student]:
    obj = get_student(db, student_id)
    if not obj:
        return None
    
    for field, value in student_in.dict(exclude_unset=True).items():
        setattr(obj, field, value)

    db.add(obj)
    db.commit()
    db.refresh(obj)
    return obj


def delete_student(db: Session, student_id: str) -> bool:
    obj = get_student(db, student_id)
    if not obj:
        return False

    db.delete(obj)
    db.commit()
    return True


def set_status(db: Session, student_id: str, new_status: str, notes: Optional[str] = None) -> Optional[Student]:
    obj = get_student(db, student_id)
    if not obj:
        return None

    old_status = obj.status
    obj.status = new_status
    db.add(obj)
    db.commit()
    db.refresh(obj)

    db.execute(
        text("""
            INSERT INTO student_status_history (
                student_id, event_type, old_status, new_status, notes
            )
            VALUES (:sid, 'status_change', :old, :new, :notes)
        """),
        {
            "sid": student_id,
            "old": old_status,
            "new": new_status,
            "notes": notes or ""
        }
    )
    db.commit()

    return obj


def transfer(db: Session, student_id: str, new_room: Optional[str], new_bed: Optional[str], notes: Optional[str]) -> Optional[Student]:
    obj = get_student(db, student_id)
    if not obj:
        return None

    old_room = obj.room_assignment
    old_bed = obj.bed_assignment

    obj.room_assignment = new_room
    obj.bed_assignment = new_bed
    db.add(obj)
    db.commit()
    db.refresh(obj)

    db.execute(
        text("""
            INSERT INTO student_status_history (
                student_id, event_type, old_room, old_bed, new_room, new_bed, notes
            )
            VALUES (:sid, 'transfer', :old_room, :old_bed, :new_room, :new_bed, :notes)
        """),
        {
            "sid": student_id,
            "old_room": old_room,
            "old_bed": old_bed,
            "new_room": new_room,
            "new_bed": new_bed,
            "notes": notes or ""
        }
    )
    db.commit()

    return obj


def list_history(db: Session, student_id: str) -> List[dict]:
    rows = db.execute(
        text("""
            SELECT id, event_type, old_status, new_status, old_room, old_bed,
                   new_room, new_bed, notes, created_at
            FROM student_status_history
            WHERE student_id = :sid
            ORDER BY created_at DESC
        """),
        {"sid": student_id}
    )
    return [dict(r._mapping) for r in rows]


# ------- Payments -------

def create_payment(
    db: Session,
    student_id: str,
    payment_type: Optional[str],
    amount: float,
    payment_method: Optional[str],
    payment_date: Optional[date],
    due_date: Optional[date],
    transaction_id: Optional[str],
    status: str = "pending",
    notes: Optional[str] = None,
    currency: Optional[str] = None,
    method: Optional[str] = None,
    paid_at: Optional[datetime] = None,
) -> StudentPayment:
    p = StudentPayment(
        student_id=student_id,
        payment_type=payment_type,
        amount=amount,
        payment_method=payment_method,
        payment_date=payment_date,
        due_date=due_date,
        transaction_id=transaction_id,
        currency=currency,
        status=status,
        method=method,
        paid_at=paid_at,
        notes=notes
    )
    db.add(p)
    db.commit()
    db.refresh(p)
    return p


def list_payments(db: Session, student_id: str) -> List[StudentPayment]:
    return db.query(StudentPayment).filter(
        StudentPayment.student_id == student_id
    ).order_by(StudentPayment.created_at.desc()).all()


# ------- Attendance -------

def create_attendance(
    db: Session,
    student_id: str,
    attendance_date: Optional[date],
    attendance_mode: Optional[str],
    check_in_time: Optional[time],
    check_out_time: Optional[time],
    is_late: bool,
    status: str,
    notes: Optional[str],
    date_val: Optional[date] = None,
) -> Attendance:

    final_date = attendance_date if attendance_date else date_val

    a = Attendance(
        student_id=student_id,
        attendance_date=final_date,
        attendance_mode=attendance_mode,
        check_in_time=check_in_time,
        check_out_time=check_out_time,
        is_late=is_late,
        date=final_date,
        status=status,
        notes=notes
    )

    db.add(a)
    db.commit()
    db.refresh(a)
    return a


def list_attendance(db: Session, student_id: str) -> List[Attendance]:
    return db.query(Attendance).filter(
        Attendance.student_id == student_id
    ).order_by(
        func.coalesce(Attendance.attendance_date, Attendance.date).desc()
    ).all()


# ------- Student Documents -------

def create_student_document(db: Session, student_id: str, doc_type: Optional[str], doc_url: str) -> StudentDocument:
    d = StudentDocument(student_id=student_id, doc_type=doc_type, doc_url=doc_url)
    db.add(d)
    db.commit()
    db.refresh(d)
    return d


def list_student_documents(db: Session, student_id: str) -> List[StudentDocument]:
    return db.query(StudentDocument).filter(
        StudentDocument.student_id == student_id
    ).order_by(StudentDocument.uploaded_at.desc()).all()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\subscription_repository.py ---
from sqlalchemy.orm import Session
from app.models import subscription as subscription_models
from app import schemas
from typing import List, Optional


# ───────────────────────────────────────────────────────────────
# PLAN REPOSITORY
# ───────────────────────────────────────────────────────────────
def create_plan(db: Session, plan: schemas.SubscriptionPlanCreate):
    db_plan = subscription_models.SubscriptionPlan(**plan.dict(by_alias=True))
    db.add(db_plan)
    db.commit()
    db.refresh(db_plan)
    return db_plan


def get_all_plans(db: Session) -> List[subscription_models.SubscriptionPlan]:
    return db.query(subscription_models.SubscriptionPlan).filter(subscription_models.SubscriptionPlan.is_active == True).all()


def get_plan_by_id(db: Session, plan_id: str):
    return db.query(subscription_models.SubscriptionPlan).filter(subscription_models.SubscriptionPlan.id == plan_id).first()


# ───────────────────────────────────────────────────────────────
# SUBSCRIPTION REPOSITORY
# ───────────────────────────────────────────────────────────────
def create_subscription(db: Session, subscription: schemas.SubscriptionCreate):
    db_sub = subscription_models.Subscription(**subscription.dict(by_alias=True))
    db.add(db_sub)
    db.commit()
    db.refresh(db_sub)
    return db_sub


def get_subscription_by_org(db: Session, organization_id: str):
    return db.query(subscription_models.Subscription).filter(subscription_models.Subscription.organization_id == organization_id).first()


def get_subscription_by_id(db: Session, subscription_id: str):
    return db.query(subscription_models.Subscription).filter(subscription_models.Subscription.id == subscription_id).first()


def list_subscriptions(db: Session) -> List[subscription_models.Subscription]:
    return db.query(subscription_models.Subscription).all()


# ───────────────────────────────────────────────────────────────
# PAYMENT REPOSITORY
# ───────────────────────────────────────────────────────────────
def create_payment(db: Session, payment: schemas.PaymentCreate):
    payment_data = payment.dict(by_alias=True, exclude_unset=True)
    # Handle metadata separately since it's an aliased field
    if hasattr(payment, 'metadata_') and payment.metadata_ is not None:
        payment_data['metadata_'] = payment.metadata_
    
    db_payment = subscription_models.Payment(**payment_data)
    db.add(db_payment)
    db.commit()
    db.refresh(db_payment)
    
    # Convert metadata to dict for response if present
    if db_payment.metadata_ is not None:
        db_payment.metadata_ = dict(db_payment.metadata_)
    return db_payment


def list_payments(db: Session, subscription_id: Optional[str] = None):
    query = db.query(subscription_models.Payment)
    if subscription_id:
        query = query.filter(subscription_models.Payment.subscription_id == subscription_id)
    payments = query.all()
    # Convert SQLAlchemy metadata to dict or None
    for payment in payments:
        if hasattr(payment, 'metadata_') and payment.metadata_ is not None:
            payment.metadata_ = dict(payment.metadata_)
    return payments


# ───────────────────────────────────────────────────────────────
# SUBSCRIPTION CHANGES REPOSITORY
# ───────────────────────────────────────────────────────────────
def create_change(db: Session, change: schemas.SubscriptionChangeCreate):
    db_change = subscription_models.SubscriptionChange(**change.dict(by_alias=True))
    db.add(db_change)
    db.commit()
    db.refresh(db_change)
    return db_change


def list_changes(db: Session, subscription_id: str):
    return db.query(subscription_models.SubscriptionChange).filter(subscription_models.SubscriptionChange.subscription_id == subscription_id).all()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\supervisor_repository.py ---
from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import text

from app.models.supervisors import Supervisor, AdminOverride
from app.schemas.supervisors import SupervisorCreate, SupervisorUpdate


def create_supervisor(db: Session, sup_in: SupervisorCreate) -> Supervisor:
    obj = Supervisor(**sup_in.dict())
    db.add(obj)
    db.commit()
    db.refresh(obj)
    _log(db, obj.employee_id, "create", f"created supervisor {obj.employee_id}")
    return obj


def get_supervisor(db: Session, employee_id: str) -> Optional[Supervisor]:
    return db.query(Supervisor).filter(
        Supervisor.employee_id == employee_id
    ).first()


def list_supervisors(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    name: Optional[str] = None,
    role: Optional[str] = None,
    department: Optional[str] = None
) -> List[Supervisor]:

    query = db.query(Supervisor)

    if name:
        query = query.filter(Supervisor.supervisor_name.ilike(f"%{name}%"))
    if role:
        query = query.filter(Supervisor.role == role)
    if department:
        query = query.filter(Supervisor.department == department)

    return query.order_by(Supervisor.employee_id).offset(skip).limit(limit).all()


def update_supervisor(db: Session, employee_id: str, sup_in: SupervisorUpdate) -> Optional[Supervisor]:
    obj = get_supervisor(db, employee_id)
    if not obj:
        return None
    
    for field, value in sup_in.dict(exclude_unset=True).items():
        setattr(obj, field, value)

    db.add(obj)
    db.commit()
    db.refresh(obj)

    _log(db, employee_id, "update", "updated supervisor")
    return obj


def delete_supervisor(db: Session, employee_id: str) -> bool:
    obj = get_supervisor(db, employee_id)
    if not obj:
        return False

    db.delete(obj)
    db.commit()

    _log(db, employee_id, "delete", "deleted supervisor")
    return True


def assign_hostel(db: Session, employee_id: str, hostel_id: str) -> None:
    db.execute(
        text("INSERT INTO supervisor_hostels (employee_id, hostel_id) VALUES (:eid, :hid)"),
        {"eid": employee_id, "hid": hostel_id}
    )
    db.commit()

    _log(db, employee_id, "assign_hostel", f"assigned to hostel {hostel_id}")


def list_hostels(db: Session, employee_id: str) -> List[dict]:
    rows = db.execute(
        text("SELECT id, hostel_id FROM supervisor_hostels WHERE employee_id = :eid"),
        {"eid": employee_id}
    )
    return [dict(r._mapping) for r in rows]


# ------- Logging -------

def _log(db: Session, employee_id: str, action: str, details: str) -> None:
    db.execute(
        text("""
            INSERT INTO supervisor_activity (employee_id, action, details)
            VALUES (:eid, :action, :details)
        """),
        {"eid": employee_id, "action": action, "details": details}
    )
    db.commit()


def list_activity(db: Session, employee_id: str) -> List[dict]:
    rows = db.execute(
        text("""
            SELECT id, action, details, created_at
            FROM supervisor_activity
            WHERE employee_id = :eid
            ORDER BY created_at DESC
        """),
        {"eid": employee_id}
    )
    return [dict(r._mapping) for r in rows]


# ------- Admin Overrides -------

def create_admin_override(db: Session, admin_employee_id: str, target_supervisor_id: Optional[str],
                          action: str, details: Optional[str]) -> AdminOverride:

    # Validate that admin_employee_id exists in the supervisors table
    admin_exists = db.execute(
        text("SELECT 1 FROM supervisors WHERE employee_id = :admin_id"),
        {"admin_id": admin_employee_id}
    ).fetchone()

    if not admin_exists:
        raise ValueError(f"Admin employee ID {admin_employee_id} does not exist in the supervisors table.")

    o = AdminOverride(
        admin_employee_id=admin_employee_id,
        target_supervisor_id=target_supervisor_id,
        action=action,
        details=details
    )
    db.add(o)
    db.commit()
    db.refresh(o)
    return o


def admin_override_assign_supervisor_hostel(db: Session, admin_employee_id: str,
                                            target_supervisor_id: str, new_hostel_id: str) -> None:

    create_admin_override(
        db,
        admin_employee_id,
        target_supervisor_id,
        "assign_hostel",
        f"Assigned to {new_hostel_id}"
    )

    db.execute(
        text("INSERT INTO supervisor_hostels (employee_id, hostel_id) VALUES (:eid, :hid)"),
        {"eid": target_supervisor_id, "hid": new_hostel_id}
    )
    db.commit()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\token_repository.py ---
"""
Manage refresh tokens
"""
from sqlalchemy.orm import Session
from typing import Optional
from datetime import datetime, timedelta, timezone
from app.models.refresh_token import RefreshToken
from app.config import settings


class TokenRepository:
    def __init__(self, db: Session):
        self.db = db
    
    def create_token(self, user_id: int, token: str) -> RefreshToken:
        """Create refresh token"""
        expires_at = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
        refresh_token = RefreshToken(
            user_id=user_id,
            token=token,
            expires_at=expires_at,
            is_active=True
        )
        self.db.add(refresh_token)
        self.db.commit()
        self.db.refresh(refresh_token)
        return refresh_token
    
    def get_by_token(self, token: str) -> Optional[RefreshToken]:
        """Get refresh token by token string"""
        return self.db.query(RefreshToken).filter(
            RefreshToken.token == token,
            RefreshToken.is_active == True
        ).first()
    
    def revoke_token(self, token: str) -> bool:
        """Revoke a refresh token"""
        refresh_token = self.get_by_token(token)
        if not refresh_token:
            return False
        refresh_token.is_active = False
        self.db.commit()
        return True
    
    def revoke_all_user_tokens(self, user_id: int) -> int:
        """Revoke all tokens for a user"""
        tokens = self.db.query(RefreshToken).filter(
            RefreshToken.user_id == user_id,
            RefreshToken.is_active == True
        ).all()
        count = len(tokens)
        for token in tokens:
            token.is_active = False
        self.db.commit()
        return count
    
    def cleanup_expired_tokens(self) -> int:
        """Remove expired tokens"""
        expired = self.db.query(RefreshToken).filter(
            RefreshToken.expires_at < datetime.now(timezone.utc)
        ).all()
        count = len(expired)
        for token in expired:
            self.db.delete(token)
        self.db.commit()
        return count



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\user_repository.py ---
"""
Fetch/create/update users
"""
from sqlalchemy.orm import Session
from typing import Optional, List
from app.models.user import User
from app.schemas.user import UserCreate, UserUpdate
from app.core.security import get_password_hash
from app.repositories.base_repository import BaseRepository
from app.core.roles import Role


class UserRepository(BaseRepository):
    def __init__(self, db: Session, user_role: Optional[str] = None, active_hostel_id: Optional[int] = None, user_hostel_ids: Optional[List[int]] = None):
        super().__init__(db, user_role, active_hostel_id, user_hostel_ids)
    
    def get_by_id(self, user_id: int) -> Optional[User]:
        """Get user by ID"""
        return self.db.query(User).filter(User.id == user_id).first()
    
    def get_by_email(self, email: str) -> Optional[User]:
        """Get user by email"""
        return self.db.query(User).filter(User.email == email).first()

    def get_by_phone_number(self, phone_number: str) -> Optional[User]:
        """Get user by phone_number"""
        return self.db.query(User).filter(User.phone_number == phone_number).first()
    
    def get_by_username(self, username: str) -> Optional[User]:
        """Get user by username"""
        return self.db.query(User).filter(User.username == username).first()
    
    def get_all(self, skip: int = 0, limit: int = 100, hostel_id: Optional[int] = None) -> List[User]:
        """Get all users, automatically filtered by hostel access"""
        query = self.db.query(User)
        
        # If explicit hostel_id provided, use it (after validation)
        if hostel_id:
            if not self._validate_hostel_access(hostel_id):
                return []  # No access to this hostel
            query = query.filter(User.hostel_id == hostel_id)
        else:
            # Apply automatic filtering based on user role and access
            query = self._apply_hostel_filter(query, User.hostel_id)
        
        return query.offset(skip).limit(limit).all()
    
    def create(self, user_data: UserCreate) -> User:
        """Create new user"""
        hashed_password = None
        if user_data.password:
            hashed_password = get_password_hash(user_data.password)
        # Normalize hostel_id: treat 0 or other falsy values as None to avoid FK violations
        raw_hostel_id = getattr(user_data, 'hostel_id', None)
        try:
            hostel_id = int(raw_hostel_id) if raw_hostel_id is not None else None
            if hostel_id is not None and hostel_id <= 0:
                hostel_id = None
        except Exception:
            hostel_id = None

        db_user = User(
            email=user_data.email,
            phone_number=getattr(user_data, 'phone_number', None),
            country_code=getattr(user_data, 'country_code', None),
            username=user_data.username,
            hashed_password=hashed_password,
            full_name=user_data.full_name,
            role=user_data.role,
            hostel_id=hostel_id
        )
        self.db.add(db_user)
        try:
            self.db.commit()
            self.db.refresh(db_user)
        except Exception:
            # surface a clearer error for foreign-key/constraint issues
            self.db.rollback()
            raise
        return db_user
    
    def update(self, user_id: int, user_data: UserUpdate) -> Optional[User]:
        """Update user"""
        db_user = self.get_by_id(user_id)
        if not db_user:
            return None
        
        update_data = user_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_user, field, value)
        
        self.db.commit()
        self.db.refresh(db_user)
        return db_user
    
    def delete(self, user_id: int) -> bool:
        """Delete user"""
        db_user = self.get_by_id(user_id)
        if not db_user:
            return False
        self.db.delete(db_user)
        self.db.commit()
        return True



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\visitor_repository.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\waitlist_repository.py ---
from sqlalchemy.orm import Session
from app.models.waitlist import Waitlist
from app.schemas.waitlist import WaitlistCreate


class WaitlistRepository:

    @staticmethod
    def add(db: Session, data: WaitlistCreate):
        entry = Waitlist(**data.dict())
        db.add(entry)
        db.commit()
        db.refresh(entry)
        return entry

    @staticmethod
    def get_next(db: Session, hostel_id: int, room_type: str):
        return db.query(Waitlist).filter(
            Waitlist.hostel_id == hostel_id,
            Waitlist.room_type == room_type
        ).order_by(Waitlist.priority.asc()).first()

    @staticmethod
    def remove(db: Session, entry_id: int):
        db.query(Waitlist).filter(Waitlist.id == entry_id).delete()
        db.commit()

    # ⭐ NEW — Get a waitlist entry by ID (required for promote/delete)
    @staticmethod
    def get_by_id(db: Session, entry_id: int):
        return db.query(Waitlist).filter(Waitlist.id == entry_id).first()

    # ⭐ NEW — List all entries (used by admin or scheduler)
    @staticmethod
    def list_all(db: Session, hostel_id: int, room_type: str = None):
        q = db.query(Waitlist).filter(Waitlist.hostel_id == hostel_id)
        if room_type:
            q = q.filter(Waitlist.room_type == room_type)
        return q.order_by(Waitlist.priority.asc(), Waitlist.created_at.asc()).all()

    # ⭐ NEW — Get top priority entry (shortcut)
    @staticmethod
    def get_top(db: Session, hostel_id: int, room_type: str):
        return (
            db.query(Waitlist)
            .filter(
                Waitlist.hostel_id == hostel_id,
                Waitlist.room_type == room_type
            )
            .order_by(Waitlist.priority.asc(), Waitlist.created_at.asc())
            .first()
        )

    # ⭐ NEW — Count entries for priority assignment
    @staticmethod
    def count(db: Session, hostel_id: int, room_type: str):
        return db.query(Waitlist).filter(
            Waitlist.hostel_id == hostel_id,
            Waitlist.room_type == room_type
        ).count()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\__init__.py ---
# Re-export repository modules for convenience
from . import subscription_repository, admin_repository, hostel_repository

__all__ = [
    'subscription_repository',
    'admin_repository',
    'hostel_repository',
]



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\repositories\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\Scheduler =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\Scheduler\reminder_scheduler.py ---
# app/scheduler/reminder_scheduler.py

from app.Scheduler.reminder_scheduler import BackgroundScheduler
from app.Scheduler.reminder_scheduler import CronTrigger
from app.core.database import SessionLocal
from app.services.reminder_services import process_automated_reminders

scheduler = BackgroundScheduler()


def start_scheduler():

    scheduler.add_job(
        run_reminder_job,
        CronTrigger(minute="0"),   # Every hour on the hour
        id="hourly_reminder_job",
        replace_existing=True
    )

    scheduler.add_job(
        run_reminder_job,
        CronTrigger(hour="9", minute="0"),  # Every day 9 AM
        id="daily_reminder_job",
        replace_existing=True
    )

    scheduler.start()


def stop_scheduler():
    scheduler.shutdown(wait=False)


def run_reminder_job():
    db = SessionLocal()
    try:
        process_automated_reminders(db)
    finally:
        db.close()



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\Scheduler\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\admin_schemas.py ---
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import List, Optional
from enum import Enum

class PermissionLevel(str, Enum):
    read = "read"
    write = "write"
    admin = "admin"

class AdminBase(BaseModel):
    admin_name: str
    email: EmailStr
    is_active: bool = True

class AdminCreate(AdminBase):
    pass

class AdminResponse(AdminBase):
    id: int
    joined_at: datetime

    class Config:
        from_attributes = True

class AdminHostelAssignmentBase(BaseModel):
    permission_level: PermissionLevel = PermissionLevel.read

class AdminHostelAssignmentCreate(AdminHostelAssignmentBase):
    hostel_id: int

class AdminHostelAssignmentResponse(AdminHostelAssignmentBase):
    id: int
    admin_id: int
    hostel_id: int
    assigned_at: datetime

    class Config:
        from_attributes = True

class BulkAssignmentRequest(BaseModel):
    admin_id: int
    hostel_ids: List[int]
    permission_level: PermissionLevel = PermissionLevel.read

class BulkAssignmentResponse(BaseModel):
    success: bool
    message: str
    assignments: List[AdminHostelAssignmentResponse]

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\analytics.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\announcement.py ---
# app/schemas/announcement.py
from datetime import datetime
from typing import Optional, List
from pydantic import BaseModel
from app.models.announcement import AnnouncementCategory, AnnouncementStatus

class AnnouncementCreate(BaseModel):
    announcement_title: str
    announcement_content: str
    announcement_category: Optional[AnnouncementCategory] = AnnouncementCategory.GENERAL
    target_audience: Optional[str] = "all"
    scheduled_date: Optional[datetime] = None
    is_emergency: Optional[bool] = False
    attachments: Optional[List[str]] = []

class AnnouncementRead(BaseModel):
    id: int
    announcement_title: str
    announcement_content: str
    announcement_category: AnnouncementCategory
    target_audience: Optional[str]
    scheduled_date: Optional[datetime]
    is_emergency: bool
    status: AnnouncementStatus
    attachments: List[str]
    created_by_id: Optional[int]
    created_at: datetime
    approved: bool

    class Config:
        orm_mode = True

class AnnouncementUpdate(BaseModel):
    announcement_title: Optional[str] = None
    announcement_content: Optional[str] = None
    announcement_category: Optional[AnnouncementCategory] = None
    target_audience: Optional[str] = None
    scheduled_date: Optional[datetime] = None
    is_emergency: Optional[bool] = None
    attachments: Optional[List[str]] = None
    status: Optional[AnnouncementStatus] = None


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\approval.py ---
"""
Approval request schemas
"""
from pydantic import BaseModel
from typing import Optional
from datetime import datetime
from app.models.approval_request import ApprovalStatus


class ApprovalRequestBase(BaseModel):
    action: str
    resource_type: str
    resource_id: Optional[int] = None
    hostel_id: Optional[int] = None
    request_details: Optional[str] = None
    threshold_level: int = 1


class ApprovalRequestCreate(ApprovalRequestBase):
    pass


class ApprovalRequestUpdate(BaseModel):
    status: Optional[str] = None
    approval_notes: Optional[str] = None


class ApprovalRequestResponse(ApprovalRequestBase):
    id: int
    requester_id: int
    approver_id: Optional[int] = None
    status: str
    approval_notes: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    approved_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True


class ApprovalAction(BaseModel):
    """Action requiring approval"""
    action: str
    resource_type: str
    resource_id: Optional[int] = None
    threshold_level: int = 1  # Minimum role level required to approve



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\attendance.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\audit.py ---
"""
Audit log schemas
"""
from pydantic import BaseModel
from typing import Optional
from datetime import datetime


class AuditLogBase(BaseModel):
    action: str
    resource: str
    hostel_id: Optional[int] = None
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    details: Optional[str] = None


class AuditLogResponse(AuditLogBase):
    id: int
    user_id: int
    created_at: datetime
    
    class Config:
        from_attributes = True


class AuditLogFilter(BaseModel):
    user_id: Optional[int] = None
    hostel_id: Optional[int] = None
    action: Optional[str] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\auth.py ---
"""
Login, register, token schemas
"""
from pydantic import BaseModel, EmailStr, model_validator
from typing import Optional


class UserRegister(BaseModel):
    email: Optional[EmailStr] = None
    phone_number: Optional[str] = None
    country_code: Optional[str] = None
    username: str
    password: str
    full_name: Optional[str] = None
    role: Optional[str] = "visitor"


class UserLogin(BaseModel):
    # Allow login by a single identifier (email OR phone) supplied as `email_or_phone`.
    # `remember_me` is optional and can be used by the client to request longer-lived tokens.
    email_or_phone: Optional[str] = None
    password: str
    remember_me: Optional[bool] = False

    @model_validator(mode='after')
    def validate_identifier(self):
        if not self.email_or_phone:
            raise ValueError('Either email or phone must be provided in `email_or_phone`')
        return self


class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class TokenData(BaseModel):
    user_id: Optional[int] = None
    username: Optional[str] = None


class RefreshTokenRequest(BaseModel):
    refresh_token: str


class RefreshTokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\auth_enhanced.py ---
"""
Enhanced authentication schemas with OTP, social login, password reset
"""
from pydantic import BaseModel, EmailStr, validator
from typing import Optional
import re





class UserLoginEnhanced(BaseModel):
    """Enhanced login with email/phone"""
    email_or_phone: str  # Can be email or phone
    password: str
    remember_me: bool = False


class PasswordResetRequest(BaseModel):
    """Request password reset"""
    email_or_phone: str  # Can be email or phone


class PasswordResetVerify(BaseModel):
    """Verify reset code/token"""
    email_or_phone: str
    reset_code: Optional[str] = None  # For SMS
    reset_token: Optional[str] = None  # For email link


class PasswordResetComplete(BaseModel):
    """Complete password reset"""
    reset_token: Optional[str] = None
    reset_code: Optional[str] = None
    email_or_phone: str
    new_password: str
    confirm_password: str
    
    @validator('confirm_password')
    def passwords_match(cls, v, values):
        if 'new_password' in values and v != values['new_password']:
            raise ValueError('Passwords do not match')
        return v
    
    @validator('new_password')
    def validate_password_strength(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not re.search(r'\d', v):
            raise ValueError('Password must contain at least one number')
        return v




class PasswordStrengthResponse(BaseModel):
    """Password strength indicator"""
    strength: str  # 'weak', 'medium', 'strong'
    score: int  # 0-100
    feedback: list[str]  # Suggestions for improvement




# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\auth_schemas.py ---
from pydantic import BaseModel, EmailStr
from typing import Optional

class UserRegister(BaseModel):
    name: str
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    password: str

class UserResponse(BaseModel):
    id: int
    name: str
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    is_verified: bool

    class Config:
        from_attributes = True  # Pydantic v2 replacement for orm_mode

class OTPVerify(BaseModel):
    otp_code: str
    email: Optional[EmailStr] = None
    phone: Optional[str] = None

class OTPResend(BaseModel):
    email: Optional[EmailStr] = None
    phone: Optional[str] = None

class Token(BaseModel):
    access_token: str
    token_type: str

# <<<< Make sure this exists
class UserLogin(BaseModel):
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    password: str


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\beds.py ---
from __future__ import annotations
from typing import Optional
from datetime import datetime
from pydantic import BaseModel
from app.models.beds import BedStatus  # from app.models.beds.py

# BED SCHEMAS

class BedBase(BaseModel):
    hostel_id: Optional[str] = None
    bed_number: str
    room_number: str
    bed_status: BedStatus = BedStatus.AVAILABLE
    monthly_price: Optional[float] = None
    quarterly_price: Optional[float] = None
    annual_price: Optional[float] = None


class BedCreate(BedBase):
    pass


class BedUpdate(BaseModel):
    hostel_id: Optional[str] = None
    bed_number: Optional[str] = None
    room_number: Optional[str] = None
    bed_status: Optional[BedStatus] = None
    monthly_price: Optional[float] = None
    quarterly_price: Optional[float] = None
    annual_price: Optional[float] = None


class BedOut(BedBase):
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\booking.py ---
from pydantic import BaseModel
from datetime import datetime
from enum import Enum


class BookingStatus(str, Enum):
    pending = "pending"
    confirmed = "confirmed"
    cancelled = "cancelled"
    rejected = "rejected"




class BookingCreate(BaseModel):
    visitor_id: int
    hostel_id: int
    room_id: int
    check_in: datetime
    check_out: datetime
    amount_paid: float = 0   # Required for model

# Add BookingCreateSchema alias for compatibility
class BookingCreateSchema(BookingCreate):
    pass



class BookingUpdate(BaseModel):
    check_in: datetime | None = None
    check_out: datetime | None = None
    room_id: int | None = None

# Add BookingUpdateSchema alias for compatibility
class BookingUpdateSchema(BookingUpdate):
    pass



class BookingStatusUpdate(BaseModel):
    status: BookingStatus

# Add BookingStatusUpdateSchema alias for compatibility
class BookingStatusUpdateSchema(BookingStatusUpdate):
    pass



class BookingResponse(BaseModel):
    id: int
    visitor_id: int
    hostel_id: int
    room_id: int
    check_in: datetime
    check_out: datetime
    status: BookingStatus
    amount_paid: float

    class Config:
        from_attributes = True   # Pydantic v2 replacement for orm_mode

# Add BookingResponseSchema alias for compatibility
class BookingResponseSchema(BookingResponse):
    pass


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\booking_schema.py ---
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime
from enum import Enum


class BookingStatus(str, Enum):
    Pending = "Pending"
    Approved = "Approved"
    Rejected = "Rejected"
    Completed = "Completed"


class BookingCreate(BaseModel):
    full_name: str
    phone_number: str
    email: EmailStr
    id_type: str
    id_number: str
    id_document: Optional[str] = None
    emergency_contact_name: str
    emergency_contact_number: str
    emergency_contact_relation: Optional[str] = None
    special_requirements: Optional[str] = None


class BookingResponse(BaseModel):
    id: int
    status: BookingStatus
    created_at: datetime

    class Config:
        orm_mode = True


class BookingStatusUpdate(BaseModel):
    status: BookingStatus



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\cancel_booking.py ---
from pydantic import BaseModel
from enum import Enum


class BookingStatus(str, Enum):
    pending = "pending"
    confirmed = "confirmed"
    cancelled = "cancelled"
    rejected = "rejected"


class CancelBookingResponse(BaseModel):
    message: str
    refund_amount: float
    status: BookingStatus
    booking_id: int


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\common.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\comparison.py ---
from pydantic import BaseModel, validator
from typing import List, Union


class HostelComparisonRequest(BaseModel):
    hostel_ids: List[Union[int, str]]

    @validator('hostel_ids')
    def validate_and_normalize(cls, v):
        if not v:
            raise ValueError('hostel_ids must be a non-empty list')
        if len(v) > 4:
            raise ValueError('Cannot compare more than 4 hostels')
        # Normalize all IDs to strings for DB queries (DB uses string IDs in models)
        return [str(x).strip() for x in v]


class HostelComparisonItem(BaseModel):
    hostel_id: Union[int, str]
    pricing: dict
    amenities: List[str]
    location: Union[str, None]
    rooms_count: int
    beds_count: int
    available_beds: int


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\complaint.py ---
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
from enum import Enum


# -------------------- ENUMS --------------------

class ComplaintCategory(str, Enum):
    room_maintenance = "room_maintenance"
    mess_quality = "mess_quality"
    cleanliness = "cleanliness"
    security = "security"
    wifi= "wifi"
    other = "other"


class ComplaintPriority(str, Enum):
    low = "low"
    medium = "medium"
    high = "high"
    urgent = "urgent"


class ComplaintStatus(str, Enum):
    pending = "pending"
    in_progress = "in_progress"
    escalated = "escalated"
    resolved = "resolved"
    closed = "closed"
    reopened = "reopened"


# -------------------- BASE SCHEMAS --------------------

class ComplaintBase(BaseModel):
    title: str
    description: str
    category: ComplaintCategory
    priority: Optional[ComplaintPriority] = ComplaintPriority.medium
    hostel_name: str
    room_number: Optional[str] = None


class ComplaintCreate(ComplaintBase):
    student_name: str
    student_email: str


class ComplaintUpdate(BaseModel):
    title: Optional[str]
    description: Optional[str]
    status: Optional[ComplaintStatus]
    priority: Optional[ComplaintPriority]
    assigned_to_name: Optional[str]
    assigned_to_email: Optional[str]
    resolution_notes: Optional[str]
    is_escalated: Optional[bool]
    escalation_reason: Optional[str]


class ComplaintAssignment(BaseModel):
    assigned_to_name: str
    assigned_to_email: str


class ComplaintResolution(BaseModel):
    resolution_notes: str
    resources_used: Optional[str] = None
    actual_cost: Optional[float] = None


class ComplaintFeedback(BaseModel):
    student_feedback: str
    student_rating: int = Field(..., ge=1, le=5)


class ComplaintReopen(BaseModel):
    reopen_reason: str


class ComplaintNoteCreate(BaseModel):
    note: str
    user_name: str
    user_email: str
    is_internal: bool = False


class ComplaintFilter(BaseModel):
    student_email: Optional[str] = None
    hostel_id: Optional[int] = None
    hostel_name: Optional[str] = None
    category: Optional[str] = None
    status: Optional[str] = None
    priority: Optional[str] = None
    assigned_to_email: Optional[str] = None
    is_escalated: Optional[bool] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    page: int = 1
    page_size: int = 10


# -------------------- RESPONSE SCHEMAS --------------------

class ComplaintResponse(BaseModel):
    id: int
    title: str
    description: str
    category: ComplaintCategory
    priority: ComplaintPriority
    status: ComplaintStatus
    student_name: str
    student_email: str
    hostel_name: str
    assigned_to_name: Optional[str]
    assigned_to_email: Optional[str]
    created_at: datetime

    class Config:
        from_attributes = True  # Replaces orm_mode in Pydantic v2


class ComplaintAttachmentResponse(BaseModel):
    id: int
    file_name: str
    file_type: str
    file_size: int
    uploaded_by: str
    created_at: datetime

    class Config:
        from_attributes = True


class ComplaintNoteResponse(BaseModel):
    id: int
    note: str
    user_name: str
    user_email: str
    is_internal: bool
    created_at: datetime

    class Config:
        from_attributes = True


class ComplaintDetailResponse(ComplaintResponse):
    attachments: List[ComplaintAttachmentResponse] = []
    notes: List[ComplaintNoteResponse] = []


class ComplaintListResponse(BaseModel):
    total: int
    page: int
    page_size: int
    total_pages: int
    complaints: List[ComplaintResponse]


# -------------------- ANALYTICS / PERFORMANCE --------------------

class SupervisorPerformance(BaseModel):
    supervisor_email: str
    total_complaints: int
    resolved_complaints: int
    average_resolution_time_hours: Optional[float]


class ComplaintAnalytics(BaseModel):
    total_complaints: int
    open_complaints: int
    resolved_complaints: int
    average_resolution_time_hours: Optional[float]
    category_distribution: dict


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\fee_structure_schemas.py ---
from pydantic import BaseModel
from typing import Optional, List
from enum import Enum

class FeeFrequency(str, Enum):
    monthly = "monthly"
    quarterly = "quarterly"
    annual = "annual"

# -------- Hostel --------
class HostelBase(BaseModel):
    hostel_name: str
    full_address: Optional[str] = None
    capacity: Optional[int] = 0

class HostelCreate(HostelBase):
    pass

class HostelRead(HostelBase):
    id: int
    class Config:
        orm_mode = True

# -------- Fee Plan --------
class FeePlanBase(BaseModel):
    hostel_id: int
    plan_name: str
    frequency: FeeFrequency
    amount: float
    room_type: Optional[str] = None
    description: Optional[str] = None

class FeePlanCreate(FeePlanBase):
    pass

class FeePlanRead(FeePlanBase):
    id: int
    class Config:
        orm_mode = True

# -------- Security Deposit --------
class SecurityDepositBase(BaseModel):
    hostel_id: int
    name: str
    amount: float
    refundable: Optional[bool] = True

class SecurityDepositCreate(SecurityDepositBase):
    pass

class SecurityDepositRead(SecurityDepositBase):
    id: int
    class Config:
        orm_mode = True

# -------- Mess Charge --------
class MessChargeBase(BaseModel):
    hostel_id: int
    meal_type: str
    frequency: FeeFrequency
    amount: float
    is_mandatory: Optional[bool] = True

class MessChargeCreate(MessChargeBase):
    pass

class MessChargeRead(MessChargeBase):
    id: int
    class Config:
        orm_mode = True

# -------- Additional Service --------
class AdditionalServiceBase(BaseModel):
    hostel_id: int
    service_name: str
    amount: float
    frequency: FeeFrequency
    description: Optional[str] = None

class AdditionalServiceCreate(AdditionalServiceBase):
    pass

class AdditionalServiceRead(AdditionalServiceBase):
    id: int
    class Config:
        orm_mode = True


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\hostel.py ---
"""
Hostel-related schemas
"""
from pydantic import BaseModel
from typing import Optional
from datetime import datetime


class HostelBase(BaseModel):
    name: str
    address: Optional[str] = None
    capacity: Optional[int] = None


class HostelCreate(HostelBase):
    pass


class HostelUpdate(BaseModel):
    name: Optional[str] = None
    address: Optional[str] = None
    capacity: Optional[int] = None
    is_active: Optional[bool] = None


class HostelResponse(HostelBase):
    id: int
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\maintenance.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\mess_menu.py ---
from pydantic import BaseModel, Field, validator
from typing import Optional, List, Dict, Any
from datetime import datetime, date, time
from enum import Enum


class MenuTypeEnum(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"


class MealTypeEnum(str, Enum):
    BREAKFAST = "breakfast"
    LUNCH = "lunch"
    SNACKS = "snacks"
    DINNER = "dinner"


class DietTypeEnum(str, Enum):
    REGULAR = "regular"
    VEGETARIAN = "vegetarian"
    VEGAN = "vegan"
    GLUTEN_FREE = "gluten_free"
    DIABETIC = "diabetic"
    ALLERGEN_FREE = "allergen_free"


class MenuStatusEnum(str, Enum):
    DRAFT = "draft"
    PENDING_APPROVAL = "pending_approval"
    APPROVED = "approved"
    PUBLISHED = "published"
    ARCHIVED = "archived"


class MenuItem(BaseModel):
    name: str
    description: Optional[str] = None
    diet_types: List[str] = []


class NutritionalInfo(BaseModel):
    calories: Optional[float] = None
    protein: Optional[float] = None
    carbs: Optional[float] = None
    fat: Optional[float] = None
    fiber: Optional[float] = None


# Menu Schemas
class MessMenuBase(BaseModel):
    hostel_id: int
    menu_type: MenuTypeEnum
    menu_date: date
    meal_type: MealTypeEnum
    items: List[Dict[str, Any]]
    serving_time_start: Optional[time] = None
    serving_time_end: Optional[time] = None
    diet_types: List[str] = []
    nutritional_info: Optional[Dict[str, Any]] = None
    notes: Optional[str] = None
    is_special_occasion: bool = False
    occasion_name: Optional[str] = None


class MessMenuCreate(MessMenuBase):
    created_by: int
    created_by_role: str
    status: MenuStatusEnum = MenuStatusEnum.DRAFT


class MessMenuUpdate(BaseModel):
    menu_type: Optional[MenuTypeEnum] = None
    menu_date: Optional[date] = None
    meal_type: Optional[MealTypeEnum] = None
    items: Optional[List[Dict[str, Any]]] = None
    serving_time_start: Optional[time] = None
    serving_time_end: Optional[time] = None
    diet_types: Optional[List[str]] = None
    nutritional_info: Optional[Dict[str, Any]] = None
    notes: Optional[str] = None
    is_special_occasion: Optional[bool] = None
    occasion_name: Optional[str] = None
    status: Optional[MenuStatusEnum] = None


class MessMenuResponse(MessMenuBase):
    id: int
    status: MenuStatusEnum
    created_by: int
    created_by_role: str
    approved_by: Optional[int] = None
    approved_at: Optional[datetime] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# Feedback Schemas
class MenuFeedbackBase(BaseModel):
    menu_id: int
    rating: int = Field(..., ge=1, le=5)
    taste_rating: Optional[int] = Field(None, ge=1, le=5)
    quantity_rating: Optional[int] = Field(None, ge=1, le=5)
    hygiene_rating: Optional[int] = Field(None, ge=1, le=5)
    comments: Optional[str] = None


class MenuFeedbackCreate(MenuFeedbackBase):
    student_id: int


class MenuFeedbackResponse(MenuFeedbackBase):
    id: int
    student_id: int
    created_at: datetime

    class Config:
        from_attributes = True


# Meal Preference Schemas
class MealPreferenceBase(BaseModel):
    hostel_id: int
    diet_type: DietTypeEnum
    allergies: Optional[List[str]] = None
    medical_requirements: Optional[str] = None
    preferred_items: Optional[List[str]] = None
    disliked_items: Optional[List[str]] = None


class MealPreferenceCreate(MealPreferenceBase):
    student_id: int


class MealPreferenceUpdate(BaseModel):
    diet_type: Optional[DietTypeEnum] = None
    allergies: Optional[List[str]] = None
    medical_requirements: Optional[str] = None
    preferred_items: Optional[List[str]] = None
    disliked_items: Optional[List[str]] = None
    is_active: Optional[bool] = None


class MealPreferenceResponse(MealPreferenceBase):
    id: int
    student_id: int
    menu_id: Optional[int] = None
    is_active: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# Menu Duplication Schema
class MenuDuplicationRequest(BaseModel):
    source_menu_id: int
    target_hostel_ids: List[int]
    target_date: Optional[date] = None
    preserve_timings: bool = True


# Approval Schema
class MenuApprovalRequest(BaseModel):
    approved_by: int
    notes: Optional[str] = None

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\notification.py ---
from typing import Optional, Dict, Any
from datetime import datetime
from pydantic import BaseModel


class NotificationCreate(BaseModel):
    recipient_id: str
    recipient_type: str
    channel: str
    subject: Optional[str] = None
    body: Optional[str] = None
    template_name: Optional[str] = None
    template_context: Optional[Dict[str, Any]] = None


class NotificationOut(BaseModel):
    id: int
    recipient_id: str
    recipient_type: str
    channel: str
    subject: Optional[str]
    body: Optional[str]
    sent: bool

    class Config:
        orm_mode = True


class TemplateCreate(BaseModel):
    name: str
    channel: str
    subject_template: Optional[str] = None
    body_template: Optional[str] = None


class TemplateOut(BaseModel):
    id: int
    name: str
    channel: str
    subject_template: Optional[str]
    body_template: Optional[str]
    created_at: Optional[datetime]   # ✅ FIXED

    class Config:
        orm_mode = True


class ProviderStatus(BaseModel):
    sendgrid: bool
    twilio: bool
    fcm: bool


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\payment.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\payment_schemas.py ---
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from datetime import datetime

# Enums imported from your models
from app.models.payment_models import (
    PaymentGateway,
    PaymentStatus,
    PaymentMethod,
    TransactionType,
    RefundStatus,
    ReminderType,
    ReminderChannel,
    ReminderStatus
)

# =====================================================================
# 🟦 GENERAL PAYMENT CREATION (User/Hostel Payments)
# =====================================================================

class PaymentCreate(BaseModel):
    amount: float = Field(gt=0)
    currency: str = "INR"
    user_id: int
    hostel_id: int
    description: Optional[str] = None
    notes: Optional[Dict[str, Any]] = None


class PaymentResponse(BaseModel):
    id: int
    order_id: str
    gateway_order_id: Optional[str]
    payment_id: Optional[str]
    gateway: PaymentGateway
    amount: float
    currency: str
    status: PaymentStatus
    payment_method: Optional[PaymentMethod]
    user_id: int
    hostel_id: int
    description: Optional[str]
    created_at: datetime
    paid_at: Optional[datetime]

    class Config:
        from_attributes = True


# =====================================================================
# 🟦 BOOKING PAYMENT SCHEMAS (Visitor/Admin Booking Payments)
# =====================================================================

class BookingPaymentCreate(BaseModel):
    booking_id: int
    payment_type: str
    amount: float
    currency: str = "INR"
    payment_method: Optional[str] = None
    payment_gateway: Optional[str] = None
    description: Optional[str] = None


class BookingPaymentResponse(BaseModel):
    id: Optional[int]
    booking_id: int
    payment_reference: Optional[str]
    payment_type: str
    amount: float
    currency: str
    status: str
    payment_method: Optional[str]
    payment_gateway: Optional[str]
    gateway_transaction_id: Optional[str]
    gateway_order_id: Optional[str]
    is_security_deposit: bool
    security_deposit_refunded: bool
    initiated_at: Optional[datetime]
    completed_at: Optional[datetime]

    class Config:
        from_attributes = True


# =====================================================================
# 🟦 RAZORPAY ORDER
# =====================================================================

class RazorpayOrderResponse(BaseModel):
    order_id: str
    gateway_order_id: str
    amount: float
    currency: str
    key_id: str
    payment_record_id: int


class PaymentVerification(BaseModel):
    razorpay_order_id: str
    razorpay_payment_id: str
    razorpay_signature: str


class CreateOrderRequest(BaseModel):
    amount: float
    currency: str = "INR"
    hostel_id: int
    description: Optional[str] = None


# =====================================================================
# 🟦 REFUND MODELS (Unified)
# =====================================================================


# Add RefundRequest for compatibility with payment_routers.py
class RefundRequest(BaseModel):
    payment_id: str | int
    amount: Optional[float] = None
    reason: Optional[str] = None

class RefundCreate(BaseModel):
    payment_id: str | int
    amount: Optional[float] = None
    reason: Optional[str] = None


class RefundResponse(BaseModel):
    id: int
    payment_id: str | int
    refund_id: Optional[str]
    refund_reference: Optional[str] = None
    amount: float
    reason: Optional[str]
    status: str
    created_at: Optional[datetime]
    initiated_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    invoice_id: Optional[int] = None
    transaction_id: Optional[int] = None

    class Config:
        from_attributes = True


# ---------------------------------------------------------------------
# Security Deposit Release
# ---------------------------------------------------------------------

class SecurityDepositReleaseRequest(BaseModel):
    payment_id: int
    deduction_amount: float = 0.0
    reason: Optional[str] = None


class SecurityDepositReleaseResponse(BaseModel):
    message: str
    refund_amount: float
    deduction_amount: float
    payment_reference: str

    class Config:
        from_attributes = True


# =====================================================================
# 🟦 INVOICE MODELS
# =====================================================================

class InvoiceItem(BaseModel):
    description: str
    quantity: int = 1
    unit_price: float
    amount: float


class InvoiceCreate(BaseModel):
    user_id: int
    hostel_id: int
    items: List[InvoiceItem]
    description: Optional[str] = None
    due_date: datetime


class InvoiceResponse(BaseModel):
    id: int
    invoice_number: str
    user_id: int
    hostel_id: int
    total_amount: float
    paid_amount: float
    due_amount: float
    status: PaymentStatus
    issue_date: datetime
    due_date: datetime

    class Config:
        from_attributes = True


# =====================================================================
# 🟦 TRANSACTION MODELS
# =====================================================================

class TransactionCreate(BaseModel):
    invoice_id: int
    amount: float = Field(gt=0)
    payment_method: str
    payment_gateway: Optional[str] = None
    gateway_transaction_id: Optional[str] = None
    notes: Optional[str] = None


class TransactionResponse(BaseModel):
    id: int
    transaction_id: str
    invoice_id: int
    transaction_type: TransactionType
    amount: float
    payment_method: Optional[str]
    status: str
    created_at: datetime

    class Config:
        from_attributes = True


# =====================================================================
# 🟦 RECEIPT MODELS
# =====================================================================

class ReceiptResponse(BaseModel):
    id: int
    receipt_number: str
    invoice_id: int
    transaction_id: int
    amount: float
    generated_at: datetime
    pdf_available: bool

    class Config:
        from_attributes = True


# =====================================================================
# 🟦 REFUND APPROVAL WORKFLOW
# =====================================================================

class RefundApproval(BaseModel):
    approved_by: int
    approve: bool
    rejection_reason: Optional[str] = None


# =====================================================================
# 🟦 PAYMENT REMINDERS
# =====================================================================

class ReminderConfigCreate(BaseModel):
    hostel_id: int
    pre_due_days: str = "7,3,1"
    pre_due_channels: ReminderChannel = ReminderChannel.EMAIL
    due_date_enabled: bool = True
    due_date_channels: ReminderChannel = ReminderChannel.BOTH
    overdue_frequency_days: int = 3
    overdue_channels: ReminderChannel = ReminderChannel.BOTH
    escalation_enabled: bool = True
    escalation_1_days: int = 7
    escalation_2_days: int = 14
    escalation_3_days: int = 30
    final_notice_days: int = 45
    escalation_emails: Optional[List[str]] = None
    escalation_cc: Optional[List[str]] = None
    max_reminders: int = 10


class ReminderConfigResponse(BaseModel):
    id: int
    hostel_id: int
    pre_due_days: str
    overdue_frequency_days: int
    escalation_enabled: bool
    max_reminders: int

    class Config:
        from_attributes = True


class ManualReminderRequest(BaseModel):
    invoice_id: int
    reminder_type: ReminderType
    channel: ReminderChannel
    custom_message: Optional[str] = None


class PaymentReminderResponse(BaseModel):
    id: int
    reminder_id: str
    invoice_id: int
    reminder_type: ReminderType
    channel: ReminderChannel
    status: ReminderStatus
    scheduled_at: datetime

    class Config:
        from_attributes = True


# =====================================================================
# 🟦 TEMPLATE MANAGEMENT
# =====================================================================

class TemplateCreate(BaseModel):
    name: str
    reminder_type: ReminderType
    email_subject: str
    email_body: str
    sms_body: str


class TemplateResponse(BaseModel):
    id: int
    name: str
    reminder_type: ReminderType
    is_default: bool

    class Config:
        from_attributes = True


# =====================================================================
# 🟦 BOOKING CONFIRMATION PDF
# =====================================================================

class ConfirmationResponse(BaseModel):
    id: int
    booking_id: int
    confirmation_number: str
    confirmation_type: str
    pdf_content: str
    email_sent: bool
    generated_at: datetime

    class Config:
        from_attributes = True


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\permission.py ---
"""
Permission schema
"""
from pydantic import BaseModel
from typing import Optional
from datetime import datetime


class PermissionBase(BaseModel):
    name: str
    description: Optional[str] = None
    resource: Optional[str] = None
    action: Optional[str] = None


class PermissionCreate(PermissionBase):
    pass


class PermissionResponse(PermissionBase):
    id: int
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True


class RolePermissionAssign(BaseModel):
    role: str
    permission_id: int



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\rbac.py ---
"""
Role + permission schema
"""
from pydantic import BaseModel
from typing import List, Optional


class RoleAssign(BaseModel):
    user_id: int
    role: str


class RoleUpdate(BaseModel):
    role: str


class PermissionCheck(BaseModel):
    role: str
    permission: str


class RolePermissionsResponse(BaseModel):
    role: str
    permissions: List[str]



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\reports.py ---
from pydantic import BaseModel
from typing import List, Dict, Optional, Any
from datetime import date, datetime
from decimal import Decimal

class DateRangeFilter(BaseModel):
    start_date: date
    end_date: date
    hostel_ids: Optional[List[int]] = None

class KPISummary(BaseModel):
    total_revenue: Decimal
    total_expenses: Decimal
    net_profit: Decimal
    occupancy_rate: float
    total_complaints: int
    resolved_complaints: int
    average_resolution_time: float
    student_count: int
    
class HostelKPI(BaseModel):
    hostel_id: int
    hostel_name: str
    revenue: Decimal
    expenses: Decimal
    profit: Decimal
    occupancy_rate: float
    total_beds: int
    occupied_beds: int
    complaint_count: int
    resolved_complaints: int
    average_rating: float

class MultiHostelDashboard(BaseModel):
    summary: KPISummary
    hostels: List[HostelKPI]
    period: str
    generated_at: datetime

class RevenueComparison(BaseModel):
    hostel_id: int
    hostel_name: str
    current_period_revenue: Decimal
    previous_period_revenue: Decimal
    growth_rate: float
    monthly_breakdown: List[Dict[str, Any]]

class OccupancyTrend(BaseModel):
    hostel_id: int
    hostel_name: str
    date: date
    occupancy_rate: float
    occupied_beds: int
    total_beds: int

class ComplaintMetrics(BaseModel):
    hostel_id: int
    hostel_name: str
    total_complaints: int
    by_category: Dict[str, int]
    by_status: Dict[str, int]
    by_priority: Dict[str, int]
    average_resolution_time: float
    satisfaction_rating: float

class MarketingAnalytics(BaseModel):
    hostel_id: int
    hostel_name: str
    profile_views: int
    search_appearances: int
    inquiries: int
    bookings: int
    conversion_rate: float
    top_sources: List[Dict[str, Any]]

class AttendanceReport(BaseModel):
    hostel_id: int
    hostel_name: str
    date: date
    total_students: int
    present_count: int
    absent_count: int
    attendance_rate: float
    absent_students: List[Dict[str, str]]

class AttendanceTrend(BaseModel):
    hostel_id: int
    hostel_name: str
    period: str
    daily_trends: List[Dict[str, Any]]
    average_attendance_rate: float
    patterns: Dict[str, Any]

class StudentAttendanceHistory(BaseModel):
    student_id: int
    student_name: str
    hostel_id: int
    total_days: int
    present_days: int
    absent_days: int
    attendance_percentage: float
    recent_absences: List[date]

class ConsolidatedAttendanceReport(BaseModel):
    period: DateRangeFilter
    summary: Dict[str, Any]
    hostel_wise: List[AttendanceReport]
    trends: List[AttendanceTrend]
    generated_at: datetime

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\report_schemas.py ---
from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime as dt
from decimal import Decimal

# Booking Schemas
class BookingCreate(BaseModel):
    hostel_id: str
    hostel_name: str
    user_id: str
    user_name: str
    room_type: str
    check_in_date: dt
    check_out_date: dt
    amount: Decimal

class BookingResponse(BaseModel):
    id: str
    hostel_id: str
    hostel_name: str
    user_id: str
    user_name: str
    room_type: str
    check_in_date: dt
    check_out_date: dt
    amount: Decimal
    commission_rate: Decimal
    commission_amount: Decimal
    status: str
    payment_status: str
    created_at: dt

    class Config:
        from_attributes = True

# Commission Schemas
class CommissionResponse(BaseModel):
    id: str
    booking_id: str
    amount: Decimal
    status: str
    earned_date: dt
    paid_date: Optional[dt]
    hostel_id: str
    platform_revenue: Decimal

    class Config:
        from_attributes = True

# Report Schemas
class ReportGenerateRequest(BaseModel):
    report_type: str
    start_date: dt
    end_date: dt
    export_format: Optional[str] = "pdf"
    parameters: Optional[Dict[str, Any]] = {}

class ReportResponse(BaseModel):
    id: str
    name: str
    report_type: str
    start_date: dt
    end_date: dt
    generated_at: dt
    export_format: Optional[str]
    file_path: Optional[str]

    class Config:
        from_attributes = True

# Financial Summary Schemas
class FinancialSummaryResponse(BaseModel):
    total_income: Decimal
    subscription_revenue: Decimal
    commission_earned: Decimal
    pending_payments: Decimal
    total_bookings: int
    completed_bookings: int
    cancelled_bookings: int
    period_start: dt
    period_end: dt

    class Config:
        from_attributes = True

# Statistics Schemas
class ReportStatistics(BaseModel):
    generated_this_month: int
    automated_reports: int
    scheduled_reports: int


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\rooms.py ---
from __future__ import annotations
from typing import Optional
from datetime import datetime
from pydantic import BaseModel
from app.models.rooms import RoomType, MaintenanceStatus

# ROOM SCHEMAS

class RoomBase(BaseModel):
    hostel_id: Optional[str] = None
    room_number: str
    room_type: RoomType = RoomType.SINGLE
    room_capacity: int = 1
    monthly_price: Optional[float] = None
    quarterly_price: Optional[float] = None
    annual_price: Optional[float] = None
    availability: int = 0
    amenities: Optional[str] = None
    maintenance_status: MaintenanceStatus = MaintenanceStatus.OK


class RoomCreate(RoomBase):
    pass


class RoomUpdate(BaseModel):
    hostel_id: Optional[str] = None
    room_number: Optional[str] = None
    room_type: Optional[RoomType] = None
    room_capacity: Optional[int] = None
    monthly_price: Optional[float] = None
    quarterly_price: Optional[float] = None
    annual_price: Optional[float] = None
    availability: Optional[int] = None
    amenities: Optional[str] = None
    maintenance_status: Optional[MaintenanceStatus] = None


class RoomOut(RoomBase):
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\search.py ---
from pydantic import BaseModel, Field
from typing import Optional, List
from decimal import Decimal

class HostelSearchFilters(BaseModel):
    query: Optional[str] = None
    city: Optional[str] = None
    area: Optional[str] = None
    pincode: Optional[str] = None
    gender: Optional[str] = None
    min_price: Optional[Decimal] = None
    max_price: Optional[Decimal] = None
    amenities: Optional[List[str]] = None
    min_rating: Optional[float] = None
    available_only: bool = True
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    radius_km: Optional[float] = 5.0
    
class HostelSearchSort(BaseModel):
    sort_by: str = Field(default="rating", pattern="^(price_asc|price_desc|rating|distance|newest|popularity)$")
    
class HostelSearchRequest(BaseModel):
    filters: HostelSearchFilters
    sort: Optional[HostelSearchSort] = HostelSearchSort()
    page: int = Field(default=1, ge=1)
    page_size: int = Field(default=20, ge=1, le=100)

class HostelSearchResult(BaseModel):
    id: int
    name: str
    description: str
    location: str
    city: str
    area: str
    pincode: str
    latitude: Optional[Decimal]
    longitude: Optional[Decimal]
    gender: str
    contact_phone: str
    contact_email: str
    available_beds: int
    total_beds: int
    price_range_min: Decimal
    price_range_max: Decimal
    rating: float
    review_count: int
    amenities: List[str]
    photos: List[str]
    distance_km: Optional[float] = None
    
    class Config:
        from_attributes = True

class HostelSearchResponse(BaseModel):
    results: List[HostelSearchResult]
    total_count: int
    page: int
    page_size: int
    total_pages: int
    facets: Optional[dict] = None  # Faceted search aggregations

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\session.py ---
"""
Active session (switch hostel) schemas
"""
from pydantic import BaseModel
from typing import Optional
from datetime import datetime


class SessionContextBase(BaseModel):
    hostel_id: int


class SessionContextCreate(SessionContextBase):
    pass


class SessionContextResponse(SessionContextBase):
    id: int
    user_id: int
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True


class SwitchSessionRequest(BaseModel):
    hostel_id: int



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\shift_coordination_schemas.py ---
from pydantic import BaseModel
from typing import Optional
from datetime import datetime, date

class ShiftCreate(BaseModel):
    name: str
    start_time: str
    end_time: str
    hostel_id: int

class ShiftScheduleCreate(BaseModel):
    admin_id: int
    shift_id: int
    hostel_id: int
    scheduled_date: date
    notes: Optional[str] = None

class TaskCreate(BaseModel):
    title: str
    description: Optional[str] = None
    hostel_id: int
    assigned_to: int
    category: str
    priority: str = "medium"
    due_date: Optional[datetime] = None
    estimated_duration: Optional[int] = None

class TaskUpdate(BaseModel):
    status: Optional[str] = None
    priority: Optional[str] = None
    due_date: Optional[datetime] = None
    description: Optional[str] = None

class TaskDelegationCreate(BaseModel):
    task_id: int
    from_admin_id: int
    to_admin_id: int
    reason: str

class HandoverCreate(BaseModel):
    from_schedule_id: int
    to_schedule_id: int
    hostel_id: int
    occupancy_status: Optional[str] = None
    pending_checkouts: int = 0
    expected_checkins: int = 0
    urgent_issues: Optional[str] = None
    maintenance_required: Optional[str] = None
    guest_concerns: Optional[str] = None
    pending_tasks: Optional[str] = None
    completed_tasks: Optional[str] = None
    inventory_status: Optional[str] = None
    cash_handover: Optional[float] = None
    keys_status: Optional[str] = None
    notes: Optional[str] = None
    special_instructions: Optional[str] = None

class HandoverItemCreate(BaseModel):
    handover_id: int
    item_type: str
    title: str
    description: Optional[str] = None
    priority: str = "medium"

class CoordinationMeetingCreate(BaseModel):
    hostel_id: int
    coordination_date: date
    meeting_type: str
    participants: str
    agenda: Optional[str] = None
    discussion_points: Optional[str] = None
    decisions_made: Optional[str] = None
    action_items: Optional[str] = None
    next_meeting: Optional[datetime] = None


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\students.py ---
from __future__ import annotations
from typing import Optional
from datetime import date, datetime, time
from pydantic import BaseModel, EmailStr
from app.models.students import (
    PaymentType, PaymentMethod, AttendanceMode
)

# STUDENT SCHEMAS

class StudentBase(BaseModel):
    student_id: Optional[str] = None
    student_name: Optional[str] = None
    student_email: Optional[EmailStr] = None
    student_phone: Optional[str] = None
    date_of_birth: Optional[date] = None
    guardian_name: Optional[str] = None
    guardian_phone: Optional[str] = None
    emergency_contact: Optional[str] = None
    check_in_date: Optional[date] = None
    check_out_date: Optional[date] = None
    room_assignment: Optional[str] = None
    bed_assignment: Optional[str] = None
    status: Optional[str] = None


class StudentCreate(StudentBase):
    student_id: str
    student_name: str
    student_email: EmailStr
    student_phone: str


class StudentUpdate(BaseModel):
    student_name: Optional[str] = None
    student_email: Optional[EmailStr] = None
    student_phone: Optional[str] = None
    date_of_birth: Optional[date] = None
    guardian_name: Optional[str] = None
    guardian_phone: Optional[str] = None
    emergency_contact: Optional[str] = None
    check_in_date: Optional[date] = None
    room_assignment: Optional[str] = None
    bed_assignment: Optional[str] = None
    status: Optional[str] = None


class StudentOut(StudentBase):
    student_id: str

    class Config:
        from_attributes = True


# PAYMENT SCHEMAS

class PaymentBase(BaseModel):
    payment_type: PaymentType
    amount: float
    payment_method: PaymentMethod
    payment_date: date
    due_date: date
    transaction_id: str
    notes: Optional[str] = None
    status: str


class PaymentCreate(PaymentBase):
    student_name: Optional[str] = None  # Optional, student_id comes from path


class PaymentOut(PaymentBase):
    id: int
    student_id: str
    student_name: str
    created_at: datetime

    class Config:
        from_attributes = True


# ATTENDANCE SCHEMAS

class AttendanceBase(BaseModel):
    attendance_date: date
    attendance_mode: AttendanceMode
    check_in_time: time
    check_out_time: time
    is_late: bool
    notes: Optional[str] = None
    status: str


class AttendanceCreate(AttendanceBase):
    student_name: Optional[str] = None  # Optional, student_id comes from path


class AttendanceOut(AttendanceBase):
    id: int
    student_id: str
    student_name: str
    created_at: datetime

    class Config:
        from_attributes = True


# STUDENT DOCUMENT SCHEMAS

class StudentDocumentCreate(BaseModel):
    doc_type: Optional[str] = None
    doc_url: str


class StudentDocumentOut(StudentDocumentCreate):
    id: int
    student_id: str
    uploaded_at: datetime

    class Config:
        from_attributes = True


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\subscription.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\subscription_schemas.py ---
from pydantic import BaseModel, EmailStr, Field
from typing import Optional, List, Any
from datetime import datetime
from enum import Enum


# ───────────────────────────────────────────────────────────────
# ENUMS
# ───────────────────────────────────────────────────────────────
class PlanTier(str, Enum):
    free = "free"
    standard = "standard"
    premium = "premium"


class BillingCycle(str, Enum):
    monthly = "monthly"
    yearly = "yearly"


class SubscriptionStatus(str, Enum):
    active = "active"
    inactive = "inactive"
    canceled = "canceled"
    past_due = "past_due"
    trialing = "trialing"


class PaymentStatus(str, Enum):
    pending = "pending"
    succeeded = "succeeded"
    failed = "failed"
    refunded = "refunded"


class PaymentType(str, Enum):
    subscription = "subscription"
    upgrade = "upgrade"
    downgrade = "downgrade"
    refund = "refund"
    proration = "proration"


class ChangeType(str, Enum):
    upgrade = "upgrade"
    downgrade = "downgrade"
    cancel = "cancel"
    reactivate = "reactivate"


# ───────────────────────────────────────────────────────────────
# PLAN SCHEMAS
# ───────────────────────────────────────────────────────────────
class SubscriptionPlanBase(BaseModel):
    name: str
    tier: PlanTier
    billing_cycle: BillingCycle
    price: float
    currency: str = "USD"
    max_hostels: int
    max_admins: int
    max_students: int
    features: Optional[Any] = None


class SubscriptionPlanCreate(SubscriptionPlanBase):
    pass


class SubscriptionPlanResponse(SubscriptionPlanBase):
    id: str
    is_active: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# ───────────────────────────────────────────────────────────────
# SUBSCRIPTION SCHEMAS
# ───────────────────────────────────────────────────────────────
class SubscriptionBase(BaseModel):
    organization_id: str
    organization_name: str
    email: EmailStr
    plan_id: str
    status: SubscriptionStatus = SubscriptionStatus.active
    current_period_start: datetime
    current_period_end: datetime
    trial_end: Optional[datetime] = None


class SubscriptionCreate(SubscriptionBase):
    pass


class SubscriptionResponse(SubscriptionBase):
    id: str
    cancel_at_period_end: bool
    canceled_at: Optional[datetime] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# ───────────────────────────────────────────────────────────────
# PAYMENT SCHEMAS
# ───────────────────────────────────────────────────────────────
class PaymentBase(BaseModel):
    subscription_id: str
    amount: float
    currency: str = "USD"
    status: PaymentStatus = PaymentStatus.pending
    payment_type: PaymentType = PaymentType.subscription
    payment_method: Optional[str] = None
    payment_method_last4: Optional[str] = None
    description: Optional[str] = None


class PaymentCreate(PaymentBase):
    paid_at: Optional[datetime] = None


class PaymentResponse(PaymentBase):
    id: str
    paid_at: Optional[datetime]
    failed_at: Optional[datetime] = None
    refunded_at: Optional[datetime] = None
    created_at: datetime
    class Config:
        from_attributes = True
        populate_by_name = True
        json_encoders = {
            datetime: lambda dt: dt.isoformat() if dt else None
        }


# ───────────────────────────────────────────────────────────────
# SUBSCRIPTION CHANGE SCHEMAS
# ───────────────────────────────────────────────────────────────
class SubscriptionChangeBase(BaseModel):
    subscription_id: str
    change_type: ChangeType
    from_plan_id: Optional[str] = None
    to_plan_id: Optional[str] = None
    proration_amount: float = 0
    effective_date: datetime
    initiated_by: str
    reason: Optional[str] = None


class SubscriptionChangeCreate(SubscriptionChangeBase):
    pass


class SubscriptionChangeResponse(SubscriptionChangeBase):
    id: str
    created_at: datetime

    class Config:
        from_attributes = True


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\supervisors.py ---
from __future__ import annotations
from typing import Optional
from datetime import datetime
from pydantic import BaseModel, EmailStr
from app.models.supervisors import SupervisorRole, Department, AccessLevel

# SUPERVISOR SCHEMAS

class SupervisorBase(BaseModel):
    supervisor_name: Optional[str] = None
    supervisor_email: Optional[EmailStr] = None
    supervisor_phone: Optional[str] = None
    role: Optional[SupervisorRole] = None
    department: Optional[Department] = None
    access_level: Optional[AccessLevel] = None
    permissions: Optional[str] = None
    status: Optional[str] = None
    invitation_status: Optional[str] = None


class SupervisorCreate(SupervisorBase):
    employee_id: str
    supervisor_name: str
    supervisor_email: EmailStr
    supervisor_phone: str
    role: SupervisorRole


class SupervisorUpdate(BaseModel):
    supervisor_name: Optional[str] = None
    supervisor_email: Optional[EmailStr] = None
    supervisor_phone: Optional[str] = None
    role: Optional[SupervisorRole] = None
    department: Optional[Department] = None
    access_level: Optional[AccessLevel] = None
    permissions: Optional[str] = None
    status: Optional[str] = None
    invitation_status: Optional[str] = None


class SupervisorOut(SupervisorBase):
    employee_id: str

    class Config:
        from_attributes = True


# ADMIN OVERRIDE SCHEMAS

class AdminOverrideCreate(BaseModel):
    admin_employee_id: str
    action: str
    target_supervisor_id: Optional[str] = None
    details: Optional[str] = None


class AdminOverrideOut(AdminOverrideCreate):
    id: int
    created_at: datetime

    class Config:
        from_attributes = True


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\super_admin_schemas.py ---
from pydantic import BaseModel, EmailStr, Field, field_validator
from typing import Optional, List
from datetime import time, datetime
from enum import Enum

class Visibility(str, Enum):
    public = "public"
    private = "private"

class HostelBase(BaseModel):
    hostel_name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    full_address: Optional[str] = None
    hostel_type: Optional[str] = None
    contact_email: Optional[EmailStr] = None
    contact_phone: Optional[str] = None
    amenities: Optional[str] = None
    rules: Optional[str] = None
    check_in: Optional[time] = None
    check_out: Optional[time] = None
    total_beds: Optional[int] = None
    current_occupancy: Optional[int] = None
    monthly_revenue: Optional[float] = None
    visibility: Visibility = Field(default=Visibility.public)
    is_featured: bool = False
    location_id: int  # Ensure location_id is required and must be valid

    @field_validator('current_occupancy')
    @classmethod
    def validate_occupancy(cls, v, info):
        if v is not None and info.data.get('total_beds') is not None and v > info.data['total_beds']:
            raise ValueError('current_occupancy cannot exceed total_beds')
        return v

    @field_validator('check_out')
    @classmethod
    def validate_checkout_time(cls, v, info):
        if v is not None and info.data.get('check_in') is not None:
            # Remove strict validation for check_out
            pass
        return v

class HostelCreate(HostelBase): pass

class HostelUpdate(BaseModel):
    hostel_name: Optional[str] = None
    description: Optional[str] = None
    full_address: Optional[str] = None
    hostel_type: Optional[str] = None
    contact_email: Optional[EmailStr] = None
    contact_phone: Optional[str] = None
    amenities: Optional[str] = None
    rules: Optional[str] = None
    check_in: Optional[time] = None
    check_out: Optional[time] = None
    total_beds: Optional[int] = None
    current_occupancy: Optional[int] = None
    monthly_revenue: Optional[float] = None
    visibility: Optional[Visibility] = None
    is_featured: Optional[bool] = None
    location_id: Optional[int] = None

class HostelUpsert(HostelBase):
    id: Optional[int] = None

class HostelResponse(HostelBase):
    id: int
    created_at: datetime
    class Config:
        from_attributes = True

class ActivityItem(BaseModel):
    entity_name: str
    entity_type: str
    action: str
    created_at: datetime

class DashboardSummary(BaseModel):
    total_hostels: int
    active_admins: int
    average_occupancy: float
    complaint_resolution_rate: float

class TopHostelItem(BaseModel):
    rank: int
    hostel_name: str
    city: str
    total_beds: int
    current_occupancy: int
    occupancy_rate: float

class DashboardResponse(BaseModel):
    summary: DashboardSummary
    recent_activities: List[ActivityItem]
    top_hostels: List[TopHostelItem]

class SuccessResponse(BaseModel):
    message: str
    data: Optional[dict] = None


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\user.py ---
"""
User creation/view schemas
"""
from pydantic import BaseModel, EmailStr, validator
from typing import Optional
from datetime import datetime


class UserBase(BaseModel):
    email: Optional[EmailStr] = None
    phone_number: Optional[str] = None
    country_code: Optional[str] = None
    username: str
    full_name: Optional[str] = None
    role: str
    hostel_id: Optional[int] = None


class UserCreate(UserBase):
    password: Optional[str] = None  # Optional for social login


class AdminCreate(UserBase):
    """Schema for creating admin users with password confirmation"""
    password: str
    confirm_password: str
    
    @validator('confirm_password')
    def passwords_match(cls, v, values):
        """Validate that confirm_password matches password"""
        if 'password' in values and v != values['password']:
            raise ValueError('Passwords do not match')
        return v
    
    @validator('password')
    def validate_password_strength(cls, v):
        """Validate password meets minimum requirements"""
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        return v


class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    phone_number: Optional[str] = None
    username: Optional[str] = None
    full_name: Optional[str] = None
    role: Optional[str] = None
    hostel_id: Optional[int] = None
    is_active: Optional[bool] = None


class UserResponse(UserBase):
    id: int
    is_active: bool
    profile_picture_url: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\visitor.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\waitlist.py ---
from pydantic import BaseModel
from datetime import datetime


class WaitlistCreate(BaseModel):
    hostel_id: int
    room_type: str
    visitor_id: int


class WaitlistResponse(BaseModel):
    id: int
    hostel_id: int
    room_type: str
    visitor_id: int
    priority: int
    created_at: datetime

    class Config:
        orm_mode = True


class PromoteResponse(BaseModel):
    promoted: bool
    booking_id: int
    room_id: int
    hostel_id: int
    message: str


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\__init__.py ---
# Re-export schema classes from individual schema modules for convenience
from .subscription_schemas import *
from .admin_schemas import *
from .super_admin_schemas import *



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\schemas\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\admin_service.py ---
from typing import List, Optional
from fastapi import HTTPException, status
from app.repositories.admin_repository import AdminRepository
from app.schemas.admin_schemas import (
    AdminCreate,
    AdminResponse,
    AdminHostelAssignmentCreate,
    AdminHostelAssignmentResponse,
    BulkAssignmentRequest,
    BulkAssignmentResponse,
)
from app.models.admin import PermissionLevel

class AdminService:
    def __init__(self, admin_repository: AdminRepository):
        self.admin_repository = admin_repository

    def create_admin(self, admin: AdminCreate) -> AdminResponse:
        # Check if admin with email already exists
        existing_admin = self.admin_repository.get_admin_by_email(admin.email)
        if existing_admin:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Admin with this email already exists"
            )
        
        db_admin = self.admin_repository.create_admin(admin)
        return AdminResponse.model_validate(db_admin)

    def get_admin(self, admin_id: int) -> AdminResponse:
        db_admin = self.admin_repository.get_admin(admin_id)
        if not db_admin:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Admin not found"
            )
        return AdminResponse.model_validate(db_admin)

    def get_all_admins(self) -> List[AdminResponse]:
        db_admins = self.admin_repository.get_all_admins()
        return [AdminResponse.model_validate(admin) for admin in db_admins]

    def assign_hostel(
        self, admin_id: int, assignment: AdminHostelAssignmentCreate
    ) -> AdminHostelAssignmentResponse:
        import logging
        logger = logging.getLogger(__name__)
        
        # Log the input values
        logger.info(f"Assigning hostel with permission level: {assignment.permission_level} (type: {type(assignment.permission_level)})")
        
        # Verify admin exists
        if not self.admin_repository.get_admin(admin_id):
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Admin not found"
            )

        # Create the assignment
        try:
            db_assignment = self.admin_repository.assign_hostel_to_admin(
                admin_id, assignment
            )
            return AdminHostelAssignmentResponse.model_validate(db_assignment)
        except Exception as e:
            logger.error(f"Error in assign_hostel: {str(e)}")
            raise

    def bulk_assign_hostels(
        self, assignment: BulkAssignmentRequest
    ) -> BulkAssignmentResponse:
        import logging
        logger = logging.getLogger(__name__)
        
        try:
            # Verify admin exists
            if not self.admin_repository.get_admin(assignment.admin_id):
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Admin not found"
                )
            
            logger.info(f"Bulk assigning with permission level: {assignment.permission_level} (type: {type(assignment.permission_level)})")
            
            # Convert permission_level to string if needed
            perm_level = assignment.permission_level
            if isinstance(perm_level, str):
                perm_level = PermissionLevel[perm_level.lower()]
            
            # Perform bulk assignment
            assignments = self.admin_repository.bulk_assign_hostels(
                assignment.admin_id,
                assignment.hostel_ids,
                perm_level
            )

            return BulkAssignmentResponse(
                success=True,
                message=f"Successfully assigned {len(assignments)} hostels to admin",
                assignments=[AdminHostelAssignmentResponse.model_validate(a) for a in assignments]
            )
        except Exception as e:
            logger.error(f"Error in bulk_assign_hostels: {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=str(e)
            )

    def get_admin_hostel_assignments(
        self, admin_id: int
    ) -> List[AdminHostelAssignmentResponse]:
        # Verify admin exists
        if not self.admin_repository.get_admin(admin_id):
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Admin not found"
            )

        assignments = self.admin_repository.get_admin_hostel_assignments(admin_id)
        return [AdminHostelAssignmentResponse.model_validate(a) for a in assignments]

    def update_hostel_permission(
        self, admin_id: int, hostel_id: int, permission_level: PermissionLevel
    ) -> AdminHostelAssignmentResponse:
        # Verify admin exists
        if not self.admin_repository.get_admin(admin_id):
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Admin not found"
            )

        updated_assignment = self.admin_repository.update_hostel_permission(
            admin_id, hostel_id, permission_level
        )
        if not updated_assignment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Assignment not found"
            )

        return AdminHostelAssignmentResponse.model_validate(updated_assignment)

    def remove_hostel_assignment(self, admin_id: int, hostel_id: int) -> bool:
        # Verify admin exists
        if not self.admin_repository.get_admin(admin_id):
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Admin not found"
            )

        success = self.admin_repository.remove_hostel_assignment(admin_id, hostel_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Assignment not found"
            )

        return True

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\analytics_service.py ---
from sqlalchemy.orm import Session
from sqlalchemy import text, func
from typing import List, Optional
from datetime import datetime, timedelta, date
from decimal import Decimal
from app.schemas.reports import *
from app.repositories.complaint_repository import ComplaintRepository

class AnalyticsService:
    
    @staticmethod
    def get_multi_hostel_dashboard(db: Session, hostel_ids: List[int], 
                                   start_date: date, end_date: date) -> MultiHostelDashboard:
        """Get unified dashboard for multiple hostels"""
        
        hostel_kpis = []
        
        for hostel_id in hostel_ids:
            kpi = AnalyticsService._get_hostel_kpi(db, hostel_id, start_date, end_date)
            hostel_kpis.append(kpi)
        
        # Calculate summary
        summary = KPISummary(
            total_revenue=sum(h.revenue for h in hostel_kpis),
            total_expenses=sum(h.expenses for h in hostel_kpis),
            net_profit=sum(h.profit for h in hostel_kpis),
            occupancy_rate=sum(h.occupancy_rate for h in hostel_kpis) / len(hostel_kpis) if hostel_kpis else 0,
            total_complaints=sum(h.complaint_count for h in hostel_kpis),
            resolved_complaints=sum(h.resolved_complaints for h in hostel_kpis),
            average_resolution_time=0.0,  # Calculate separately
            student_count=sum(h.occupied_beds for h in hostel_kpis)
        )
        
        # Get average resolution time
        complaint_stats = ComplaintRepository.get_statistics(db, hostel_ids, 
                                                            datetime.combine(start_date, datetime.min.time()),
                                                            datetime.combine(end_date, datetime.max.time()))
        summary.average_resolution_time = complaint_stats.get('average_resolution_hours', 0)
        
        return MultiHostelDashboard(
            summary=summary,
            hostels=hostel_kpis,
            period=f"{start_date} to {end_date}",
            generated_at=datetime.utcnow()
        )
    
    @staticmethod
    def _get_hostel_kpi(db: Session, hostel_id: int, start_date: date, end_date: date) -> HostelKPI:
        """Get KPI for a single hostel"""
        
        # Get hostel info
        hostel = db.execute(text("""
            SELECT id, hostel_name, total_beds, current_occupancy
            FROM hostels WHERE id = :hostel_id
        """), {'hostel_id': hostel_id}).first()
        
        if not hostel:
            return None
        
        # Get financial data
        financial = db.execute(text("""
            SELECT 
                SUM(CASE WHEN transaction_type IN ('fee', 'booking') THEN amount ELSE 0 END) as revenue,
                SUM(CASE WHEN transaction_type = 'expense' THEN amount ELSE 0 END) as expenses
            FROM financial_transactions
            WHERE hostel_id = :hostel_id 
            AND transaction_date BETWEEN :start_date AND :end_date
        """), {'hostel_id': hostel_id, 'start_date': start_date, 'end_date': end_date}).first()
        
        revenue = financial.revenue or Decimal(0)
        expenses = financial.expenses or Decimal(0)
        
        # Get complaint stats
        complaint_stats = ComplaintRepository.get_statistics(
            db, [hostel_id],
            datetime.combine(start_date, datetime.min.time()),
            datetime.combine(end_date, datetime.max.time())
        )
        
        # `current_occupancy` stores occupied beds; compute occupancy and available beds from it
        current_occupancy = hostel.current_occupancy or 0
        occupied_beds = current_occupancy
        occupancy_rate = (occupied_beds / hostel.total_beds * 100) if hostel.total_beds and hostel.total_beds > 0 else 0
        
        return HostelKPI(
            hostel_id=hostel.id,
            hostel_name=hostel.hostel_name,
            revenue=revenue,
            expenses=expenses,
            profit=revenue - expenses,
            occupancy_rate=occupancy_rate,
            total_beds=hostel.total_beds,
            occupied_beds=occupied_beds,
            complaint_count=complaint_stats['total'],
            resolved_complaints=complaint_stats['resolved'],
            average_rating=0.0
        )
    
    @staticmethod
    def get_revenue_comparison(db: Session, hostel_ids: List[int], 
                              current_start: date, current_end: date,
                              previous_start: date, previous_end: date) -> List[RevenueComparison]:
        """Compare revenue across hostels and periods"""
        
        comparisons = []
        
        for hostel_id in hostel_ids:
            hostel = db.execute(text("SELECT hostel_name FROM hostels WHERE id = :id"), 
                              {'id': hostel_id}).first()
            
            if not hostel:
                continue
            
            # Current period revenue
            current = db.execute(text("""
                SELECT SUM(amount) as total
                FROM financial_transactions
                WHERE hostel_id = :hostel_id 
                AND transaction_type IN ('fee', 'booking')
                AND transaction_date BETWEEN :start_date AND :end_date
            """), {'hostel_id': hostel_id, 'start_date': current_start, 'end_date': current_end}).first()
            
            # Previous period revenue
            previous = db.execute(text("""
                SELECT SUM(amount) as total
                FROM financial_transactions
                WHERE hostel_id = :hostel_id 
                AND transaction_type IN ('fee', 'booking')
                AND transaction_date BETWEEN :start_date AND :end_date
            """), {'hostel_id': hostel_id, 'start_date': previous_start, 'end_date': previous_end}).first()
            
            current_revenue = current.total or Decimal(0)
            previous_revenue = previous.total or Decimal(0)
            
            growth_rate = 0.0
            if previous_revenue > 0:
                growth_rate = float((current_revenue - previous_revenue) / previous_revenue * 100)
            
            # Monthly breakdown
            monthly = db.execute(text("""
                SELECT 
                    DATE_TRUNC('month', transaction_date) as month,
                    SUM(amount) as revenue
                FROM financial_transactions
                WHERE hostel_id = :hostel_id 
                AND transaction_type IN ('fee', 'booking')
                AND transaction_date BETWEEN :start_date AND :end_date
                GROUP BY DATE_TRUNC('month', transaction_date)
                ORDER BY month
            """), {'hostel_id': hostel_id, 'start_date': current_start, 'end_date': current_end}).fetchall()
            
            monthly_breakdown = [{'month': str(row.month), 'revenue': float(row.revenue)} for row in monthly]
            
            comparisons.append(RevenueComparison(
                hostel_id=hostel_id,
                hostel_name=hostel.hostel_name,
                current_period_revenue=current_revenue,
                previous_period_revenue=previous_revenue,
                growth_rate=growth_rate,
                monthly_breakdown=monthly_breakdown
            ))
        
        return comparisons
    
    @staticmethod
    def get_occupancy_trends(db: Session, hostel_ids: List[int], 
                            start_date: date, end_date: date) -> List[OccupancyTrend]:
        """Get occupancy trends over time"""
        
        trends = []
        
        # Generate date range
        current_date = start_date
        while current_date <= end_date:
            for hostel_id in hostel_ids:
                hostel = db.execute(text("""
                    SELECT hostel_name, total_beds, current_occupancy 
                        FROM hostels WHERE id = :id
                """), {'id': hostel_id}).first()
                
                if hostel:
                    current_occupancy = hostel.current_occupancy or 0
                    occupied = current_occupancy
                    occupancy_rate = (occupied / hostel.total_beds * 100) if hostel.total_beds and hostel.total_beds > 0 else 0

                    trends.append(OccupancyTrend(
                        hostel_id=hostel_id,
                        hostel_name=hostel.hostel_name,
                        date=current_date,
                        occupancy_rate=occupancy_rate,
                        occupied_beds=occupied,
                        total_beds=hostel.total_beds
                    ))
            
            current_date += timedelta(days=1)
        
        return trends
    
    @staticmethod
    def get_complaint_metrics(db: Session, hostel_ids: List[int], 
                             start_date: date, end_date: date) -> List[ComplaintMetrics]:
        """Get complaint metrics by hostel"""
        
        metrics = []
        
        for hostel_id in hostel_ids:
            hostel = db.execute(text("SELECT hostel_name FROM hostels WHERE id = :id"), 
                              {'id': hostel_id}).first()
            
            if not hostel:
                continue
            
            # Get complaints by category, status, priority
            by_category = db.execute(text("""
                SELECT category, COUNT(*) as count
                FROM complaints
                WHERE hostel_name = :hostel_name
                AND created_at BETWEEN :start_date AND :end_date
                GROUP BY category
            """), {
                'hostel_name': hostel.hostel_name,
                'start_date': datetime.combine(start_date, datetime.min.time()),
                'end_date': datetime.combine(end_date, datetime.max.time())
            }).fetchall()
            
            by_status = db.execute(text("""
                SELECT status, COUNT(*) as count
                FROM complaints
                WHERE hostel_name = :hostel_name
                AND created_at BETWEEN :start_date AND :end_date
                GROUP BY status
            """), {
                'hostel_name': hostel.hostel_name,
                'start_date': datetime.combine(start_date, datetime.min.time()),
                'end_date': datetime.combine(end_date, datetime.max.time())
            }).fetchall()
            
            by_priority = db.execute(text("""
                SELECT priority, COUNT(*) as count
                FROM complaints
                WHERE hostel_name = :hostel_name
                AND created_at BETWEEN :start_date AND :end_date
                GROUP BY priority
            """), {
                'hostel_name': hostel.hostel_name,
                'start_date': datetime.combine(start_date, datetime.min.time()),
                'end_date': datetime.combine(end_date, datetime.max.time())
            }).fetchall()
            
            stats = ComplaintRepository.get_statistics(
                db, [hostel_id],
                datetime.combine(start_date, datetime.min.time()),
                datetime.combine(end_date, datetime.max.time())
            )
            
            metrics.append(ComplaintMetrics(
                hostel_id=hostel_id,
                hostel_name=hostel.hostel_name,
                total_complaints=stats['total'],
                by_category={row.category: row.count for row in by_category},
                by_status={row.status: row.count for row in by_status},
                by_priority={row.priority: row.count for row in by_priority},
                average_resolution_time=stats['average_resolution_hours'],
                satisfaction_rating=stats['average_rating']
            ))
        
        return metrics
    
    @staticmethod
    def get_marketing_analytics(db: Session, hostel_ids: List[int], 
                                start_date: date, end_date: date) -> List[MarketingAnalytics]:
        """Get marketing analytics by hostel"""
        
        analytics = []
        
        for hostel_id in hostel_ids:
            hostel = db.execute(text("SELECT hostel_name FROM hostels WHERE id = :id"), 
                              {'id': hostel_id}).first()
            
            if not hostel:
                continue
            
            # Profile views
            views = db.execute(text("""
                SELECT COUNT(*) as count
                FROM hostel_profile_views
                WHERE hostel_id = :hostel_id
                AND viewed_at BETWEEN :start_date AND :end_date
            """), {
                'hostel_id': hostel_id,
                'start_date': datetime.combine(start_date, datetime.min.time()),
                'end_date': datetime.combine(end_date, datetime.max.time())
            }).scalar()
            
            # Search appearances (simplified - count from search queries)
            searches = db.execute(text("""
                SELECT COUNT(*) as count
                FROM search_queries
                WHERE searched_at BETWEEN :start_date AND :end_date
            """), {
                'start_date': datetime.combine(start_date, datetime.min.time()),
                'end_date': datetime.combine(end_date, datetime.max.time())
            }).scalar()
            
            # Bookings
            bookings_data = db.execute(text("""
                SELECT COUNT(*) as count
                FROM hostel_bookings
                WHERE hostel_id = :hostel_id
                AND booking_date BETWEEN :start_date AND :end_date
            """), {
                'hostel_id': hostel_id,
                'start_date': datetime.combine(start_date, datetime.min.time()),
                'end_date': datetime.combine(end_date, datetime.max.time())
            }).scalar()
            
            # Top sources
            sources = db.execute(text("""
                SELECT source, COUNT(*) as count
                FROM hostel_profile_views
                WHERE hostel_id = :hostel_id
                AND viewed_at BETWEEN :start_date AND :end_date
                GROUP BY source
                ORDER BY count DESC
                LIMIT 5
            """), {
                'hostel_id': hostel_id,
                'start_date': datetime.combine(start_date, datetime.min.time()),
                'end_date': datetime.combine(end_date, datetime.max.time())
            }).fetchall()
            
            conversion_rate = (bookings_data / views * 100) if views > 0 else 0
            
            analytics.append(MarketingAnalytics(
                hostel_id=hostel_id,
                hostel_name=hostel.hostel_name,
                profile_views=views or 0,
                search_appearances=searches or 0,
                inquiries=0,  # Would need inquiry table
                bookings=bookings_data or 0,
                conversion_rate=conversion_rate,
                top_sources=[{'source': row.source, 'count': row.count} for row in sources]
            ))
        
        return analytics
    
    @staticmethod
    def get_attendance_report(db: Session, hostel_id: int, report_date: date) -> AttendanceReport:
        """Get attendance report for a specific date"""
        
        hostel = db.execute(text("SELECT hostel_name FROM hostels WHERE id = :id"), 
                          {'id': hostel_id}).first()
        
        # Get attendance data
        attendance_data = db.execute(text("""
            SELECT 
                COUNT(*) as total_students,
                SUM(CASE WHEN is_present THEN 1 ELSE 0 END) as present_count
            FROM attendance
            WHERE hostel_id = :hostel_id AND date = :date
        """), {'hostel_id': hostel_id, 'date': report_date}).first()
        
        # Get absent students
        absent = db.execute(text("""
            SELECT student_id, student_name
            FROM attendance
            WHERE hostel_id = :hostel_id AND date = :date AND is_present = FALSE
        """), {'hostel_id': hostel_id, 'date': report_date}).fetchall()
        
        total = attendance_data.total_students or 0
        present = attendance_data.present_count or 0
        absent_count = total - present
        attendance_rate = (present / total * 100) if total > 0 else 0
        
        return AttendanceReport(
            hostel_id=hostel_id,
            hostel_name=hostel.hostel_name if hostel else "Unknown",
            date=report_date,
            total_students=total,
            present_count=present,
            absent_count=absent_count,
            attendance_rate=attendance_rate,
            absent_students=[{'student_id': str(row.student_id), 'student_name': row.student_name} for row in absent]
        )
    
    @staticmethod
    def get_attendance_trends(db: Session, hostel_id: int, 
                             start_date: date, end_date: date) -> AttendanceTrend:
        """Get attendance trends over a period"""
        
        hostel = db.execute(text("SELECT hostel_name FROM hostels WHERE id = :id"), 
                          {'id': hostel_id}).first()
        
        # Daily trends
        daily = db.execute(text("""
            SELECT 
                date,
                COUNT(*) as total_students,
                SUM(CASE WHEN is_present THEN 1 ELSE 0 END) as present_count
            FROM attendance
            WHERE hostel_id = :hostel_id 
            AND date BETWEEN :start_date AND :end_date
            GROUP BY date
            ORDER BY date
        """), {'hostel_id': hostel_id, 'start_date': start_date, 'end_date': end_date}).fetchall()
        
        daily_trends = []
        total_rate = 0
        for row in daily:
            rate = (row.present_count / row.total_students * 100) if row.total_students > 0 else 0
            daily_trends.append({
                'date': str(row.date),
                'total_students': row.total_students,
                'present_count': row.present_count,
                'attendance_rate': rate
            })
            total_rate += rate
        
        avg_rate = total_rate / len(daily) if daily else 0
        
        # Patterns (day of week analysis)
        patterns = db.execute(text("""
            SELECT 
                EXTRACT(DOW FROM date) as day_of_week,
                AVG(CASE WHEN is_present THEN 100.0 ELSE 0.0 END) as avg_attendance
            FROM attendance
            WHERE hostel_id = :hostel_id 
            AND date BETWEEN :start_date AND :end_date
            GROUP BY EXTRACT(DOW FROM date)
            ORDER BY day_of_week
        """), {'hostel_id': hostel_id, 'start_date': start_date, 'end_date': end_date}).fetchall()
        
        day_names = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
        pattern_dict = {day_names[int(row.day_of_week)]: float(row.avg_attendance) for row in patterns}
        
        return AttendanceTrend(
            hostel_id=hostel_id,
            hostel_name=hostel.hostel_name if hostel else "Unknown",
            period=f"{start_date} to {end_date}",
            daily_trends=daily_trends,
            average_attendance_rate=avg_rate,
            patterns=pattern_dict
        )
    
    @staticmethod
    def get_student_attendance_history(db: Session, student_id: int, 
                                       start_date: date, end_date: date) -> StudentAttendanceHistory:
        """Get attendance history for a student"""
        
        # Get student info and attendance
        attendance = db.execute(text("""
            SELECT 
                student_id, student_name, hostel_id,
                COUNT(*) as total_days,
                SUM(CASE WHEN is_present THEN 1 ELSE 0 END) as present_days
            FROM attendance
            WHERE student_id = :student_id 
            AND date BETWEEN :start_date AND :end_date
            GROUP BY student_id, student_name, hostel_id
        """), {'student_id': student_id, 'start_date': start_date, 'end_date': end_date}).first()
        
        if not attendance:
            return None
        
        # Get recent absences
        absences = db.execute(text("""
            SELECT date
            FROM attendance
            WHERE student_id = :student_id 
            AND is_present = FALSE
            AND date BETWEEN :start_date AND :end_date
            ORDER BY date DESC
            LIMIT 10
        """), {'student_id': student_id, 'start_date': start_date, 'end_date': end_date}).fetchall()
        
        total = attendance.total_days
        present = attendance.present_days
        absent = total - present
        percentage = (present / total * 100) if total > 0 else 0
        
        return StudentAttendanceHistory(
            student_id=attendance.student_id,
            student_name=attendance.student_name,
            hostel_id=attendance.hostel_id,
            total_days=total,
            present_days=present,
            absent_days=absent,
            attendance_percentage=percentage,
            recent_absences=[row.date for row in absences]
        )
    
    @staticmethod
    def get_consolidated_attendance_report(db: Session, hostel_ids: List[int], 
                                          start_date: date, end_date: date) -> ConsolidatedAttendanceReport:
        """Get consolidated attendance report across multiple hostels"""
        
        # Summary
        summary_data = db.execute(text("""
            SELECT 
                COUNT(DISTINCT hostel_id) as total_hostels,
                COUNT(DISTINCT student_id) as total_students,
                COUNT(*) as total_records,
                SUM(CASE WHEN is_present THEN 1 ELSE 0 END) as total_present
            FROM attendance
            WHERE hostel_id = ANY(:hostel_ids)
            AND date BETWEEN :start_date AND :end_date
        """), {'hostel_ids': hostel_ids, 'start_date': start_date, 'end_date': end_date}).first()
        
        total_records = summary_data.total_records or 0
        total_present = summary_data.total_present or 0
        overall_rate = (total_present / total_records * 100) if total_records > 0 else 0
        
        summary = {
            'total_hostels': summary_data.total_hostels or 0,
            'total_students': summary_data.total_students or 0,
            'overall_attendance_rate': overall_rate,
            'total_records': total_records
        }
        
        # Hostel-wise reports
        hostel_reports = []
        for hostel_id in hostel_ids:
            # Use end_date for the report
            report = AnalyticsService.get_attendance_report(db, hostel_id, end_date)
            hostel_reports.append(report)
        
        # Trends
        trends = []
        for hostel_id in hostel_ids:
            trend = AnalyticsService.get_attendance_trends(db, hostel_id, start_date, end_date)
            trends.append(trend)
        
        return ConsolidatedAttendanceReport(
            period=DateRangeFilter(start_date=start_date, end_date=end_date, hostel_ids=hostel_ids),
            summary=summary,
            hostel_wise=hostel_reports,
            trends=trends,
            generated_at=datetime.utcnow()
        )

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\analytics_services.py ---
from sqlalchemy.orm import Session
from app.repositories import analytics_repositories as hostel_summary_repository

def fetch_hostel_summary(db: Session, hostel_id: int):
    return hostel_summary_repository.get_hostel_occupancy_and_revenue(db, hostel_id)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\announcement_service.py ---
# app/services/announcement_service.py
from datetime import datetime
from typing import List, Optional
from sqlmodel import Session
from app.models.announcement import Announcement, AnnouncementStatus
from app.repositories.announcement_repository import AnnouncementRepository
from fastapi import HTTPException
from fastapi import UploadFile
import os

UPLOAD_DIR = "uploads/notices"
os.makedirs(UPLOAD_DIR, exist_ok=True)

class AnnouncementService:
    def __init__(self, session: Session):
        self.repo = AnnouncementRepository(session)

    # CREATE
    def create_announcement(self, creator: dict, payload: dict) -> Announcement:
        ann = Announcement(**payload, created_by_id=creator["id"])
        # Supervisor-created urgent/hostel-wide -> require approval
        if creator["role"] == "supervisor":
            if ann.is_emergency or (ann.target_audience and "hostel" in ann.target_audience.lower()):
                ann.approved = False
            else:
                ann.approved = True
            # supervisors do not auto-publish unless allowed by policy; keep draft/scheduled
            ann.status = AnnouncementStatus.SCHEDULED if ann.scheduled_date else AnnouncementStatus.DRAFT
        elif creator["role"] == "admin":
            ann.approved = True
            # admin-created: published immediately if no schedule and not draft
            ann.status = AnnouncementStatus.SCHEDULED if ann.scheduled_date else AnnouncementStatus.PUBLISHED
            if ann.status == AnnouncementStatus.PUBLISHED:
                ann.published = True
        else:
            raise HTTPException(status_code=403, detail="Role not permitted to create announcements")
        return self.repo.create(ann)

    # READ
    def get_announcement(self, announcement_id: int) -> Announcement:
        ann = self.repo.get(announcement_id)
        if not ann:
            raise HTTPException(status_code=404, detail="Announcement not found")
        return ann

    # UPDATE (with basic role checks)
    def update_announcement(self, updater: dict, announcement_id: int, changes: dict) -> Announcement:
        ann = self.get_announcement(announcement_id)
        # Only admin or creator (supervisor who created it) can update
        if updater["role"] != "admin" and ann.created_by_id != updater["id"]:
            raise HTTPException(status_code=403, detail="Not allowed to update this announcement")
        for k, v in changes.items():
            if hasattr(ann, k) and v is not None:
                setattr(ann, k, v)
        # If supervisor updated to make it urgent/hostel-wide, reset approval
        if updater["role"] == "supervisor" and (ann.is_emergency or ("hostel" in (ann.target_audience or "").lower())):
            ann.approved = False
            ann.status = AnnouncementStatus.DRAFT if not ann.scheduled_date else AnnouncementStatus.SCHEDULED
        return self.repo.update(ann)

    # DELETE
    def delete_announcement(self, deleter: dict, announcement_id: int) -> None:
        ann = self.get_announcement(announcement_id)
        if deleter["role"] != "admin" and ann.created_by_id != deleter["id"]:
            raise HTTPException(status_code=403, detail="Not allowed to delete this announcement")
        self.repo.delete(ann)

    # APPROVE (admin only)
    def approve_announcement(self, approver: dict, announcement_id: int) -> Announcement:
        if approver["role"] != "admin":
            raise HTTPException(status_code=403, detail="Only admin can approve")
        ann = self.get_announcement(announcement_id)
        ann.approved = True
        ann.approved_by = approver["id"]
        ann.approved_at = datetime.utcnow()
        # If scheduled date is None, publish immediately
        if not ann.scheduled_date:
            ann.status = AnnouncementStatus.PUBLISHED
            ann.published = True
        return self.repo.update(ann)

    # FORCE PUBLISH (admin)
    def force_publish(self, publisher: dict, announcement_id: int) -> Announcement:
        if publisher["role"] != "admin":
            raise HTTPException(status_code=403, detail="Only admin can publish forcibly")
        ann = self.get_announcement(announcement_id)
        ann.status = AnnouncementStatus.PUBLISHED
        ann.published = True
        ann.approved = True
        return self.repo.update(ann)

    # ADD ATTACHMENT
    def add_attachment(self, announcement_id: int, file: UploadFile, actor: dict) -> Announcement:
        ann = self.get_announcement(announcement_id)
        # only admin or creator can attach
        if actor["role"] != "admin" and ann.created_by_id != actor["id"]:
            raise HTTPException(status_code=403, detail="Not allowed to attach file")
        filename = f"{int(datetime.utcnow().timestamp())}_{file.filename}"
        path = os.path.join(UPLOAD_DIR, filename)
        with open(path, "wb") as f:
            f.write(file.file.read())
        ann.attachments = (ann.attachments or []) + [path]
        return self.repo.update(ann)

    # ACKNOWLEDGE / READ RECEIPT
    def acknowledge(self, announcement_id: int, user_id: int) -> Announcement:
        ann = self.get_announcement(announcement_id)
        readers = ann.read_by or []
        if user_id not in readers:
            readers.append(user_id)
            ann.read_by = readers
            return self.repo.update(ann)
        return ann

    # LISTS
    def list_for_admin(self, limit: int = 100, offset: int = 0) -> List[Announcement]:
        return self.repo.list_all(limit=limit, offset=offset)

    def list_for_student(self, student_hostel_ids: List[int], limit: int = 100, offset: int = 0) -> List[Announcement]:
        # Simple strategy: return published announcements. For target filtering you should expand model to include hostel_ids
        anns = self.repo.list_published(limit=limit, offset=offset)
        # If you have structured target audience, filter here. Returning all published for simplicity.
        return anns

    def publish_due_scheduled(self) -> List[Announcement]:
        due = self.repo.list_scheduled_due()
        published = []
        for ann in due:
            if ann.approved:
                ann.status = AnnouncementStatus.PUBLISHED
                ann.published = True
                published.append(self.repo.update(ann))
        return published


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\approval_service.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\attendance_service.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\audit_service.py ---
"""
Audit log creation/viewing
"""
from sqlalchemy.orm import Session
from typing import List, Optional
from fastapi import HTTPException, status

from app.core.roles import Role
from app.repositories.audit_repository import AuditRepository
from app.schemas.audit import AuditLogFilter, AuditLogResponse


class AuditService:
    def __init__(self, db: Session):
        self.db = db
        self.audit_repo = AuditRepository(db)
    
    def create_audit_log(
        self,
        user_id: int,
        action: str,
        resource: str,
        hostel_id: Optional[int] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        details: Optional[str] = None
    ) -> AuditLogResponse:
        """Create audit log entry"""
        audit_log = self.audit_repo.create_audit_log(
            user_id=user_id,
            action=action,
            resource=resource,
            hostel_id=hostel_id,
            ip_address=ip_address,
            user_agent=user_agent,
            details=details
        )
        
        return AuditLogResponse(
            id=audit_log.id,
            user_id=audit_log.user_id,
            hostel_id=audit_log.hostel_id,
            action=audit_log.action,
            resource=audit_log.resource,
            ip_address=audit_log.ip_address,
            user_agent=audit_log.user_agent,
            details=audit_log.details,
            created_at=audit_log.created_at
        )
    
    def get_audit_logs(
        self,
        viewer_role: str,
        viewer_user_id: int,
        skip: int = 0,
        limit: int = 100,
        filters: Optional[AuditLogFilter] = None
    ) -> List[AuditLogResponse]:
        """Get audit logs (with role-based filtering)"""
        # Only admin/supervisor/superadmin can view audit logs
        if viewer_role not in [Role.ADMIN, Role.SUPERVISOR, Role.SUPERADMIN]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Insufficient permissions to view audit logs"
            )
        
        # Superadmin can see all logs
        if viewer_role == Role.SUPERADMIN:
            logs = self.audit_repo.get_all(skip=skip, limit=limit, filters=filters)
        else:
            # Admin/supervisor can only see logs for their hostel(s)
            if filters and filters.hostel_id:
                logs = self.audit_repo.get_all(skip=skip, limit=limit, filters=filters)
            else:
                # Get user's hostel and filter
                from app.repositories.user_repository import UserRepository
                user_repo = UserRepository(self.db)
                user = user_repo.get_by_id(viewer_user_id)
                if user and user.hostel_id:
                    if filters:
                        filters.hostel_id = user.hostel_id
                    else:
                        filters = AuditLogFilter(hostel_id=user.hostel_id)
                    logs = self.audit_repo.get_all(skip=skip, limit=limit, filters=filters)
                else:
                    logs = []
        
        return [
            AuditLogResponse(
                id=log.id,
                user_id=log.user_id,
                hostel_id=log.hostel_id,
                action=log.action,
                resource=log.resource,
                ip_address=log.ip_address,
                user_agent=log.user_agent,
                details=log.details,
                created_at=log.created_at
            )
            for log in logs
        ]
    
    def get_user_audit_logs(self, user_id: int, skip: int = 0, limit: int = 100) -> List[AuditLogResponse]:
        """Get audit logs for a specific user"""
        logs = self.audit_repo.get_by_user(user_id, skip=skip, limit=limit)
        return [
            AuditLogResponse(
                id=log.id,
                user_id=log.user_id,
                hostel_id=log.hostel_id,
                action=log.action,
                resource=log.resource,
                ip_address=log.ip_address,
                user_agent=log.user_agent,
                details=log.details,
                created_at=log.created_at
            )
            for log in logs
        ]

    def get_target_audit_logs(self, target_id: str, skip: int = 0, limit: int = 100) -> List[AuditLogResponse]:
        """Search audit logs by a target identifier present in resource or details."""
        logs = self.audit_repo.get_by_target(target_id, skip=skip, limit=limit)
        return [
            AuditLogResponse(
                id=log.id,
                user_id=log.user_id,
                hostel_id=log.hostel_id,
                action=log.action,
                resource=log.resource,
                ip_address=log.ip_address,
                user_agent=log.user_agent,
                details=log.details,
                created_at=log.created_at
            )
            for log in logs
        ]



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\auth_service.py ---
"""
JWT generation, refresh, role auth, password hashing, OTP, email & SMS utilities
Merged into one complete authentication module.
"""

from datetime import datetime, timedelta, timezone
from sqlalchemy.orm import Session
from fastapi import HTTPException, status

import bcrypt
import random
import ssl
import smtplib
from email.mime.text import MIMEText
from jose import jwt

from app.core.security import decode_token     # Keeping decode_token if used elsewhere
from app.repositories.user_repository import UserRepository
from app.repositories.token_repository import TokenRepository
from app.schemas.auth import UserLogin, UserRegister, Token
from app.config import settings


# ============================================================
# 🔐 PASSWORD HASHING & VERIFICATION
# ============================================================

def get_password_hash(password: str) -> str:
    password_bytes = password.encode('utf-8')[:72]
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password_bytes, salt).decode('utf-8')


def verify_password(plain_password: str, hashed_password: str) -> bool:
    password_bytes = plain_password.encode('utf-8')[:72]
    return bcrypt.checkpw(password_bytes, hashed_password.encode('utf-8'))


# ============================================================
# 🔐 JWT GENERATION
# ============================================================

def create_access_token(data: dict, expires_delta: timedelta = None):
    """Create short-lived access token"""
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire, "type": "access"})
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)


def create_refresh_token(data: dict):
    """Create long-lived refresh token"""
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)


# ============================================================
# 🔐 OTP GENERATION & SENDING
# ============================================================

def generate_otp() -> str:
    return f"{random.randint(100000, 999999):06d}"


async def send_otp_email(email: str, otp_code: str) -> bool:
    subject = "Your OTP Code"
    body = (
        f"Hello,\n\nYour OTP code is: {otp_code}\n"
        f"This OTP is valid for {settings.OTP_EXPIRE_MINUTES} minutes.\n\nRegards,\nYour Company"
    )
    msg = MIMEText(body)
    msg["Subject"] = subject
    msg["From"] = settings.EMAIL_ADDRESS
    msg["To"] = email

    try:
        context = ssl.create_default_context()
        with smtplib.SMTP_SSL("smtp.gmail.com", 465, context=context) as server:
            server.login(settings.EMAIL_ADDRESS, settings.EMAIL_PASSWORD)
            server.send_message(msg)
        return True
    except Exception as e:
        print(f"Failed to send OTP email: {e}")
        return False


async def send_otp_sms(phone: str, otp_code: str) -> bool:
    print(f"Sending SMS OTP to {phone}: {otp_code}")
    return True


def otp_expiry_time(minutes: int = None) -> datetime:
    expiry = minutes or settings.OTP_EXPIRE_MINUTES
    return datetime.utcnow() + timedelta(minutes=expiry)


# ============================================================
# 🔐 AUTH SERVICE (MAIN LOGIC)
# ============================================================

class AuthService:
    def __init__(self, db: Session):
        self.db = db
        self.user_repo = UserRepository(db)
        self.token_repo = TokenRepository(db)

    # --------------------------------------------------------
    # USER REGISTRATION
    # --------------------------------------------------------
    def register_user(self, user_data: UserRegister) -> dict:

        # Prevent duplicates
        if user_data.email and self.user_repo.get_by_email(user_data.email):
            raise HTTPException(400, "Email already registered")

        if getattr(user_data, "phone_number", None) and \
                self.user_repo.get_by_phone_number(user_data.phone_number):
            raise HTTPException(400, "Phone already registered")

        if self.user_repo.get_by_username(user_data.username):
            raise HTTPException(400, "Username already taken")

        # Create user
        from app.schemas.user import UserCreate

        user_create = UserCreate(
            email=user_data.email,
            phone_number=getattr(user_data, "phone_number", None),
            country_code=getattr(user_data, "country_code", None),
            username=user_data.username,
            password=user_data.password,
            full_name=user_data.full_name,
            role=user_data.role,
            hostel_id=None
        )

        user = self.user_repo.create(user_create)

        # Auto-verify
        changed = False
        if not user.is_active:
            user.is_active = True
            changed = True
        if user.email and not user.is_email_verified:
            user.is_email_verified = True
            changed = True
        if getattr(user, "phone_number", None) and not user.is_phone_verified:
            user.is_phone_verified = True
            changed = True

        if changed:
            self.db.commit()
            self.db.refresh(user)

        return {
            "id": user.id,
            "email": user.email,
            "username": user.username,
            "role": user.role
        }

    # --------------------------------------------------------
    # LOGIN
    # --------------------------------------------------------
    def login(self, credentials: UserLogin) -> Token:

        identifier = credentials.email_or_phone
        user = None

        if identifier and "@" in identifier:
            user = self.user_repo.get_by_email(identifier)
        else:
            user = self.user_repo.get_by_phone_number(identifier)

        if not user or not verify_password(credentials.password, user.hashed_password):
            raise HTTPException(401, "Incorrect credentials")

        if not user.is_active:
            raise HTTPException(403, "User account is inactive")

        # JWT Tokens
        access_token = create_access_token(
            data={"sub": str(user.id), "role": user.role, "hostel_id": user.hostel_id, "email": user.email}
        )
        refresh_token = create_refresh_token(
            data={"sub": str(user.id), "role": user.role}
        )

        # Store refresh token
        self.token_repo.create_token(user.id, refresh_token)

        return Token(
            access_token=access_token,
            refresh_token=refresh_token,
            token_type="bearer"
        )

    # --------------------------------------------------------
    # REFRESH ACCESS TOKEN
    # --------------------------------------------------------
    def refresh_access_token(self, refresh_token: str) -> dict:

        from jose import JWTError

        try:
            payload = jwt.decode(refresh_token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        except JWTError as e:
            raise HTTPException(401, f"Invalid or expired refresh token: {str(e)}")

        if payload.get("type") != "refresh":
            raise HTTPException(401, "Invalid token type. Expected refresh token.")

        token_record = self.token_repo.get_by_token(refresh_token)
        if not token_record:
            raise HTTPException(401, "Refresh token revoked or not found")

        if token_record.expires_at < datetime.now(timezone.utc):
            raise HTTPException(401, "Refresh token expired")

        user_id = payload.get("sub")
        user = self.user_repo.get_by_id(user_id)

        if not user:
            raise HTTPException(401, "User not found")

        if not user.is_active:
            raise HTTPException(403, "User account is inactive")

        access_token = create_access_token(
            data={"sub": str(user.id), "role": user.role, "hostel_id": user.hostel_id, "email": user.email}
        )

        return {"access_token": access_token, "token_type": "bearer"}

    # --------------------------------------------------------
    # LOGOUT
    # --------------------------------------------------------
    def logout(self, refresh_token: str) -> bool:
        return self.token_repo.revoke_token(refresh_token)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\bed_service.py ---
from typing import List, Optional
from sqlalchemy.orm import Session

from app.repositories.bed_repository import (
    create_bed as repo_create_bed,
    get_bed as repo_get_bed,
    list_beds as repo_list_beds,
    list_available_beds as repo_list_available_beds,
    update_bed as repo_update_bed,
    delete_bed as repo_delete_bed,
    assign_bed_to_student as repo_assign_bed_to_student,
    release_bed as repo_release_bed,
    transfer_student_to_bed as repo_transfer_student_to_bed,
    find_bed_by_room_and_bed_number as repo_find_bed_by_room_and_bed_number,
)
from app.schemas.beds import BedCreate, BedUpdate
from app.models.beds import Bed


def create_bed(db: Session, bed_in: BedCreate) -> Bed:
    return repo_create_bed(db, bed_in)


def get_bed(db: Session, bed_id: int) -> Optional[Bed]:
    return repo_get_bed(db, bed_id)


def list_beds(db: Session, skip: int = 0, limit: int = 100) -> List[Bed]:
    return repo_list_beds(db, skip=skip, limit=limit)


def list_available_beds(db: Session, room_number: Optional[str] = None, skip: int = 0, limit: int = 100) -> List[Bed]:
    return repo_list_available_beds(db, room_number=room_number, skip=skip, limit=limit)


def update_bed(db: Session, bed_id, bed_in: BedUpdate) -> Optional[Bed]:
    bed = repo_get_bed(db, bed_id)
    if not bed:
        return None
    return repo_update_bed(db, bed, bed_in)


def delete_bed(db: Session, bed_id) -> bool:
    bed = repo_get_bed(db, bed_id)
    if not bed:
        return False
    repo_delete_bed(db, bed)
    return True


def assign_bed(db: Session, bed_id: int, student_id: str) -> Optional[Bed]:
    bed = repo_get_bed(db, bed_id)
    if not bed:
        return None
    return repo_assign_bed_to_student(db, bed, student_id)


def release_bed(db: Session, bed_id: int) -> Optional[Bed]:
    bed = repo_get_bed(db, bed_id)
    if not bed:
        return None
    return repo_release_bed(db, bed)


def transfer_student_bed(db: Session, student_id: str, new_bed_id: int) -> Optional[Bed]:
    new_bed = repo_get_bed(db, new_bed_id)
    if not new_bed:
        return None
    return repo_transfer_student_to_bed(db, student_id, new_bed)


def find_bed_by_room_bed(db: Session, room_number: str, bed_number: str) -> Optional[Bed]:
    return repo_find_bed_by_room_and_bed_number(db, room_number, bed_number)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\booking_expiry_service.py ---
"""
Booking Expiry Service - Handles automatic expiration of pending bookings
"""

import threading
import time
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from app.core.logger import setup_logger
from app.models.booking import Booking, BookingStatus
from app.repositories.booking_repository import BookingRepository

logger = setup_logger()


class BookingExpiryService:
    """
    Service to handle automatic expiration of pending bookings.
    Runs as a background thread to check and expire bookings.
    """

    def __init__(self, db_session_factory):
        """
        Initialize the booking expiry service.
        
        Args:
            db_session_factory: SQLAlchemy SessionLocal factory
        """
        self.db_session_factory = db_session_factory
        self.running = False
        self.thread = None
        self.check_interval = 300  # Check every 5 minutes (300 seconds)

    def start(self):
        """Start the background booking expiry checker thread."""
        if self.running:
            logger.warning("BookingExpiryService is already running")
            return

        self.running = True
        self.thread = threading.Thread(
            target=self._run_expiry_checker,
            daemon=True
        )
        self.thread.start()
        logger.info("BookingExpiryService started")

    def stop(self):
        """Stop the background booking expiry checker thread."""
        self.running = False
        if self.thread:
            self.thread.join(timeout=5)
        logger.info("BookingExpiryService stopped")

    def _run_expiry_checker(self):
        """Background task to check and expire pending bookings."""
        while self.running:
            try:
                self._check_and_expire_bookings()
            except Exception as e:
                logger.error(f"Error in booking expiry checker: {str(e)}")
            
            # Sleep before next check
            time.sleep(self.check_interval)

    def _check_and_expire_bookings(self):
        """
        Check for pending bookings that should be expired.
        A booking is expired if:
        1. Status is PENDING
        2. Created more than 24 hours ago (configurable)
        """
        try:
            db: Session = self.db_session_factory()
            
            # Calculate expiry threshold (24 hours ago)
            expiry_threshold = datetime.utcnow() - timedelta(hours=24)
            
            # Find pending bookings that are older than 24 hours
            expired_bookings = db.query(Booking).filter(
                Booking.status == BookingStatus.pending,
                Booking.created_at < expiry_threshold
            ).all()
            
            if expired_bookings:
                logger.info(f"Found {len(expired_bookings)} bookings to expire")
                
                for booking in expired_bookings:
                    try:
                        booking.status = BookingStatus.cancelled
                        db.add(booking)
                        logger.info(f"Expired booking {booking.id}")
                    except Exception as e:
                        logger.error(f"Error expiring booking {booking.id}: {str(e)}")
                        db.rollback()
                        continue
                
                db.commit()
                logger.info(f"Successfully expired {len(expired_bookings)} bookings")
            
            db.close()
        except Exception as e:
            logger.error(f"Error in _check_and_expire_bookings: {str(e)}")

    def manually_expire_booking(self, db: Session, booking_id: int):
        """
        Manually expire a specific booking.
        
        Args:
            db: Database session
            booking_id: ID of booking to expire
            
        Returns:
            Updated booking object or None if not found
        """
        try:
            booking = db.query(Booking).filter(Booking.id == booking_id).first()
            if booking:
                booking.status = BookingStatus.cancelled
                db.add(booking)
                db.commit()
                db.refresh(booking)
                logger.info(f"Manually expired booking {booking_id}")
                return booking
            return None
        except Exception as e:
            logger.error(f"Error manually expiring booking: {str(e)}")
            db.rollback()
            return None


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\booking_lock_service.py ---
"""
Booking Lock Service - Handles room locking and conflict detection for bookings
"""
from sqlalchemy.orm import Session
from datetime import datetime
from app.models.rooms import Room
from app.models.booking import Booking, BookingStatus


class BookingLockService:
    """Service for managing booking locks and conflicts"""

    @staticmethod
    def lock_room(db: Session, room_id: int) -> Room | None:
        """
        Get room without pessimistic locking.
        Just verify the room exists.
        """
        room = db.query(Room).filter(Room.id == room_id).first()
        return room

    @staticmethod
    def has_conflict(db: Session, room_id: int, check_in: datetime, check_out: datetime) -> bool:
        """
        Check if there's a booking conflict for the given room and dates.
        Returns True if there's a conflict, False otherwise.
        """
        try:
            conflict = db.query(Booking).filter(
                Booking.room_id == room_id,
                Booking.status.in_([BookingStatus.confirmed, BookingStatus.pending]),
                Booking.check_in < check_out,
                Booking.check_out > check_in
            ).first()

            return conflict is not None

        except Exception as e:
            print(f"Error checking booking conflict: {str(e)}")
            # If there's an error, assume conflict to be safe
            return True

    @staticmethod
    def unlock_room(db: Session, room_id: int):
        """
        Placeholder for explicit unlock logic if needed.
        """
        pass



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\booking_service.py ---
from sqlalchemy.orm import Session
from fastapi import HTTPException, status

from app.repositories.booking_repository import BookingRepository
from app.schemas.booking import BookingCreate, BookingUpdate
from app.models.booking import BookingStatus

from app.services.booking_lock_service import BookingLockService
from app.services.refund_service import RefundService
from app.services.waitlist_service import WaitlistService


from sqlalchemy.orm import Session
from app.models.booking import BookingRequest, BookingStatus
from app.schemas.booking_schema import BookingCreate

class BookingService:

    # ---------------------------------------------------------
    # CREATE BOOKING
    # ---------------------------------------------------------
    @staticmethod
    def create_booking(db: Session, data: BookingCreate):

        # 1️⃣ Lock the room row
        locked_room = BookingLockService.lock_room(db, data.room_id)
        if not locked_room:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Room is being booked by another user. Please try again."
            )

        # 2️⃣ Check double booking safely
        conflict = BookingLockService.has_conflict(
            db=db,
            room_id=data.room_id,
            check_in=data.check_in,
            check_out=data.check_out
        )

        if conflict:
            db.rollback()
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Room is already booked for the selected dates"
            )

        # 3️⃣ Create booking
        try:
            booking = BookingRepository.create(db, data)
            db.commit()
            db.refresh(booking)
            return booking
        except Exception as e:
            db.rollback()
            raise HTTPException(500, f"Booking failed: {str(e)}")

    # ---------------------------------------------------------
    # MODIFY BOOKING (Visitor)
    # ---------------------------------------------------------
    @staticmethod
    def modify_booking(db: Session, booking_id: int, updates: BookingUpdate):
        booking = BookingRepository.get_by_id(db, booking_id)
        if not booking:
            raise HTTPException(404, "Booking not found")

        if booking.status in [BookingStatus.cancelled.value, BookingStatus.rejected.value]:
            raise HTTPException(400, "Cannot modify cancelled/rejected booking")

        # If changing room or dates → check overlap
        if updates.room_id or updates.check_in or updates.check_out:

            room_id = updates.room_id or booking.room_id
            check_in = updates.check_in or booking.check_in
            check_out = updates.check_out or booking.check_out

            overlap = BookingRepository.check_overlap(
                db, room_id, check_in, check_out
            )

            if overlap and overlap.id != booking.id:
                raise HTTPException(400, "New dates/room overlap with another booking")

        return BookingRepository.update(db, booking, updates)

    # ---------------------------------------------------------
    # CANCEL BOOKING (Refund + Auto-Promotion)
    # ---------------------------------------------------------
    @staticmethod
    def cancel_booking(db: Session, booking_id: int):
        booking = BookingRepository.get_by_id(db, booking_id)
        if not booking:
            raise HTTPException(404, "Booking not found")

        if booking.status in [BookingStatus.cancelled.value, BookingStatus.rejected.value]:
            return booking  # already cancelled

        # ⭐ Calculate refund
        refund_amount = RefundService.calculate_refund(
            check_in=booking.check_in,
            amount_paid=booking.amount_paid or 0.0
        )

        # ⭐ Cancel booking
        booking.status = BookingStatus.cancelled.value
        db.commit()
        db.refresh(booking)

        # ⭐ Auto promote next waitlist user
        try:
            WaitlistService.promote_after_cancellation(
                db=db,
                hostel_id=booking.hostel_id,
                room_type=booking.room.room_type
            )
        except Exception:
            pass  # Promotion failures should not block cancellation

        # ⭐ Add refund amount into booking object for response schema
        # (only works if your BookingResponse includes refund_amount)
        booking.refund_amount = refund_amount

        return booking  # FULL booking object returned to match response_model

    # ---------------------------------------------------------
    # CONFIRM BOOKING (Admin)
    # ---------------------------------------------------------
    @staticmethod
    def confirm_booking(db: Session, booking_id: int):
        booking = BookingRepository.get_by_id(db, booking_id)
        if not booking:
            raise HTTPException(404, "Booking not found")

        booking.status = BookingStatus.confirmed.value
        db.commit()
        db.refresh(booking)
        return booking

    # ---------------------------------------------------------
    # GET SINGLE BOOKING
    # ---------------------------------------------------------
    @staticmethod
    def get_booking(db: Session, booking_id: int):
        return BookingRepository.get_by_id(db, booking_id)

    # ---------------------------------------------------------
    # GET CALENDAR (Hostel-wise booking chart)
    # ---------------------------------------------------------
    @staticmethod
    def get_calendar(db: Session, hostel_id: int):
        return BookingRepository.get_calendar(db, hostel_id)

    # ---------------------------------------------------------
    # ADMIN MODIFY BOOKING (Lock + Conflict Check)
    # ---------------------------------------------------------
    @staticmethod
    def admin_modify_booking(db: Session, booking_id: int, updates: BookingUpdate):
        booking = BookingRepository.get_by_id(db, booking_id)
        if not booking:
            raise HTTPException(404, "Booking not found")

        new_room_id = updates.room_id or booking.room_id
        new_check_in = updates.check_in or booking.check_in
        new_check_out = updates.check_out or booking.check_out

        # 1️⃣ Lock target room
        locked_room = BookingLockService.lock_room(db, new_room_id)
        if not locked_room:
            raise HTTPException(409, "Another admin is modifying this room. Try again.")

        # 2️⃣ Check conflict (but ignore self)
        conflict = BookingLockService.has_conflict(
            db=db,
            room_id=new_room_id,
            check_in=new_check_in,
            check_out=new_check_out
        )

        if conflict and conflict.id != booking.id:
            db.rollback()
            raise HTTPException(
                400,
                "New dates or room overlap with another booking"
            )

        # 3️⃣ Apply update safely
        try:
            booking.room_id = new_room_id
            booking.check_in = new_check_in
            booking.check_out = new_check_out

            db.commit()
            db.refresh(booking)
            return booking

        except Exception as e:
            db.rollback()
            raise HTTPException(500, f"Admin modification failed: {str(e)}")

def create_booking(db: Session, user_id: int, booking_data: BookingCreate):
    booking = BookingRequest(
        user_id=user_id,
        full_name=booking_data.full_name,
        phone_number=booking_data.phone_number,
        email=booking_data.email,
        id_type=booking_data.id_type,
        id_number=booking_data.id_number,
        id_document=booking_data.id_document,
        emergency_contact_name=booking_data.emergency_contact_name,
        emergency_contact_number=booking_data.emergency_contact_number,
        emergency_contact_relation=booking_data.emergency_contact_relation,
        special_requirements=booking_data.special_requirements,
    )
    db.add(booking)
    db.commit()
    db.refresh(booking)
    return booking


def update_booking_status(db: Session, booking_id: int, status: BookingStatus):
    booking = db.query(BookingRequest).filter(BookingRequest.id == booking_id).first()
    if not booking:
        return None
    booking.status = status
    db.commit()
    db.refresh(booking)
    return booking

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\comparison_service.py ---
from typing import List
from sqlalchemy.orm import Session

from app.repositories.comparison_repository import get_hostel_comparison as repo_get_hostel_comparison
from app.models.hostel import Hostel
from app.models.rooms import Room


# ---------------------------------------------------------
# VERSION 1: (Simple repository pass-through)
# ---------------------------------------------------------
def compare_hostels(db: Session, hostel_ids: List[str]) -> List[dict]:
    return repo_get_hostel_comparison(db, hostel_ids)


# ---------------------------------------------------------
# VERSION 2: (Full comparison logic)
# ---------------------------------------------------------
class ComparisonService:

    @staticmethod
    def compare_hostels(db: Session, hostel_ids: list[int]):
        if len(hostel_ids) > 4:
            raise Exception("You can compare only up to 4 hostels")

        hostels = db.query(Hostel).filter(Hostel.id.in_(hostel_ids)).all()

        if not hostels:
            return []

        result = []

        for hostel in hostels:
            rooms = db.query(Room).filter(Room.hostel_id == hostel.id).all()

            result.append({
                "hostel_id": hostel.id,
                "name": hostel.name,
                "address": hostel.address,
                "amenities": hostel.amenities if hasattr(hostel, "amenities") else [],
                "pricing": [
                    {
                        "room_id": r.id,
                        "type": r.room_type,
                        "price": r.price if hasattr(r, "price") else None,
                        "available_beds": r.available_beds
                    }
                    for r in rooms
                ]
            })

        return result


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\complaint_service.py ---
from datetime import datetime, timedelta
from typing import Optional, Tuple, List

from app.repositories.complaint_repository import ComplaintRepository
from app.schemas.complaint import (
    ComplaintCreate,
    ComplaintUpdate,
    ComplaintAssignment,
    ComplaintResolution,
    ComplaintFeedback,
    ComplaintReopen,
    ComplaintNoteCreate,
    ComplaintFilter,
)
from app.models.complaint import ComplaintStatus


class ComplaintService:
    def __init__(self, repo: ComplaintRepository):
        self.repo = repo

    # -------------------------------------------------------------------------
    # STUDENT ACTIONS
    # -------------------------------------------------------------------------

    async def create_complaint(self, data: ComplaintCreate):
        """Create a new complaint (student)."""
        payload = data.dict()
        payload["status"] = ComplaintStatus.PENDING
        payload["created_at"] = datetime.utcnow()
        payload["sla_deadline"] = datetime.utcnow() + timedelta(days=3)
        return await self.repo.create(payload)

    async def list_complaints(self, filters: ComplaintFilter) -> Tuple[List, int]:
        return await self.repo.list(filters)

    async def get_complaint(self, complaint_id: int):
        return await self.repo.get_by_id(complaint_id)

    async def get_complaint_with_details(self, complaint_id: int):
        return await self.repo.get_with_details(complaint_id)

    async def submit_feedback(self, complaint_id: int, data: ComplaintFeedback):
        updates = {
            "student_feedback": data.student_feedback,
            "student_rating": data.student_rating,
            "status": ComplaintStatus.CLOSED,
            "closed_at": datetime.utcnow()
        }
        return await self.repo.update(complaint_id, updates)

    async def reopen_complaint(self, complaint_id: int, data: ComplaintReopen):
        complaint = await self.repo.get_by_id(complaint_id)
        if not complaint:
            raise ValueError("Complaint not found")

        if complaint.status != ComplaintStatus.CLOSED:
            raise ValueError("Only closed complaints can be reopened")

        updates = {
            "status": ComplaintStatus.REOPENED,
            "is_reopened": True,
            "reopen_reason": data.reopen_reason,
            "updated_at": datetime.utcnow()
        }
        return await self.repo.update(complaint_id, updates)

    async def add_note(self, complaint_id: int, note_data: ComplaintNoteCreate):
        return await self.repo.add_note(
            complaint_id,
            note_data.note,
            note_data.user_name,
            note_data.user_email,
            note_data.is_internal
        )

    async def add_attachment(
        self, complaint_id: int, uploaded_by: str, file_path: str,
        file_name: str, file_type: str, file_size: int
    ):
        return await self.repo.add_attachment(
            complaint_id, uploaded_by, file_path, file_name, file_type, file_size
        )

    # -------------------------------------------------------------------------
    # SUPERVISOR ACTIONS
    # -------------------------------------------------------------------------

    async def update_complaint(self, complaint_id: int, data: ComplaintUpdate):
        """Fix: use dict(exclude_unset=True) to prevent overwriting with None."""
        return await self.repo.update_fields(
            complaint_id,
            data.dict(exclude_unset=True)
        )

    async def assign_complaint(self, complaint_id: int, data: ComplaintAssignment):
        updates = data.dict(exclude_unset=True)
        updates["status"] = ComplaintStatus.IN_PROGRESS
        updates["assigned_at"] = datetime.utcnow()
        return await self.repo.update(complaint_id, updates)

    async def resolve_complaint(self, complaint_id: int, data: ComplaintResolution):
        updates = data.dict(exclude_unset=True)
        updates["status"] = ComplaintStatus.RESOLVED
        updates["resolved_at"] = datetime.utcnow()
        return await self.repo.update(complaint_id, updates)

    async def close_complaint(self, complaint_id: int):
        updates = {
            "status": ComplaintStatus.CLOSED,
            "closed_at": datetime.utcnow()
        }
        return await self.repo.update(complaint_id, updates)

    async def get_supervisor_performance(
        self,
        supervisor_email: str,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ):
        return await self.repo.get_performance(supervisor_email, start_date, end_date)

    # -------------------------------------------------------------------------
    # ADMIN ACTIONS
    # -------------------------------------------------------------------------

    async def reassign_complaint(self, complaint_id: int, new_name: str, new_email: str):
        updates = {
            "assigned_to_name": new_name,
            "assigned_to_email": new_email,
            "status": ComplaintStatus.IN_PROGRESS,
            "assigned_at": datetime.utcnow()
        }
        return await self.repo.update(complaint_id, updates)

    # -------------------------------------------------------------------------
    # ANALYTICS FIX (must match schema)
    # -------------------------------------------------------------------------

    async def get_analytics(
        self,
        hostel_name: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ):
        """Fix: Ensure response matches ComplaintAnalytics schema exactly."""
        raw = await self.repo.get_analytics(hostel_name, start_date, end_date)

        return {
            "total_complaints": raw.get("total_complaints", 0),
            "open_complaints": raw.get("open_complaints", 0),
            "resolved_complaints": raw.get("resolved_complaints", 0),
            "average_resolution_time_hours": raw.get("average_resolution_time_hours", 0.0),
            "category_distribution": raw.get("category_distribution", {}),
            "status_distribution": raw.get("status_distribution", {})
        }


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\dashboard_service.py ---
from sqlalchemy import text, func
from sqlalchemy.orm import Session
import json
import logging
from typing import Dict, Any, List
from app.models.hostel import Hostel, Location
from app.models.admin import Admin
from app.models.complaint import Complaint, ComplaintStatus
from app.models.admin_hostel_mapping import AdminHostelMapping

logger = logging.getLogger(__name__)

class DashboardService:
    @staticmethod
    def get_dashboard_and_activities(db: Session) -> Dict[str, Any]:
        try:
            # Get summary statistics using ORM queries on available tables
            total_hostels = db.query(func.count(Hostel.id)).scalar() or 0
            active_admins = db.query(func.count(Admin.id)).filter(Admin.is_active == True).scalar() or 0
            
            # Compute average occupancy from hostels
            avg_occupancy_result = db.query(func.avg(Hostel.current_occupancy)).scalar() or 0.0
            avg_occupancy = round(float(avg_occupancy_result), 2) if avg_occupancy_result else 0.0
            
            # Compute complaint resolution rate as proxy for health
            total_complaints = db.query(func.count(Complaint.id)).scalar() or 0
            resolved_complaints = db.query(func.count(Complaint.id)).filter(
                Complaint.status == ComplaintStatus.RESOLVED
            ).scalar() or 0
            resolution_rate = round(
                (resolved_complaints / total_complaints * 100) if total_complaints > 0 else 0.0, 2
            )
            
            dashboard_data = {
                "summary": {
                    "total_hostels": total_hostels,
                    "active_admins": active_admins,
                    "average_occupancy": avg_occupancy,
                    "complaint_resolution_rate": resolution_rate,
                },
                "recent_activities": [],
            }

            # Get top performing hostels by occupancy and total beds
            top_result = db.query(
                Hostel.hostel_name,
                func.coalesce(Location.city, "Unknown").label("city"),
                Hostel.total_beds,
                Hostel.current_occupancy,
                func.round(
                    (Hostel.current_occupancy / func.nullif(Hostel.total_beds, 0) * 100), 2
                ).label("occupancy_rate")
            ).outerjoin(Location, Hostel.location_id == Location.id).order_by(Hostel.current_occupancy.desc()).limit(5).all()

            top_hostels = [
                {
                    "rank": idx + 1,
                    "hostel_name": r[0] or "Unknown",
                    "city": r[1] or "Unknown",
                    "total_beds": r[2] or 0,
                    "current_occupancy": r[3] or 0,
                    "occupancy_rate": float(r[4] or 0.0),
                }
                for idx, r in enumerate(top_result)
            ]

            dashboard_data["top_hostels"] = top_hostels
            return dashboard_data
        except Exception as e:
            logger.exception("Error fetching dashboard")
            raise


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\email_service.py ---
"""
Email service for sending OTP and notifications
"""
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Optional
from fastapi import HTTPException, status
import logging

from app.config import settings

logger = logging.getLogger(__name__)


class EmailService:
    """Email service for sending emails via SMTP"""
    
    def __init__(self):
        # Support either SMTP_* or EMAIL_* environment names (legacy/config mismatch)
        self.smtp_host = getattr(settings, 'SMTP_HOST', None) or getattr(settings, 'EMAIL_HOST', None)
        self.smtp_port = getattr(settings, 'SMTP_PORT', None) or getattr(settings, 'EMAIL_PORT', None)
        self.smtp_username = getattr(settings, 'SMTP_USERNAME', None) or getattr(settings, 'EMAIL_USER', None)
        self.smtp_password = getattr(settings, 'SMTP_PASSWORD', None) or getattr(settings, 'EMAIL_PASS', None)
        self.from_email = getattr(settings, 'SMTP_FROM_EMAIL', None) or getattr(settings, 'EMAIL_FROM', None) or self.smtp_username
        self.from_name = getattr(settings, 'SMTP_FROM_NAME', None) or getattr(settings, 'EMAIL_FROM_NAME', None) or settings.APP_NAME
        self.use_tls = getattr(settings, 'SMTP_USE_TLS', None) if hasattr(settings, 'SMTP_USE_TLS') else getattr(settings, 'EMAIL_USE_TLS', False)
        self.use_ssl = getattr(settings, 'SMTP_USE_SSL', None) if hasattr(settings, 'SMTP_USE_SSL') else getattr(settings, 'EMAIL_USE_SSL', False)
    
    def is_configured(self) -> bool:
        """Check if email service is configured"""
        return all([
            self.smtp_host,
            self.smtp_username,
            self.smtp_password,
            self.from_email
        ])
    
    def send_email(
        self,
        to_email: str,
        subject: str,
        html_body: str,
        text_body: Optional[str] = None
    ) -> bool:
        """Send email via SMTP"""
        if not self.is_configured():
            logger.warning("Email service not configured. Email not sent.")
            # Provide masked SMTP config to help debugging without leaking secrets
            try:
                def _mask(v: str | None) -> str | None:
                    if not v:
                        return None
                    s = str(v)
                    if len(s) <= 4:
                        return "****"
                    return s[:2] + "*" * (len(s) - 4) + s[-2:]

                logger.info(
                    "Email configuration (masked): host=%s port=%s user=%s from=%s use_tls=%s use_ssl=%s",
                    _mask(self.smtp_host), _mask(self.smtp_port), _mask(self.smtp_username), _mask(self.from_email), self.use_tls, self.use_ssl
                )
            except Exception:
                pass
            if settings.DEBUG:
                logger.info(f"Would send email to {to_email}: {subject}")
            return False
        
        try:
            # Create message
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = f"{self.from_name} <{self.from_email}>"
            msg['To'] = to_email
            
            # Add text and HTML parts
            if text_body:
                text_part = MIMEText(text_body, 'plain')
                msg.attach(text_part)
            
            html_part = MIMEText(html_body, 'html')
            msg.attach(html_part)
            
            # Connect to SMTP server
            if self.use_ssl:
                server = smtplib.SMTP_SSL(self.smtp_host, self.smtp_port)
            else:
                server = smtplib.SMTP(self.smtp_host, self.smtp_port)
                if self.use_tls:
                    server.starttls()
            
            # Login and send
            server.login(self.smtp_username, self.smtp_password)
            server.send_message(msg)
            server.quit()
            
            logger.info(f"Email sent successfully to {to_email}")
            return True
            
        except Exception as e:
            logger.error(f"Error sending email to {to_email}: {str(e)}")
            if settings.DEBUG:
                logger.exception("Email sending error details:")
            return False
    
    def send_otp_email(self, to_email: str, otp_code: str, otp_type: str = "registration") -> bool:
        """Send OTP via email"""
        # OTP delivery has been disabled by administrator request.
        # Keep the method for backward compatibility but do not send OTPs.
        logger.info(f"OTP delivery disabled: would have sent OTP to {to_email} (type={otp_type})")
        if settings.DEBUG:
            logger.debug(f"OTP code for {to_email}: {otp_code}")
        # Return False to indicate no OTP was sent
        return False
    
    def send_password_reset_email(self, to_email: str, reset_token: str = None, reset_code: str = None, user_name: str | None = None) -> bool:
        """Send password reset via email.

        Supports either a reset link (reset_token) or a numeric reset_code. If `reset_code` is provided,
        the email will contain the code and frontend URL; `user_name` is used in the code email template.
        """
        # Helper to generate HTML + text templates for a code flow
        def _generate_code_templates(user_name: str, reset_code: str, frontend_url: str):
            html = (
                f"<html><body style=\"font-family: Arial, sans-serif; padding: 20px;\">"
                f"<h2 style=\"color: #333;\">Password Reset Request</h2>"
                f"<p>Hello {user_name},</p>"
                f"<p>We received a request to reset your password.</p>"
                f"<div style=\"background: #f7f7f7; padding: 12px; border-radius: 6px; display: inline-block;\">"
                f"<strong style=\"font-size:18px;\">➡ {reset_code}</strong></div>"
                f"<p>Please enter this code on the password reset page: <a href=\"{frontend_url}\">{frontend_url}</a></p>"
                f"<p style=\"color:#666;\">Note: This code is valid for {settings.PASSWORD_RESET_TOKEN_EXPIRY_MINUTES} minutes.</p>"
                f"<p style=\"color:#666;\">If you did not request a password reset, you can safely ignore this email.</p>"
                f"<p style=\"margin-top:12px;\">With regards,<br/>Support Team</p>"
                f"</body></html>"
            )

            text = (
                f"Hello {user_name}, "
                f"We received a request to reset your password. "
                f"Your password reset code is: ➡ {reset_code} "
                f"Please enter this code on the password reset page: {frontend_url} "
                f"Note: This code is valid for {settings.PASSWORD_RESET_TOKEN_EXPIRY_MINUTES} minutes. "
                f"If you did not request a password reset, you can safely ignore this email. "
                f"With regards, Support Team"
            )

            return html, text

        # Build reset URL (token flow)
        reset_url = f"{settings.FRONTEND_URL}/reset-password?token={reset_token}" if reset_token else None
        subject = "Reset Your Password"

        # If reset_code is provided, prefer code+link email
        if reset_code:
            name = user_name or settings.APP_NAME
            # If a reset_token was provided as well, include it in the frontend URL
            frontend_reset_url = f"{settings.FRONTEND_URL}/reset-password"
            if reset_token:
                frontend_reset_url = f"{frontend_reset_url}?token={reset_token}"

            html_body, text_body = _generate_code_templates(name, reset_code, frontend_reset_url)
            return self.send_email(to_email, subject, html_body, text_body)

        # If only token provided -> link-only email
        if reset_url:
            html_body = (
                f"<html><body style=\"font-family: Arial, sans-serif; padding: 20px;\">"
                f"<h2 style=\"color: #333;\">Password Reset Request</h2>"
                f"<p>You requested to reset your password. Click the link below to reset it:</p>"
                f"<div style=\"text-align: center; margin: 20px 0;\">"
                f"<a href=\"{reset_url}\" style=\"background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block;\">Reset Password</a></div>"
                f"<p>Or copy and paste this link into your browser:</p>"
                f"<p style=\"color: #666; word-break: break-all;\">{reset_url}</p>"
                f"<p>This link will expire in {settings.PASSWORD_RESET_TOKEN_EXPIRY_MINUTES} minutes.</p>"
                f"<p>If you didn't request this, please ignore this email.</p>"
                f"<hr style=\"margin: 20px 0; border: none; border-top: 1px solid #eee;\">"
                f"<p style=\"color: #666; font-size: 12px;\">This is an automated message, please do not reply.</p>"
                f"</body></html>"
            )

            text_body = f"Reset your password by clicking this link: {reset_url}\n\nThis link will expire in {settings.PASSWORD_RESET_TOKEN_EXPIRY_MINUTES} minutes."
            return self.send_email(to_email, subject, html_body, text_body)

        logger.warning("send_password_reset_email called without token or code")
        return False



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\fee_structure_service.py ---
from app.repositories.fee_structure_repositorys import FeeStructureRepository
from app import models

class FeeStructureService:
    def __init__(self, db):
        self.repo = FeeStructureRepository(db)

    def create_hostel(self, data):
        return self.repo.create(models.Hostel, data)

    def list_hostels(self):
        return self.repo.list(models.Hostel)

    def create_fee_plan(self, data):
        return self.repo.create(models.FeePlan, data)

    def create_deposit(self, data):
        return self.repo.create(models.SecurityDeposit, data)

    def create_mess_charge(self, data):
        return self.repo.create(models.MessCharge, data)

    def create_service(self, data):
        return self.repo.create(models.AdditionalService, data)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\file_service.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\hostel_service.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\ledger_service.py ---
from sqlalchemy.orm import Session
from typing import Optional, Dict
from datetime import date
from app.repositories.ledger_repositorys import LedgerRepository, ReportRepository

class LedgerService:
    def __init__(self, db: Session):
        self.db = db
        self.ledger_repo = LedgerRepository(db)
        self.report_repo = ReportRepository(db)

    def get_transaction_history(
        self,
        start_date: Optional[date],
        end_date: Optional[date],
        hostel_id: Optional[int],
        user_id: Optional[int],          # 🔥 updated
        transaction_type: Optional[str],
        page: int,
        page_size: int
    ):
        offset = (page - 1) * page_size

        transactions, total = self.ledger_repo.get_complete_transaction_history(
            start_date=start_date,
            end_date=end_date,
            hostel_id=hostel_id,
            user_id=user_id,              # 🔥 updated
            transaction_type=transaction_type,
            limit=page_size,
            offset=offset
        )

        return {
            "transactions": transactions,
            "pagination": {
                "total": total,
                "page": page,
                "page_size": page_size,
                "total_pages": (total + page_size - 1) // page_size
            }
        }

    def get_outstanding_payments_report(self, hostel_id, overdue_only):
        invoices = self.ledger_repo.get_outstanding_payments(hostel_id, overdue_only)

        overdue = [
            i for i in invoices
            if i.due_date and i.due_date.date() < date.today()]


        return {
            "invoices": invoices,
            "summary": {
                "total_outstanding": sum(i.due_amount for i in invoices),
                "invoice_count": len(invoices),
                "overdue_count": len(overdue),
                "overdue_amount": sum(i.due_amount for i in overdue),
            }
        }

    def get_revenue_report_by_hostel(self, start_date, end_date):
        hostel_data = self.report_repo.get_revenue_by_hostel(start_date, end_date)

        return {
            "hostels": hostel_data,
            "summary": {
                "total_billed": sum(h["total_billed"] for h in hostel_data),
                "total_collected": sum(h["total_collected"] for h in hostel_data),
                "total_outstanding": sum(h["total_outstanding"] for h in hostel_data),
            }
        }


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\maintenance_service.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\mess_menu_service.py ---
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import date, datetime
from app.repositories.mess_menu_repository import MessMenuRepository
from app.schemas.mess_menu import (
    MessMenuCreate, MessMenuUpdate, MessMenuResponse,
    MenuFeedbackCreate, MenuFeedbackResponse,
    MealPreferenceCreate, MealPreferenceUpdate, MealPreferenceResponse,
    MenuDuplicationRequest, MenuApprovalRequest
)
from fastapi import HTTPException, status


class MessMenuService:
    def __init__(self, db: Session):
        self.repository = MessMenuRepository(db)

    # Menu Management
    def create_menu(self, menu: MessMenuCreate) -> MessMenuResponse:
        # Check if menu already exists for the same date and meal type
        existing_menu = self.repository.get_menu_by_date_and_meal(
            menu.hostel_id,
            menu.menu_date,
            menu.meal_type.value
        )
        
        if existing_menu:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Menu already exists for {menu.meal_type.value} on {menu.menu_date}"
            )
        
        db_menu = self.repository.create_menu(menu)
        return MessMenuResponse.from_orm(db_menu)

    def get_menu(self, menu_id: int) -> MessMenuResponse:
        db_menu = self.repository.get_menu_by_id(menu_id)
        if not db_menu:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Menu not found"
            )
        return MessMenuResponse.from_orm(db_menu)

    def get_menus_by_hostel(
        self,
        hostel_id: int,
        skip: int = 0,
        limit: int = 100,
        menu_type: Optional[str] = None,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None
    ) -> List[MessMenuResponse]:
        db_menus = self.repository.get_menus_by_hostel(
            hostel_id, skip, limit, menu_type, start_date, end_date
        )
        return [MessMenuResponse.from_orm(menu) for menu in db_menus]

    def update_menu(self, menu_id: int, menu_update: MessMenuUpdate) -> MessMenuResponse:
        db_menu = self.repository.update_menu(menu_id, menu_update)
        if not db_menu:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Menu not found"
            )
        return MessMenuResponse.from_orm(db_menu)

    def delete_menu(self, menu_id: int) -> dict:
        success = self.repository.delete_menu(menu_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Menu not found"
            )
        return {"message": "Menu deleted successfully"}

    def approve_menu(self, menu_id: int, approval: MenuApprovalRequest) -> MessMenuResponse:
        db_menu = self.repository.approve_menu(menu_id, approval.approved_by)
        if not db_menu:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Menu not found"
            )
        return MessMenuResponse.from_orm(db_menu)

    def publish_menu(self, menu_id: int) -> MessMenuResponse:
        # Check if menu is approved before publishing
        menu = self.repository.get_menu_by_id(menu_id)
        if not menu:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Menu not found"
            )
        
        if menu.status.value != "approved":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Menu must be approved before publishing"
            )
        
        db_menu = self.repository.publish_menu(menu_id)
        return MessMenuResponse.from_orm(db_menu)

    def duplicate_menu(self, duplication: MenuDuplicationRequest) -> List[MessMenuResponse]:
        """Duplicate a menu to multiple hostels"""
        source_menu = self.repository.get_menu_by_id(duplication.source_menu_id)
        if not source_menu:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Source menu not found"
            )
        
        duplicated_menus = []
        for target_hostel_id in duplication.target_hostel_ids:
            try:
                new_menu = self.repository.duplicate_menu(
                    duplication.source_menu_id,
                    target_hostel_id,
                    duplication.target_date
                )
                if new_menu:
                    duplicated_menus.append(MessMenuResponse.from_orm(new_menu))
            except Exception as e:
                # Log error but continue with other hostels
                print(f"Error duplicating menu to hostel {target_hostel_id}: {str(e)}")
                continue
        
        if not duplicated_menus:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to duplicate menu to any hostel"
            )
        
        return duplicated_menus

    # Feedback Management
    def create_feedback(self, feedback: MenuFeedbackCreate) -> MenuFeedbackResponse:
        # Verify menu exists
        menu = self.repository.get_menu_by_id(feedback.menu_id)
        if not menu:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Menu not found"
            )
        
        db_feedback = self.repository.create_feedback(feedback)
        return MenuFeedbackResponse.from_orm(db_feedback)

    def get_menu_feedback(self, menu_id: int) -> List[MenuFeedbackResponse]:
        feedbacks = self.repository.get_feedback_by_menu(menu_id)
        return [MenuFeedbackResponse.from_orm(feedback) for feedback in feedbacks]

    def get_feedback_summary(self, menu_id: int) -> dict:
        return self.repository.get_feedback_summary(menu_id)

    # Meal Preference Management
    def create_preference(self, preference: MealPreferenceCreate) -> MealPreferenceResponse:
        # Check if student already has an active preference
        existing = self.repository.get_preference_by_student(
            preference.student_id,
            preference.hostel_id
        )
        
        if existing:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Student already has an active meal preference. Please update instead."
            )
        
        db_preference = self.repository.create_preference(preference)
        return MealPreferenceResponse.from_orm(db_preference)

    def get_student_preference(self, student_id: int, hostel_id: int) -> MealPreferenceResponse:
        preference = self.repository.get_preference_by_student(student_id, hostel_id)
        if not preference:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Meal preference not found"
            )
        return MealPreferenceResponse.from_orm(preference)

    def get_hostel_preferences(self, hostel_id: int) -> List[MealPreferenceResponse]:
        preferences = self.repository.get_preferences_by_hostel(hostel_id)
        return [MealPreferenceResponse.from_orm(pref) for pref in preferences]

    def update_preference(
        self,
        preference_id: int,
        preference_update: MealPreferenceUpdate
    ) -> MealPreferenceResponse:
        db_preference = self.repository.update_preference(preference_id, preference_update)
        if not db_preference:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Meal preference not found"
            )
        return MealPreferenceResponse.from_orm(db_preference)

    def get_dietary_restrictions_report(self, hostel_id: int) -> dict:
        """Get summary of students with dietary restrictions"""
        restrictions = self.repository.get_students_with_dietary_restrictions(hostel_id)
        
        allergy_summary = {}
        diet_type_summary = {}
        
        for pref in restrictions:
            # Count diet types
            diet_type = pref.diet_type.value
            diet_type_summary[diet_type] = diet_type_summary.get(diet_type, 0) + 1
            
            # Count allergies
            if pref.allergies:
                for allergy in pref.allergies:
                    allergy_summary[allergy] = allergy_summary.get(allergy, 0) + 1
        
        return {
            "total_students_with_restrictions": len(restrictions),
            "diet_type_distribution": diet_type_summary,
            "allergy_distribution": allergy_summary,
            "students_with_medical_requirements": len([p for p in restrictions if p.medical_requirements])
        }

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\notification_service.py ---
from typing import Dict, Any, Optional
import os

from jinja2 import Template
from datetime import datetime

from app.repositories.notification_repository import NotificationRepository
from app.models.notification import Notification, NotificationTemplate, Channel, DeliveryAttempt

# FIXED: No circular import – interface separated
from app.services.providers.base_provider import ProviderInterface

# Providers (these must import interface from the base_provider)
from app.services.providers.sendgrid_provider import SendGridProvider
from app.services.providers.twilio_provider import TwilioProvider
from app.services.providers.fcm_provider import FCMProvider

# remove this top-level import if present:
# from app.tasks.notification_tasks import enqueue_send


class DummyEmailProvider(ProviderInterface):
    """Used when real email provider is missing."""
    def send(self, to: str, subject: str, body: str, extra: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        return {"success": True, "provider": "dummy_email", "response": "ok"}


class NotificationService:
    def __init__(self, db):
        self.repo = NotificationRepository(db)

        # Providers (optional)
        self.sendgrid = SendGridProvider(os.getenv("SENDGRID_API_KEY")) if os.getenv("SENDGRID_API_KEY") else None
        self.twilio = TwilioProvider(os.getenv("TWILIO_ACCOUNT_SID")) if os.getenv("TWILIO_ACCOUNT_SID") else None
        self.fcm = FCMProvider(os.getenv("FCM_SERVICE_ACCOUNT_JSON")) if os.getenv("FCM_SERVICE_ACCOUNT_JSON") else None

    def provider_status(self) -> dict:
        """Return availability/status for providers."""
        return {
            "sendgrid": bool(self.sendgrid and getattr(self.sendgrid, "client", None)),
            "twilio": bool(self.twilio and getattr(self.twilio, "client", None)),
            "fcm": bool(self.fcm and getattr(self.fcm, "available", False)),
        }

    def route_recipients(self, recipient_id: str, recipient_type: str) -> list:
        """Return an ordered list of (recipient_id, recipient_type) to attempt delivery.

        This is a simple in-memory hierarchical routing example:
        - first: the original recipient
        - second: supervisor for the student (if student)
        - third: default admin
        In a real system this would consult user relations in the DB.
        """
        routed = [(recipient_id, recipient_type)]
        if recipient_type == "student":
            # synthetic supervisor id for demo purposes
            routed.append((f"supervisor_for_{recipient_id}", "supervisor"))
        # finally add a default admin contact
        routed.append(("admin_default", "admin"))
        return routed

    # ------------------------------ #
    #   TEMPLATE RENDERING
    # ------------------------------ #
    def render_template(self, template: NotificationTemplate, context: Dict[str, Any]) -> Dict[str, str]:
        subject = Template(template.subject_template or "").render(**(context or {}))
        body = Template(template.body_template or "").render(**(context or {}))
        return {"subject": subject, "body": body}

    # ------------------------------ #
    #   CREATE & QUEUE NOTIFICATION
    # ------------------------------ #
    def send_notification(
        self,
        recipient_id: str,
        recipient_type: str,
        channel: str,
        subject: str,
        body: str,
        template_name: Optional[str] = None,
        template_context: Optional[Dict[str, Any]] = None,
    ) -> Notification:

        chan_value = channel.value if isinstance(channel, Channel) else str(channel)

        # If template_name provided, fetch and render
        if template_name:
            tpl = self.repo.get_template_by_name(template_name)
            if tpl:
                rendered = self.render_template(tpl, template_context or {})
                subject = rendered.get("subject") or subject
                body = rendered.get("body") or body

        notif = Notification(
            recipient_id=recipient_id,
            recipient_type=recipient_type,
            channel=chan_value,
            subject=subject,
            body=body,
        )

        saved = self.repo.create_notification(notif)

        # Queue asynchronous sending
        enqueue_send(saved.id)

        return saved

    # ------------------------------ #
    #   INTERNAL ACTUAL SEND LOGIC
    # ------------------------------ #
    def _perform_send(self, notification_id: int):
        notif = self.repo.get_notification(notification_id)
        if not notif:
            return

        resp = {"success": False, "response": "no_provider"}
        provider = None

        # ---------------- EMAIL ----------------
        if notif.channel == Channel.EMAIL.value:
            provider = self.sendgrid or DummyEmailProvider()
            resp = provider.send(
                to=notif.recipient_id,
                subject=notif.subject or "",
                body=notif.body or ""
            )

        # ---------------- SMS ----------------
        elif notif.channel == Channel.SMS.value and self.twilio:
            provider = self.twilio
            resp = provider.send(
                to=notif.recipient_id,
                subject=notif.subject or "",
                body=notif.body or ""
            )

        # ---------------- PUSH ----------------
        elif notif.channel == Channel.PUSH.value and self.fcm:
            provider = self.fcm
            resp = provider.send(
                to=notif.recipient_id,
                subject=notif.subject or "",
                body=notif.body or ""
            )

        # Log delivery attempt
        attempt = DeliveryAttempt(
            notification_id=notif.id,
            provider=resp.get("provider") if isinstance(resp, dict) else None,
            provider_response=str(resp),
            success=resp.get("success", False),
        )
        self.repo.create_attempt(attempt)

        # Mark as sent
        if attempt.success:
            notif.sent = True
            notif.sent_at = datetime.utcnow()
            self.repo.db.commit()
            self.repo.db.refresh(notif)

# Lazy wrapper to avoid circular import: import the real task only when used
def enqueue_send(*args, **kwargs):
    from app.tasks.notification_tasks import enqueue_send as _enqueue
    return _enqueue(*args, **kwargs)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\password_reset_service.py ---
"""
Password reset service
"""
import secrets
import random
import string
from datetime import datetime, timedelta, timezone
from sqlalchemy.orm import Session
from typing import Optional
from fastapi import HTTPException, status
import logging

from app.models.password_reset import PasswordResetToken
from app.repositories.user_repository import UserRepository
from app.core.security import get_password_hash
from app.config import settings
from app.services.email_service import EmailService
from app.services.sms_service import SMSService

logger = logging.getLogger(__name__)


class PasswordResetService:
    def __init__(self, db: Session):
        self.db = db
        self.user_repo = UserRepository(db)
        self.token_expiry_minutes = settings.PASSWORD_RESET_TOKEN_EXPIRY_MINUTES
        self.reset_code_length = settings.PASSWORD_RESET_CODE_LENGTH
    
    def generate_reset_token(self) -> str:
        """Generate secure reset token"""
        return secrets.token_urlsafe(32)
    
    def generate_reset_code(self) -> str:
        """Generate 6-digit reset code for SMS"""
        return ''.join(random.choices(string.digits, k=self.reset_code_length))
    
    def create_reset_request(self, email_or_phone: str, include_debug: bool = False) -> dict:
        """Create password reset request"""
        # Find user by email or phone
        user = None
        
        # Try email first
        if '@' in email_or_phone:
            user = self.user_repo.get_by_email(email_or_phone)
        else:
            # Try phone number exact match or username match first
            user = self.user_repo.get_by_phone_number(email_or_phone)
            if not user:
                # Try username (some users may provide username instead of email)
                user = self.user_repo.get_by_username(email_or_phone)
                if user:
                    # If a username was provided, switch the target to the user's email
                    email_or_phone = user.email or email_or_phone
            # Fallback: try fuzzy phone substring search across users
            if not user:
                users = self.user_repo.get_all()
                for u in users:
                    if u.phone_number and email_or_phone in u.phone_number:
                        user = u
                        break
        
        if not user:
            # Don't reveal if user exists (security best practice)
            # But still send a generic notification to the supplied address/phone
            # (User requested: always send a notification on forgot-password)
            email_service = EmailService()
            sms_service = SMSService()

            generic_message_text = (
                "A password reset was requested for this address. "
                "If you initiated this request, follow the instructions on the password reset page. "
                "If you did not request this, you can safely ignore this message."
            )

            try:
                if '@' in email_or_phone:
                    subject = "Password reset requested"
                    # Simple HTML and text bodies
                    html_body = f"<p>{generic_message_text}</p><p>If needed, visit: {settings.FRONTEND_URL}/reset-password</p>"
                    text_body = generic_message_text + f"\nVisit: {settings.FRONTEND_URL}/reset-password"
                    email_service.send_email(email_or_phone, subject, html_body, text_body)
                else:
                    # send generic SMS notification (do not include codes)
                    sms_service.send_sms(email_or_phone, generic_message_text)
            except Exception:
                # Swallow exceptions to avoid revealing implementation details
                logger.exception("Error sending generic password reset notification")

            return {
                "message": "If an account exists with this email/phone, you will receive a password reset link/code shortly."
            }
        
        # Generate reset token and code
        reset_token = self.generate_reset_token()
        reset_code = self.generate_reset_code()
        expires_at = datetime.now(timezone.utc) + timedelta(minutes=self.token_expiry_minutes)
        
        # Create reset token record
        reset_token_record = PasswordResetToken(
            user_id=user.id,
            token=reset_token,
            reset_code=reset_code,
            expires_at=expires_at,
            is_used=False
        )
        
        self.db.add(reset_token_record)
        self.db.commit()
        self.db.refresh(reset_token_record)
        
        # Send email with reset link and SMS with reset code
        email_service = EmailService()
        sms_service = SMSService()

        # Always attempt to email the reset code/link when we have the user's email
        display_name = user.full_name or user.username or user.email
        try:
            if user.email:
                # pass both reset_code and reset_token so the email can include both
                email_service.send_password_reset_email(user.email, reset_token=reset_token, reset_code=reset_code, user_name=display_name)
                # Log the tokenized frontend URL and the single-line email text for easy verification
                frontend_reset_url = f"{settings.FRONTEND_URL}/reset-password"
                if reset_token:
                    frontend_reset_url = f"{frontend_reset_url}?token={reset_token}"
                logger.info(f"Password reset link for {user.email}: {frontend_reset_url}")
                single_line_email = (
                    f"Hello {display_name}, We received a request to reset your password. "
                    f"Your password reset code is: ➡ {reset_code} "
                    f"Please enter this code on the password reset page: {frontend_reset_url} "
                    f"Note: This code is valid for {self.token_expiry_minutes} minutes. "
                    f"If you did not request a password reset, you can safely ignore this email. With regards, Support Team"
                )
                logger.info(single_line_email)
        except Exception:
            logger.exception("Error sending password reset email; continuing")

        # If request was via phone (no '@'), still send SMS
        if '@' in email_or_phone:
            # request came by email; we've already attempted email delivery
            pass
        else:
            # Send SMS with reset code
            try:
                sms_service.send_password_reset_sms(email_or_phone, reset_code)
            except Exception:
                logger.exception("Error sending password reset SMS; continuing")
        
        # Log in debug mode
        # Log the reset (always helpful in debug). The actual email send may be skipped if email not configured.
        if settings.DEBUG:
            if '@' in email_or_phone:
                logger.info(f"Password reset link for {email_or_phone}: {settings.FRONTEND_URL}/reset-password?token={reset_token}")
            else:
                logger.info(f"Password reset code for {email_or_phone}: {reset_code}")

        # Return a generic message; include debug details only when explicitly requested
        response = {
            "message": "If an account exists with this email/phone, you will receive a password reset link/code shortly.",
            "expires_in_minutes": self.token_expiry_minutes
        }

        if settings.DEBUG and include_debug:
            # include safe debug details for development/testing only when requested
            response["debug"] = {
                "reset_token": reset_token,
                "reset_code": reset_code,
                "reset_url": f"{settings.FRONTEND_URL}/reset-password?token={reset_token}"
            }

        return response
    
    def verify_reset_code(self, email_or_phone: str, reset_code: Optional[str] = None, reset_token: Optional[str] = None) -> dict:
        """Verify reset code or token"""
        if not reset_code and not reset_token:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Either reset_code or reset_token must be provided"
            )
        
        # Find user
        user = None
        if '@' in email_or_phone:
            user = self.user_repo.get_by_email(email_or_phone)
        else:
            users = self.user_repo.get_all()
            for u in users:
                if u.phone_number and email_or_phone in u.phone_number:
                    user = u
                    break
        
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        
        # Find reset token
        query = self.db.query(PasswordResetToken).filter(
            PasswordResetToken.user_id == user.id,
            PasswordResetToken.is_used == False
        )
        
        if reset_token:
            query = query.filter(PasswordResetToken.token == reset_token)
        elif reset_code:
            query = query.filter(PasswordResetToken.reset_code == reset_code)
        
        reset_token_record = query.first()
        
        if not reset_token_record:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid reset code or token"
            )
        
        # Check expiration
        if reset_token_record.expires_at < datetime.now(timezone.utc):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Reset link/code has expired. Please request a new one."
            )
        
        return {
            "valid": True,
            "token": reset_token_record.token,
            "user_id": user.id
        }
    
    def reset_password(
        self,
        reset_token: Optional[str] = None,
        reset_code: Optional[str] = None,
        email_or_phone: str = None,
        new_password: str = None
    ) -> dict:
        """Complete password reset"""
        # Verify reset token/code first
        verification = self.verify_reset_code(email_or_phone, reset_code, reset_token)
        user_id = verification["user_id"]
        
        # Get reset token record
        query = self.db.query(PasswordResetToken).filter(
            PasswordResetToken.user_id == user_id,
            PasswordResetToken.is_used == False
        )
        
        if reset_token:
            query = query.filter(PasswordResetToken.token == reset_token)
        elif reset_code:
            query = query.filter(PasswordResetToken.reset_code == reset_code)
        
        reset_token_record = query.first()
        
        if not reset_token_record:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid reset token or code"
            )
        
        # Update password
        user = self.user_repo.get_by_id(user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        
        user.hashed_password = get_password_hash(new_password)
        self.db.commit()
        
        # Mark token as used
        reset_token_record.is_used = True
        reset_token_record.used_at = datetime.now(timezone.utc)
        self.db.commit()
        
        return {
            "message": "Password reset successfully. Please login with your new password."
        }



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\payment_service.py ---
import random, string
from datetime import datetime
from app.models.payment import BookingPayment as Payment, BookingRefund as Refund, Confirmation
from sqlalchemy.orm import Session

def _generate_ref(prefix: str) -> str:
    suffix = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
    return f"{prefix}{datetime.utcnow().strftime('%Y%m%d%H%M')}{suffix}"

# 1️⃣ Initiate Payment
def initiate_payment(db: Session, data, user_id: int):
    payment = Payment(
        booking_id=data.booking_id,
        user_id=user_id,
        payment_type=data.payment_type,
        amount=data.amount,
        currency=data.currency,
        payment_method=data.payment_method,
        payment_gateway=data.payment_gateway,
        description=data.description,
        status="processing",
        gateway_order_id=f"order_{''.join(random.choices(string.ascii_lowercase + string.digits, k=14))}"
    )
    db.add(payment)
    db.commit()
    db.refresh(payment)

    return {
        "payment_id": payment.id,
        "client_secret": None,
        "gateway_order_id": payment.gateway_order_id,
        "amount": payment.amount,
        "currency": payment.currency,
        "gateway_url": None
    }

# 2️⃣ Confirm Payment
def confirm_payment(db: Session, payment_id: int):
    payment = db.query(Payment).filter(Payment.id == payment_id).first()
    if not payment:
        return None

    payment.status = "completed"
    payment.payment_reference = _generate_ref("PAY")
    payment.completed_at = datetime.utcnow()
    payment.gateway_transaction_id = payment.gateway_order_id
    db.commit()
    db.refresh(payment)

    confirmation_number = _generate_ref("CONF")
    pdf_html = f"<h1>Booking Payment Confirmation</h1><p>Payment Ref: {payment.payment_reference}</p>"
    confirmation = Confirmation(
        booking_id=payment.booking_id,
        confirmation_number=confirmation_number,
        confirmation_type="booking_payment",
        pdf_content=pdf_html,
        email_sent=True
    )
    db.add(confirmation)
    db.commit()

    # Simulate email log in console
    print("\n📧 EMAIL SENT")
    print(f"To: john.doe@example.com")
    print(f"Subject: Booking Confirmation - {confirmation_number}")
    print(f"Content length: {len(pdf_html)} chars")
    print("="*50)

    return payment

# 3️⃣ Refund
def refund_payment(db: Session, data):
    refund = Refund(
        payment_id=data.payment_id,
        refund_reference=_generate_ref("RFD"),
        amount=data.amount,
        reason=data.reason,
        status="completed"
    )
    db.add(refund)
    db.commit()
    db.refresh(refund)
    return refund

# 4️⃣ Security Deposit Release
def release_security_deposit(db: Session, data):
    payment = db.query(Payment).filter(Payment.id == data.payment_id).first()
    if not payment:
        return None

    refund_amount = max(0.0, payment.amount - data.deduction_amount)
    payment.security_deposit_refunded = True
    db.commit()

    return {
        "message": "Security deposit released successfully",
        "refund_amount": refund_amount,
        "deduction_amount": data.deduction_amount,
        "payment_reference": payment.payment_reference
    }

# 5️⃣ Get Confirmation
def get_confirmation(db: Session, confirmation_number: str):
    return db.query(Confirmation).filter(Confirmation.confirmation_number == confirmation_number).first()

# 6️⃣ List Payments
def get_all_payments(db: Session):
    return db.query(Payment).all()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\payment_services.py ---
from fastapi import HTTPException
from app.repositories.razorpay_repositorys import RazorpayRepository
from app.models.subscription import Payment
from app.models.subscription import PaymentStatus
from app.models.user import User
from datetime import datetime
import  os, uuid
from app.core.razorpay_client import razorpay_client

# ✅ Razorpay client setup
# razorpay_client = razorpay.Client(auth=(
#     os.getenv("RAZORPAY_KEY_ID"),
#     os.getenv("RAZORPAY_KEY_SECRET")
# ))

class RazorpayService:
    @staticmethod
    def create_order(db, request, current_user):
        # ✅ Validate user
        # user = RazorpayRepository.get_user_by_id(db, request.user_id)
        # if not user:
        #     raise HTTPException(status_code=400, detail="Invalid user_id: User does not exist")

        # ✅ Validate hostel
        hostel = RazorpayRepository.get_hostel_by_id(db, request.hostel_id)
        if not hostel:
            raise HTTPException(status_code=400, detail="Invalid hostel_id: Hostel does not exist")

        # ✅ Prepare Razorpay order payload
        order_data = {
            "amount": int(request.amount * 100),
            "currency": request.currency,
            "receipt": f"rcpt_{uuid.uuid4().hex[:8]}",
            "notes": {
                "user_id":current_user.id,
                "hostel_id": request.hostel_id,
                "description": request.description
            },
        }

        # ✅ Create order in Razorpay
        razorpay_order = razorpay_client.order.create(order_data)

        # ✅ Store in DB
        payment = Payment(
            order_id=razorpay_order["id"],
            gateway_order_id=razorpay_order["id"],
            gateway="razorpay",
            amount=request.amount,
            currency=request.currency,
            status="pending",
            user_id=current_user.id,
            # user_id=request.user_id,
            hostel_id=request.hostel_id,
            description=request.description,
            created_at=datetime.utcnow()
        )

        RazorpayRepository.save_payment(db, payment)

        return {
            "message": "Order created successfully",
            "razorpay_order": razorpay_order,
            "local_payment_id": payment.id
        }

#payments,partial payments, refunds, customers, and generates PDF receipts.
# app/services/payment_service.py
# from datetime import datetime
# import uuid
# from app.models.payment_models import Invoice, Transaction, Receipt, RefundRequest, TransactionType, PaymentStatus
# from app.repositories.payment_repository import PaymentRepository
# from app.utils.receipt_generator import generate_receipt_pdf
# from sqlalchemy.orm import Session

# def generate_invoice_number():
#     return f"INV-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"

# def generate_transaction_id():
#     return f"TXN-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8].upper()}"

# def generate_receipt_number():
#     return f"RCP-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"

# def generate_refund_id():
#     return f"RFN-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"

# class PaymentService:

#     @staticmethod
#     def create_invoice(db: Session, user_id: int, hostel_id: int, items: list, description: str, due_date):
#         total = sum(i['amount'] for i in items)
#         inv = Invoice(
#             invoice_number=generate_invoice_number(),
#             user_id=user_id,
#             hostel_id=hostel_id,
#             total_amount=total,
#             paid_amount=0.0,
#             due_amount=total,
#             description=description,
#             items=__import__("json").dumps(items),
#             due_date=due_date,
#             status=PaymentStatus.PENDING
#         )
#         return PaymentRepository.create_invoice(db, inv)

#     @staticmethod
#     def process_payment(db: Session, invoice_id: int, amount: float, payment_method: str, payment_gateway: str=None, gateway_transaction_id: str=None, notes: str=None, processed_by: int=None):
#         invoice = PaymentRepository.get_invoice(db, invoice_id)
#         if not invoice:
#             raise ValueError("Invoice not found")
#         if amount > invoice.due_amount:
#             raise ValueError("Amount exceeds due amount")
#         txn = Transaction(
#             transaction_id=generate_transaction_id(),
#             invoice_id=invoice.id,
#             transaction_type=TransactionType.PAYMENT,
#             amount=amount,
#             payment_method=payment_method,
#             payment_gateway=payment_gateway,
#             gateway_transaction_id=gateway_transaction_id,
#             notes=notes,
#             status="success",
#             processed_by=processed_by
#         )
#         PaymentRepository.save_transaction(db, txn)

#         # update invoice
#         invoice.paid_amount += amount
#         invoice.due_amount -= amount
#         invoice.updated_at = datetime.utcnow()
#         if invoice.due_amount <= 0:
#             invoice.status = PaymentStatus.COMPLETED
#             invoice.due_amount = 0
#         elif invoice.paid_amount > 0:
#             invoice.status = PaymentStatus.PARTIAL
#         db.commit()
#         db.refresh(txn)

#         # create receipt
#         receipt = Receipt(
#             receipt_number=generate_receipt_number(),
#             invoice_id=invoice.id,
#             transaction_id=txn.id,
#             amount=txn.amount,
#             qr_code_data=f"R:{generate_receipt_number()}|A:{txn.amount}"
#         )
#         PaymentRepository.save_receipt(db, receipt)

#         # generate pdf synchronously (you can move to background)
#         pdf_path = generate_receipt_pdf(receipt, invoice, txn)
#         receipt.pdf_path = pdf_path
#         db.commit()
#         db.refresh(receipt)

#         return txn

#     @staticmethod
#     def request_refund(db: Session, transaction_id: int, refund_amount: float, reason: str, requested_by: int):
#         txn = PaymentRepository.get_transaction(db, transaction_id)
#         if not txn:
#             raise ValueError("Transaction not found")
#         refund = RefundRequest(
#             refund_id=generate_refund_id(),
#             transaction_id=txn.id,
#             invoice_id=txn.invoice_id,
#             refund_amount=refund_amount,
#             reason=reason,
#             requested_by=requested_by,
#             status='initiated'
#         )
#         return PaymentRepository.create_refund_request(db, refund)



# from datetime import datetime
# import uuid, json
# from sqlalchemy.orm import Session
# from app.models.payment_models import (
#     Invoice, Transaction, Receipt, RefundRequest,
#     TransactionType, PaymentStatus
# )
# from app.repositories.payment_repository import PaymentRepository
# from app.utils.receipt_generator import generate_receipt_pdf


# # -------------------------------------------------------------------
# # 🔹 Helper ID Generators
# # -------------------------------------------------------------------
# def generate_invoice_number():
#     return f"INV-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"

# def generate_transaction_id():
#     return f"TXN-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8].upper()}"

# def generate_receipt_number():
#     return f"RCP-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"

# def generate_refund_id():
#     return f"RFN-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"


# # -------------------------------------------------------------------
# # 💳 Payment Service Layer
# # -------------------------------------------------------------------
# class PaymentService:

#     # ---------------------------------------------------------------
#     # 🧾 Create Invoice
#     # ---------------------------------------------------------------
#     @staticmethod
#     def create_invoice(db: Session, user_id: int, hostel_id: int, items: list, description: str, due_date):
#         total = sum(i['amount'] for i in items)
#         invoice = Invoice(
#             invoice_number=generate_invoice_number(),
#             user_id=user_id,
#             hostel_id=hostel_id,
#             total_amount=total,
#             paid_amount=0.0,
#             due_amount=total,
#             description=description,
#             items=json.dumps(items),
#             due_date=due_date,
#             status=PaymentStatus.PENDING.value  # ✅ ensure lowercase enum value
#         )
#         return PaymentRepository.create_invoice(db, invoice)


#     # ---------------------------------------------------------------
#     # 💰 Process Payment → Creates Transaction + Receipt
#     # ---------------------------------------------------------------
#     @staticmethod
#     def process_payment(
#         db: Session,
#         invoice_id: int,
#         amount: float,
#         payment_method: str,
#         payment_gateway: str = None,
#         gateway_transaction_id: str = None,
#         notes: str = None,
#         processed_by: int = None
#     ):
#         try:
#             invoice = PaymentRepository.get_invoice(db, invoice_id)
#             if not invoice:
#                 raise ValueError("Invoice not found")

#             if amount > invoice.due_amount:
#                 raise ValueError(f"Amount exceeds due amount ₹{invoice.due_amount}")

#             # 💳 Create Transaction
#             txn = Transaction(
#                 transaction_id=generate_transaction_id(),
#                 invoice_id=invoice.id,
#                 transaction_type=TransactionType.PAYMENT,
#                 amount=amount,
#                 payment_method=payment_method,
#                 payment_gateway=payment_gateway,
#                 gateway_transaction_id=gateway_transaction_id,
#                 notes=notes,
#                 status="success",
#                 processed_by=processed_by
#             )
#             PaymentRepository.save_transaction(db, txn)

#             # 💡 Update Invoice status and amounts
#             invoice.paid_amount += amount
#             invoice.due_amount = max(invoice.due_amount - amount, 0)
#             invoice.updated_at = datetime.utcnow()

#             if invoice.due_amount <= 0:
#                 invoice.status = PaymentStatus.COMPLETED.value
#                 invoice.due_amount = 0
#             elif invoice.paid_amount > 0:
#                 invoice.status = PaymentStatus.PARTIAL.value

#             db.commit()
#             db.refresh(invoice)
#             db.refresh(txn)

#             # 🧾 Create Receipt (always, even if PDF fails)
#             receipt_number = generate_receipt_number()
#             receipt = Receipt(
#                 receipt_number=receipt_number,
#                 invoice_id=invoice.id,
#                 transaction_id=txn.id,
#                 amount=txn.amount,
#                 qr_code_data=f"Receipt:{receipt_number}|Amount:{txn.amount}|Date:{datetime.utcnow().isoformat()}",
#                 generated_at=datetime.utcnow()
#             )
#             PaymentRepository.save_receipt(db, receipt)

#             # 🧾 Try generating PDF
#             try:
#                 pdf_path = generate_receipt_pdf(receipt, invoice, txn, db)
#                 receipt.pdf_path = pdf_path
#                 db.commit()
#                 db.refresh(receipt)
#                 print(f"✅ Receipt generated successfully: {receipt.receipt_number}")
#             except Exception as pdf_error:
#                 db.commit()  # commit even if PDF fails
#                 print(f"⚠️ PDF generation failed for receipt {receipt.receipt_number}: {pdf_error}")

#             return txn

#         except Exception as e:
#             db.rollback()
#             print(f"❌ Payment processing error: {e}")
#             raise ValueError(f"Payment processing failed: {str(e)}")


#     # ---------------------------------------------------------------
#     # 💸 Request Refund
#     # ---------------------------------------------------------------
#     @staticmethod
#     def request_refund(db: Session, transaction_id: int, refund_amount: float, reason: str, requested_by: int):
#         txn = PaymentRepository.get_transaction(db, transaction_id)
#         if not txn:
#             raise ValueError("Transaction not found")

#         refund = RefundRequest(
#             refund_id=generate_refund_id(),
#             transaction_id=txn.id,
#             invoice_id=txn.invoice_id,
#             refund_amount=refund_amount,
#             reason=reason,
#             requested_by=requested_by,
#             status='initiated'
#         )
#         return PaymentRepository.create_refund_request(db, refund)

from datetime import datetime
import uuid, json
from sqlalchemy.orm import Session
from fastapi import HTTPException
from app.models.payment_models import (
    Invoice, Transaction, Receipt, RefundRequest,
    TransactionType
)
from app.models.subscription import Payment
from app.models.subscription import PaymentStatus
from app.repositories.payment_repositorys import PaymentRepository
from app.utils.receipt_generatorss import generate_receipt_pdf


# -------------------------------------------------------------------
# 🔹 Helper ID Generators
# -------------------------------------------------------------------
def generate_invoice_number():
    return f"INV-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"

def generate_transaction_id():
    return f"TXN-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8].upper()}"

def generate_receipt_number():
    return f"RCP-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"

def generate_refund_id():
    return f"RFN-{datetime.utcnow().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"


# -------------------------------------------------------------------
# 💳 Payment Service Layer
# -------------------------------------------------------------------
class PaymentService:

    # ---------------------------------------------------------------
    # 🧾 Create Invoice
    # ---------------------------------------------------------------
    @staticmethod
    def create_invoice(db: Session, user_id: int, hostel_id: int, items: list, description: str, due_date):
        total = sum(i['amount'] for i in items)
        invoice = Invoice(
            invoice_number=generate_invoice_number(),
            user_id=user_id,
            hostel_id=hostel_id,
            total_amount=total,
            paid_amount=0.0,
            due_amount=total,
            description=description,
            items=json.dumps(items),
            due_date=due_date,
            status=PaymentStatus.pending.value  # ✅ ensure lowercase enum value
        )
        return PaymentRepository.create_invoice(db, invoice)


    # ---------------------------------------------------------------
    # 💰 Process Payment → Creates Transaction + Receipt
    # ---------------------------------------------------------------
    @staticmethod
    def process_payment(
        db: Session,
        invoice_id: int,
        amount: float,
        payment_method: str,
        payment_gateway: str = None,
        gateway_transaction_id: str = None,
        notes: str = None,
        processed_by: int = None
    ):
        try:
            # 1️⃣ Validate invoice
            invoice = PaymentRepository.get_invoice(db, invoice_id)
            if not invoice:
                raise ValueError("Invoice not found")

            if amount > invoice.due_amount:
                raise ValueError(f"Amount exceeds due amount ₹{invoice.due_amount}")
            # 2️⃣ ALWAYS create a Payment entry for invoice payments
            payment = Payment(
                user_id=invoice.user_id,
                hostel_id=invoice.hostel_id,
                amount=amount,
                currency="INR",
                status=PaymentStatus.succeeded.value,
                description=notes or "Invoice payment",
                created_at=datetime.utcnow()
                )
            db.add(payment)
            db.commit()
            db.refresh(payment)
            payment_id = payment.id


            # 2️⃣ Find related Payment automatically
            
            # payment = (
            #     db.query(Payment)
            #     .filter(
            #         Payment.user_id == invoice.user_id,
            #         Payment.hostel_id == invoice.hostel_id
            #     )
            #     .order_by(Payment.created_at.desc())
            #     .first()
            # )
            # payment_id = payment.id if payment else None

            # 3️⃣ Create Transaction
            txn = Transaction(
                transaction_id=generate_transaction_id(),
                payment_id=payment_id,  # ✅ Auto-linked
                invoice_id=invoice.id,
                transaction_type=TransactionType.PAYMENT,
                amount=amount,
                payment_method=payment_method,
                payment_gateway=payment_gateway,
                gateway_transaction_id=gateway_transaction_id,
                notes=notes,
                status="success",
                processed_by=processed_by,
                created_at=datetime.utcnow()
            )
            PaymentRepository.save_transaction(db, txn)

            # 4️⃣ Update Invoice totals and status
            invoice.paid_amount += amount
            invoice.due_amount = max(invoice.due_amount - amount, 0)
            invoice.updated_at = datetime.utcnow()

            if invoice.due_amount <= 0:
                invoice.status = PaymentStatus.succeeded.value   
                invoice.due_amount = 0
            elif invoice.paid_amount > 0:
                invoice.status = PaymentStatus.pending.value

            # 5️⃣ Update Payment status too (if exists)
            if payment:
                payment.status = PaymentStatus.succeeded.value
                payment.updated_at = datetime.utcnow()

            db.commit()
            db.refresh(invoice)
            db.refresh(txn)

            # 6️⃣ Generate Receipt
            receipt_number = generate_receipt_number()
            receipt = Receipt(
                receipt_number=receipt_number,
                invoice_id=invoice.id,
                transaction_id=txn.id,
                payment_id=txn.payment_id,
                amount=txn.amount,
                qr_code_data=f"Receipt:{receipt_number}|Amount:{txn.amount}|Date:{datetime.utcnow().isoformat()}",
                generated_at=datetime.utcnow()
            )
            PaymentRepository.save_receipt(db, receipt)

            # 7️⃣ Try generating PDF
            try:
                pdf_path = generate_receipt_pdf(receipt, invoice, txn, db)
                receipt.pdf_path = pdf_path
                db.commit()
                db.refresh(receipt)
                print(f"✅ Receipt generated successfully: {receipt.receipt_number}")
            except Exception as pdf_error:
                db.commit()  # commit even if PDF generation fails
                print(f"⚠️ PDF generation failed for {receipt.receipt_number}: {pdf_error}")

            return txn

        except Exception as e:
            db.rollback()
            print(f"❌ Payment processing error: {e}")
            raise ValueError(f"Payment processing failed: {str(e)}")


    # ---------------------------------------------------------------
    # 💸 Request Refund
    # ---------------------------------------------------------------
    @staticmethod
    def request_refund(
        db: Session,
        transaction_id: int,
        refund_amount: float,
        reason: str,
        requested_by: int
    ):
        txn = PaymentRepository.get_transaction(db, transaction_id)
        if not txn:
            raise ValueError("Transaction not found")

        refund = RefundRequest(
            refund_id=generate_refund_id(),
            transaction_id=txn.id,
            invoice_id=txn.invoice_id,
            refund_amount=refund_amount,
            reason=reason,
            requested_by=requested_by,
            status="initiated"
        )
        return PaymentRepository.create_refund_request(db, refund)


# app/services/refund_service.py
# from sqlalchemy.orm import Session
# from datetime import datetime
# import uuid
# from typing import Dict
# from app.repositories.payment_repository import RefundRepository
# from app.repositories.invoice_repository import InvoiceRepository
# from app.models.payment_models import TransactionType, PaymentStatus
# from app.schemas.payment_schemas import RefundApproval

# class RefundService:
#     """Business logic for refund operations"""
    
#     def __init__(self, db: Session):
#         self.db = db
#         self.refund_repo = RefundRepository(db)
#         self.invoice_repo = InvoiceRepository(db)
    
#     @staticmethod
#     def generate_transaction_id() -> str:
#         """Generate unique transaction ID"""
#         timestamp = datetime.utcnow().strftime('%Y%m%d%H%M%S')
#         unique_id = uuid.uuid4().hex[:8].upper()
#         return f"TXN-{timestamp}-{unique_id}"
    
#     def calculate_invoice_status(self, paid_amount: float, due_amount: float) -> str:
#         """Determine invoice status based on payment amounts"""
#         if paid_amount <= 0:
#             return PaymentStatus.PENDING.value
#         elif due_amount > 0:
#             return PaymentStatus.PARTIAL.value
#         else:
#             return PaymentStatus.SUCCESS.value
    
#     def approve_refund(self, refund_id: int, approval: RefundApproval) -> Dict:
#         """Approve a refund request and update invoice"""
#         refund = self.refund_repo.get_by_id(refund_id)
#         if not refund:
#             raise ValueError("Refund request not found")
        
#         if refund.status not in ["initiated", "processing"]:
#             raise ValueError(f"Refund already {refund.status}")

#         try:
#             txn_id = self.generate_transaction_id()
#             transaction_data = {
#                 "transaction_id": txn_id,
#                 "invoice_id": refund.invoice_id,
#                 "transaction_type": TransactionType.REFUND.value,
#                 "amount": -abs(refund.refund_amount),
#                 "payment_method": "refund",
#                 "notes": f"Refund processed: {refund.reason}",
#                 "status": "success",
#                 "processed_by": approval.approved_by,
#                 "created_at": datetime.utcnow()
#             }
#             txn = self.refund_repo.create_refund_transaction(transaction_data)

#             invoice = self.invoice_repo.get_by_id(refund.invoice_id)
#             if not invoice:
#                 raise ValueError("Invoice linked to refund not found")

#             new_paid = max(invoice.paid_amount - refund.refund_amount, 0)
#             new_due = invoice.due_amount + refund.refund_amount
#             new_status = self.calculate_invoice_status(new_paid, new_due)

#             self.invoice_repo.update_payment_status(invoice, new_paid, new_due, new_status)

#             self.refund_repo.update_status(
#                 refund,
#                 status="completed",
#                 approved_by=approval.approved_by,
#                 processed_at=datetime.utcnow(),
#                 completed_at=datetime.utcnow()
#             )

#             self.db.commit()
#             self.db.refresh(refund)

#             return {
#                 "success": True,
#                 "message": "Refund approved successfully",
#                 "refund": {
#                     "refund_id": refund.refund_id,
#                     "status": refund.status,
#                     "refund_amount": refund.refund_amount,
#                     "approved_by": refund.approved_by,
#                     "processed_at": refund.processed_at,
#                     "completed_at": refund.completed_at,
#                 },
#                 "transaction_id": txn_id
#             }

#         except Exception as e:
#             self.db.rollback()
#             raise Exception(f"Refund approval failed: {str(e)}")

#     def reject_refund(self, refund_id: int, approval: RefundApproval) -> Dict:
#         """Reject a refund request"""
#         refund = self.refund_repo.get_by_id(refund_id)
#         if not refund:
#             raise ValueError("Refund request not found")
#         if refund.status not in ["initiated", "processing"]:
#             raise ValueError(f"Refund already {refund.status}")
        
#         try:
#             self.refund_repo.update_status(
#                 refund,
#                 status="rejected",
#                 rejection_reason=approval.rejection_reason,
#                 approved_by=approval.approved_by,
#                 processed_at=datetime.utcnow()
#             )
#             self.db.commit()
#             self.db.refresh(refund)

#             return {
#                 "success": True,
#                 "message": "Refund request rejected",
#                 "refund": {
#                     "refund_id": refund.refund_id,
#                     "status": refund.status,
#                     "refund_amount": refund.refund_amount,
#                     "approved_by": refund.approved_by,
#                     "rejection_reason": refund.rejection_reason,
#                     "processed_at": refund.processed_at,
#                 }
#             }

#         except Exception as e:
#             self.db.rollback()
#             raise Exception(f"Refund rejection failed: {str(e)}")




# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\permission_service.py ---
"""
Supervisor permission engine
"""
from sqlalchemy.orm import Session
from typing import List, Optional
from fastapi import HTTPException, status
from datetime import datetime

from app.core.permissions import Permission, has_permission
from app.core.roles import get_role_level
from app.repositories.permission_repository import PermissionRepository
from app.repositories.approval_repository import ApprovalRepository
from app.schemas.permission import PermissionCreate, RolePermissionAssign
from app.schemas.approval import ApprovalRequestCreate, ApprovalAction


class PermissionService:
    def __init__(self, db: Session):
        self.db = db
        self.permission_repo = PermissionRepository(db)
        self.approval_repo = ApprovalRepository(db)
    
    # Approval thresholds for different actions
    APPROVAL_THRESHOLDS = {
        "delete_user": 4,  # Requires Admin level (4) or higher
        "update_user": 3,  # Requires Supervisor level (3) or higher
        "delete_hostel": 5,  # Requires SuperAdmin level (5)
        "create_hostel": 5,  # Requires SuperAdmin level (5)
    }
    
    def check_permission(self, role: str, permission_name: str) -> bool:
        """Check if role has permission (with hierarchical override)"""
        # Check direct permission
        if has_permission(role, permission_name):
            return True
        
        # Check database permissions (for dynamic permissions)
        permissions = self.permission_repo.get_role_permissions(role)
        permission_names = [p.name for p in permissions]
        return permission_name in permission_names
    
    def assign_permission_to_role(self, assign_data: RolePermissionAssign) -> dict:
        """Assign permission to role"""
        # Verify permission exists
        permission = self.permission_repo.get_by_id(assign_data.permission_id)
        if not permission:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Permission not found"
            )
        
        # Assign
        role_perm = self.permission_repo.assign_permission_to_role(
            assign_data.role,
            assign_data.permission_id
        )
        
        return {
            "role": role_perm.role,
            "permission_id": role_perm.permission_id,
            "message": "Permission assigned successfully"
        }
    
    def get_role_permissions(self, role: str) -> dict:
        """Get all permissions for a role (static + dynamic)"""
        # Get static permissions
        from app.core.permissions import PERMISSION_MATRIX
        static_perms = list(PERMISSION_MATRIX.get(role, set()))
        
        # Get dynamic permissions from database
        db_permissions = self.permission_repo.get_role_permissions(role)
        dynamic_perms = [p.name for p in db_permissions]
        
        # Combine
        all_permissions = list(set(static_perms + dynamic_perms))
        
        return {
            "role": role,
            "permissions": all_permissions,
            "count": len(all_permissions)
        }
    
    def get_all_permissions(self) -> List[dict]:
        """Get all available permissions"""
        permissions = self.permission_repo.get_all()
        return [
            {
                "id": p.id,
                "name": p.name,
                "description": p.description,
                "resource": p.resource,
                "action": p.action
            }
            for p in permissions
        ]
    
    def requires_approval(self, action: str, user_role: str) -> bool:
        """Check if action requires approval based on threshold"""
        if action not in self.APPROVAL_THRESHOLDS:
            return False
        
        threshold_level = self.APPROVAL_THRESHOLDS[action]
        user_level = get_role_level(user_role)
        
        # If user level is below threshold, approval is required
        return user_level < threshold_level
    
    def create_approval_request(
        self,
        requester_id: int,
        action: str,
        resource_type: str,
        resource_id: Optional[int] = None,
        hostel_id: Optional[int] = None,
        request_details: Optional[str] = None
    ) -> dict:
        """Create an approval request for an action"""
        threshold_level = self.APPROVAL_THRESHOLDS.get(action, 5)  # Default to SuperAdmin level
        
        approval_data = ApprovalRequestCreate(
            action=action,
            resource_type=resource_type,
            resource_id=resource_id,
            hostel_id=hostel_id,
            request_details=request_details,
            threshold_level=threshold_level
        )
        
        approval_request = self.approval_repo.create(requester_id, approval_data)
        
        return {
            "id": approval_request.id,
            "status": approval_request.status,
            "message": "Approval request created. Waiting for approval.",
            "threshold_level": threshold_level
        }
    
    def check_approval_status(self, approval_id: int) -> dict:
        """Check status of an approval request"""
        approval = self.approval_repo.get_by_id(approval_id)
        if not approval:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Approval request not found"
            )
        
        return {
            "id": approval.id,
            "status": approval.status,
            "action": approval.action,
            "resource_type": approval.resource_type,
            "resource_id": approval.resource_id,
            "created_at": approval.created_at,
            "approved_at": approval.approved_at,
            "approval_notes": approval.approval_notes
        }
    
    def approve_request(self, approval_id: int, approver_id: int, notes: Optional[str] = None) -> dict:
        """Approve an approval request"""
        approval = self.approval_repo.approve(approval_id, approver_id, notes)
        if not approval:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Cannot approve this request. It may not be pending or not found."
            )
        
        return {
            "id": approval.id,
            "status": approval.status,
            "message": "Request approved successfully"
        }
    
    def reject_request(self, approval_id: int, approver_id: int, notes: Optional[str] = None) -> dict:
        """Reject an approval request"""
        approval = self.approval_repo.reject(approval_id, approver_id, notes)
        if not approval:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Cannot reject this request. It may not be pending or not found."
            )
        
        return {
            "id": approval.id,
            "status": approval.status,
            "message": "Request rejected"
        }
    
    def get_pending_approvals(self, approver_role: str, hostel_id: Optional[int] = None) -> List[dict]:
        """Get pending approvals that approver can handle"""
        approver_level = get_role_level(approver_role)
        approvals = self.approval_repo.get_pending_for_approver(approver_level, hostel_id)
        
        return [
            {
                "id": a.id,
                "requester_id": a.requester_id,
                "action": a.action,
                "resource_type": a.resource_type,
                "resource_id": a.resource_id,
                "hostel_id": a.hostel_id,
                "request_details": a.request_details,
                "threshold_level": a.threshold_level,
                "created_at": a.created_at
            }
            for a in approvals
        ]



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\rbac_service.py ---
"""
Role-based access control logic
"""
from sqlalchemy.orm import Session
from fastapi import HTTPException, status

from app.core.roles import Role, can_manage_role, get_role_level
from app.core.permissions import has_permission, get_role_permissions
from app.repositories.user_repository import UserRepository
from app.repositories.permission_repository import PermissionRepository
from app.schemas.rbac import RoleAssign, PermissionCheck


class RBACService:
    def __init__(self, db: Session):
        self.db = db
        self.user_repo = UserRepository(db)
        self.permission_repo = PermissionRepository(db)
    
    def assign_role(self, assign_data: RoleAssign, assigner_role: str) -> dict:
        """Assign role to user (with permission check)"""
        # Check if assigner can manage this role
        if not can_manage_role(assigner_role, assign_data.role):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Your role cannot assign {assign_data.role} role"
            )
        
        # Get user
        user = self.user_repo.get_by_id(assign_data.user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        
        # Update user role
        from app.schemas.user import UserUpdate
        user_update = UserUpdate(role=assign_data.role)
        updated_user = self.user_repo.update(assign_data.user_id, user_update)
        
        return {
            "id": updated_user.id,
            "username": updated_user.username,
            "role": updated_user.role
        }
    
    def check_permission(self, check_data: PermissionCheck) -> bool:
        """Check if role has permission"""
        return has_permission(check_data.role, check_data.permission)
    
    def get_role_permissions_list(self, role: str) -> dict:
        """Get all permissions for a role"""
        permissions = get_role_permissions(role)
        return {
            "role": role,
            "permissions": list(permissions)
        }
    
    def validate_role_access(self, user_role: str, required_role: str) -> bool:
        """Validate if user role has access (hierarchy check)"""
        user_level = get_role_level(user_role)
        required_level = get_role_level(required_role)
        return user_level >= required_level



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\refund_service.py ---
from datetime import datetime


class RefundService:

    @staticmethod
    def calculate_refund(check_in: datetime, amount_paid: float) -> float:
        """
        Refund rules:
        - >7 days before check-in → 100%
        - 3–7 days → 50%
        - 0–2 days → 0%
        - After check-in → 0%
        """
        now = datetime.utcnow()
        days_left = (check_in - now).days

        if days_left > 7:
            return amount_paid
        elif 3 <= days_left <= 7:
            return amount_paid * 0.5
        elif 0 <= days_left <= 2:
            return 0.0
        else:
            return 0.0


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\reminder_services.py ---
# app/services/reminder_service.py

from datetime import datetime
import uuid
import json
from sqlalchemy.orm import Session
from app.models.payment_models import (
    Invoice, ReminderConfiguration, PaymentReminder, ReminderType,
    ReminderChannel, ReminderStatus, ReminderTemplate
)
from app.utils.email_utilss import send_email_reminder
from app.utils.sms_utilss import send_sms_reminder
from app.utils.template_utilss import render_template


# -----------------------------------------------------------
# Helpers
# -----------------------------------------------------------

def generate_reminder_id():
    return f"REM-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:6].upper()}"


def get_template_context(invoice: Invoice):
    """Generate template variables."""
    user = invoice.user
    hostel = invoice.hostel

    now = datetime.utcnow()
    days_overdue = max((now - invoice.due_date).days, 0)

    return {
        "user_name": user.name,
        "invoice_number": invoice.invoice_number,
        "amount": f"₹{invoice.due_amount:.2f}",
        "total_amount": f"₹{invoice.total_amount:.2f}" if hasattr(invoice, "total_amount") else "",
        "paid_amount": f"₹{invoice.paid_amount:.2f}",
        "due_date": invoice.due_date.strftime("%d-%b-%Y"),
        "days_overdue": days_overdue,
        "hostel_name": hostel.name,
        "hostel_phone": hostel.phone or "N/A",
        "hostel_email": hostel.email or "N/A",
        "payment_link": f"https://hostelpay.com/pay/{invoice.invoice_number}"
    }


def get_default_template(reminder_type: ReminderType, db: Session):
    return db.query(ReminderTemplate).filter(
        ReminderTemplate.reminder_type == reminder_type,
        ReminderTemplate.is_default == True
    ).first()


# -----------------------------------------------------------
# Core: Create Reminder
# -----------------------------------------------------------

def create_and_schedule_reminder(invoice: Invoice, reminder_type: ReminderType, channel: ReminderChannel, db: Session):
    user = invoice.user

    template = get_default_template(reminder_type, db)
    if not template:
        print(f"No template found for {reminder_type}")
        return

    context = get_template_context(invoice)

    subject = render_template(template.email_subject, context)
    email_body = render_template(template.email_body, context)
    sms_body = render_template(template.sms_body, context)

    reminder = PaymentReminder(
        reminder_id=generate_reminder_id(),
        invoice_id=invoice.id,
        reminder_type=reminder_type,
        channel=channel,
        recipient_email=user.email,
        recipient_phone=user.phone,
        subject=subject,
        message_body=email_body,
        scheduled_at=datetime.utcnow(),
        status=ReminderStatus.PENDING
    )

    db.add(reminder)
    db.commit()
    db.refresh(reminder)

    # Send instantly (real world: background worker)
    process_single_reminder(reminder.id, db)


# -----------------------------------------------------------
# Send Actual Emails/SMS
# -----------------------------------------------------------

def process_single_reminder(reminder_id: int, db: Session):
    reminder = db.query(PaymentReminder).filter(PaymentReminder.id == reminder_id).first()
    if not reminder:
        print("Reminder not found")
        return

    invoice = reminder.invoice
    user = invoice.user

    email_success = False
    sms_success = False

    # EMAIL
    if reminder.channel in [ReminderChannel.EMAIL, ReminderChannel.BOTH]:
        if user.email and user.email_notifications:
            email_success = send_email_reminder(
                reminder.recipient_email,
                reminder.subject,
                reminder.message_body
            )

    # SMS
    if reminder.channel in [ReminderChannel.SMS, ReminderChannel.BOTH]:
        if user.phone and user.sms_notifications:
            sms_success = send_sms_reminder(reminder.recipient_phone, reminder.message_body)

    # Update status
    if email_success or sms_success:
        reminder.status = ReminderStatus.SENT
        reminder.sent_at = datetime.utcnow()
        invoice.last_reminder_sent = datetime.utcnow()
        invoice.reminder_count += 1
    else:
        reminder.status = ReminderStatus.FAILED

    db.commit()


# -----------------------------------------------------------
# Automated Invoice Processing
# -----------------------------------------------------------

def process_invoice_reminders(invoice: Invoice, db: Session):
    now = datetime.utcnow()
    config = db.query(ReminderConfiguration).filter(
        ReminderConfiguration.hostel_id == invoice.hostel_id
    ).first()

    if not config:
        return

    if invoice.reminder_count >= config.max_reminders:
        return

    days_until_due = (invoice.due_date - now).days
    days_overdue = (now - invoice.due_date).days if now > invoice.due_date else 0

    reminder_type = None
    channel = None

    # 1️⃣ Pre-due reminders
    if days_until_due > 0:
        days_list = [int(d.strip()) for d in config.pre_due_days.split(",")]
        if days_until_due in days_list:
            reminder_type = ReminderType.PRE_DUE
            channel = config.pre_due_channels

    # 2️⃣ Due date reminder
    elif days_until_due == 0 and config.due_date_enabled:
        reminder_type = ReminderType.DUE_DATE
        channel = config.due_date_channels

    # 3️⃣ Overdue & Escalation
    elif days_overdue > 0:

        if config.escalation_enabled:

            if days_overdue >= config.final_notice_days and invoice.escalation_level < 4:
                reminder_type = ReminderType.FINAL_NOTICE
                channel = ReminderChannel.BOTH
                invoice.escalation_level = 4

            elif days_overdue >= config.escalation_3_days and invoice.escalation_level < 3:
                reminder_type = ReminderType.ESCALATION_3
                channel = ReminderChannel.BOTH
                invoice.escalation_level = 3

            elif days_overdue >= config.escalation_2_days and invoice.escalation_level < 2:
                reminder_type = ReminderType.ESCALATION_2
                channel = ReminderChannel.BOTH
                invoice.escalation_level = 2

            elif days_overdue >= config.escalation_1_days and invoice.escalation_level < 1:
                reminder_type = ReminderType.ESCALATION_1
                channel = ReminderChannel.BOTH
                invoice.escalation_level = 1

        if not reminder_type:
            if not invoice.last_reminder_sent or \
                (now - invoice.last_reminder_sent).days >= config.overdue_frequency_days:

                reminder_type = ReminderType.OVERDUE
                channel = config.overdue_channels

    # 4️⃣ If reminder needed, create it
    if reminder_type and channel:
        create_and_schedule_reminder(invoice, reminder_type, channel, db)


# -----------------------------------------------------------
# Scheduler Processing Loop
# -----------------------------------------------------------

def process_automated_reminders(db: Session):
    invoices = db.query(Invoice).filter(
        Invoice.status.in_(["pending", "partial", "overdue"])
    ).all()

    for invoice in invoices:
        process_invoice_reminders(invoice, db)

    db.commit()


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\report_services.py ---
from fastapi import HTTPException
from sqlalchemy.orm import Session
from datetime import datetime

from app.repositories.report_repositories import (
    create_booking, update_booking_status, get_pending_commissions, mark_commission_paid,
    calculate_financial_summary, generate_revenue_report, generate_commission_report,
    get_recent_reports, get_report_statistics, get_report_by_id
)
from app.utils.utils import generate_pdf_report, generate_csv_report, generate_excel_report



def book_room(db: Session, booking_data):
    return create_booking(db, booking_data)

def change_booking_status(db: Session, booking_id: str, status, payment_status):
    return update_booking_status(db, booking_id, status, payment_status)

def list_pending_commissions(db: Session, hostel_id: str = None):
    return get_pending_commissions(db, hostel_id)

def pay_commission(db: Session, commission_id: str):
    return mark_commission_paid(db, commission_id)

def get_financial_summary_service(db: Session, start_date: datetime, end_date: datetime):
    return calculate_financial_summary(db, start_date, end_date)

def fetch_recent_reports(db: Session, limit: int = 10):
    return get_recent_reports(db, limit)

def fetch_report_statistics(db: Session):
    return get_report_statistics(db)

def fetch_report(db: Session, report_id: str):
    report = get_report_by_id(db, report_id)
    if not report:
        raise HTTPException(status_code=404, detail="Report not found")
    return report

def export_report_file(report):
    export_format = (report.export_format or "pdf").lower()
    data = {
        "id": report.id,
        "name": report.name,
        "result_data": report.result_data or {}
    }
    print("Export format:", export_format)
    print("Result data keys:", data["result_data"].keys())  # check keys exist
    print("Daily breakdown length:", len(data["result_data"].get("daily_breakdown", [])))
    
    if export_format == "pdf":
        return generate_pdf_report(data)
    if export_format == "csv":
        return generate_csv_report(data)
    if export_format == "excel":
        return generate_excel_report(data)
    raise HTTPException(status_code=400, detail="Unsupported export format")



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\role_service.py ---
"""
Role assignments, updates
"""
from sqlalchemy.orm import Session
from typing import List

from app.core.roles import Role, get_all_roles, can_manage_role
from app.repositories.user_repository import UserRepository


class RoleService:
    def __init__(self, db: Session):
        self.db = db
        self.user_repo = UserRepository(db)
    
    def get_all_available_roles(self) -> List[str]:
        """Get all available roles"""
        return get_all_roles()
    
    def get_users_by_role(self, role: str, skip: int = 0, limit: int = 100) -> List[dict]:
        """Get all users with a specific role"""
        users = self.user_repo.get_all(skip=skip, limit=limit)
        filtered = [u for u in users if u.role == role]
        return [
            {
                "id": u.id,
                "username": u.username,
                "email": u.email,
                "full_name": u.full_name,
                "role": u.role,
                "hostel_id": u.hostel_id
            }
            for u in filtered
        ]
    
    def can_assign_role(self, assigner_role: str, target_role: str) -> bool:
        """Check if assigner can assign target role"""
        return can_manage_role(assigner_role, target_role)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\room_service.py ---
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from app.repositories.room_repository import (
    create_room as repo_create_room,
    get_room as repo_get_room,
    list_rooms as repo_list_rooms,
    update_room as repo_update_room,
    delete_room as repo_delete_room,
    set_room_maintenance as repo_set_room_maintenance,
    set_room_availability as repo_set_room_availability,
)
from app.schemas.rooms import RoomCreate, RoomUpdate
from app.models.rooms import Room, RoomType, MaintenanceStatus


def create_room(db: Session, room_in: RoomCreate) -> Room:
    return repo_create_room(db, room_in)


def get_room(db: Session, room_id: UUID) -> Optional[Room]:
    return repo_get_room(db, room_id)


def list_rooms(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    room_type: Optional[RoomType] = None,
    maintenance_status: Optional[MaintenanceStatus] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    min_capacity: Optional[int] = None,
    only_available: Optional[bool] = None,
    amenities_like: Optional[str] = None,
) -> List[Room]:
    return repo_list_rooms(
        db,
        skip=skip,
        limit=limit,
        room_type=room_type,
        maintenance_status=maintenance_status,
        min_price=min_price,
        max_price=max_price,
        min_capacity=min_capacity,
        only_available=only_available,
        amenities_like=amenities_like,
    )


def update_room(db: Session, room_id, room_in: RoomUpdate) -> Optional[Room]:
    room = repo_get_room(db, room_id)
    if not room:
        return None
    return repo_update_room(db, room, room_in)


def delete_room(db: Session, room_id) -> bool:
    room = repo_get_room(db, room_id)
    if not room:
        return False
    repo_delete_room(db, room)
    return True


def set_room_maintenance(db: Session, room_id: int, status: MaintenanceStatus) -> Optional[Room]:
    room = repo_get_room(db, room_id)
    if not room:
        return None
    return repo_set_room_maintenance(db, room, status)


def set_room_availability(db: Session, room_id: int, availability: int) -> Optional[Room]:
    room = repo_get_room(db, room_id)
    if not room:
        return None
    return repo_set_room_availability(db, room, availability)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\scheduler.py ---
# app/services/scheduler.py
from datetime import datetime, timedelta
import logging

from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger

from sqlalchemy import select
from sqlalchemy.orm import Session

from app.core.database import SessionLocal
from app.models.booking import Booking, BookingStatus
from app.models.rooms import Room

logger = logging.getLogger("hostel_scheduler")
logger.setLevel(logging.INFO)


# --- CONFIG ---
# How old (in hours) a PENDING booking must be to be expired automatically
DEFAULT_EXPIRY_HOURS = 24

# How often the scheduler will run (in seconds). For dev/testing you can set to 60.
DEFAULT_RUN_INTERVAL_SECONDS = 60  # run every minute. Change to 3600 for hourly, etc.
# ---------------


def expire_pending_bookings_once(expiry_hours: int = DEFAULT_EXPIRY_HOURS):
    """
    One-off run: finds bookings with status PENDING older than expiry_hours
    and marks them as rejected. Releases any bed if necessary.
    """
    cutoff = datetime.utcnow() - timedelta(hours=expiry_hours)
    db: Session = SessionLocal()

    expired_count = 0
    try:
        # Find pending bookings older than cutoff
        pending_q = db.query(Booking).filter(
            Booking.status == BookingStatus.pending,
            Booking.created_at < cutoff
        )

        pending_list = pending_q.all()

        if not pending_list:
            logger.info("No pending bookings to expire (cutoff=%s)", cutoff.isoformat())
            return {"expired": 0, "cutoff": cutoff.isoformat()}

        for booking in pending_list:
            try:
                # Extra-safety: if booking was somehow confirmed already, skip expiry
                if booking.status != BookingStatus.pending:
                    continue

                # mark booking as rejected
                booking.status = BookingStatus.rejected

                # If the booking had reserved/consumed a bed (shouldn't for pending),
                # ensure bed counts are correct. This is defensive: only decrement/increment
                # when consistent with your app's confirm flow.
                # We'll increment available_beds if booking was confirmed earlier (defensive)
                if booking.room_id:
                    room = db.query(Room).filter(Room.id == booking.room_id).first()
                    if room:
                        # only adjust if available_beds would logically increase
                        # (we don't want available_beds > total_beds; keep defensive checks)
                        try:
                            room.available_beds = min(room.total_beds, (room.available_beds + 1))
                        except Exception:
                            # fallback: try set to total_beds if anything weird
                            room.available_beds = room.total_beds

                # Placeholder: refund handling (if advance was paid & policy allows)
                # call_refund_processor(booking)  -> implement when integrating payment gateway

                db.add(booking)
                expired_count += 1
            except Exception as inner:
                logger.exception("Failed to expire booking id=%s: %s", getattr(booking, "id", None), str(inner))
                db.rollback()
                continue

        db.commit()
        logger.info("Expired %d pending bookings older than %d hours", expired_count, expiry_hours)
        return {"expired": expired_count, "cutoff": cutoff.isoformat()}

    except Exception as e:
        db.rollback()
        logger.exception("Error during expire_pending_bookings_once: %s", str(e))
        raise
    finally:
        db.close()


# Scheduler control API
_scheduler: BackgroundScheduler | None = None


def start_scheduler(interval_seconds: int = DEFAULT_RUN_INTERVAL_SECONDS, expiry_hours: int = DEFAULT_EXPIRY_HOURS):
    """
    Start the background scheduler (idempotent).
    It will run expire_pending_bookings_once every `interval_seconds`.
    """
    global _scheduler
    if _scheduler and _scheduler.running:
        logger.info("Scheduler already running")
        return _scheduler

    _scheduler = BackgroundScheduler()
    trigger = IntervalTrigger(seconds=interval_seconds)
    _scheduler.add_job(
        expire_pending_bookings_once,
        trigger,
        args=(expiry_hours,),
        id="expire_pending_bookings_job",
        replace_existing=True,
        max_instances=1,
    )

    _scheduler.start()
    logger.info("Scheduler started: interval_seconds=%s expiry_hours=%s", interval_seconds, expiry_hours)
    return _scheduler


def stop_scheduler():
    global _scheduler
    if _scheduler:
        _scheduler.shutdown(wait=False)
        logger.info("Scheduler stopped")
        _scheduler = None


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\search_service.py ---
from sqlalchemy.orm import Session
from sqlalchemy import text, and_, or_
from typing import List, Tuple
from app.schemas.search import HostelSearchFilters, HostelSearchSort, HostelSearchResult
import math

class SearchService:
    
    @staticmethod
    def search_hostels(db: Session, filters: HostelSearchFilters, 
                      sort: HostelSearchSort, page: int, page_size: int) -> Tuple[List[dict], int]:
        """Search hostels with filters and sorting"""
        
        # Use current schema: hostels has `hostel_name`, `full_address`, `total_beds`, `current_occupancy`,
        # and `location_id` referencing `locations.city`. There is no `name`, `location` or `is_active`.
        base_query = """
            SELECT h.id, h.hostel_name, h.description, h.full_address, l.city as city,
                   h.total_beds, h.current_occupancy, h.monthly_revenue, h.visibility,
                   h.contact_phone, h.contact_email, h.amenities, h.created_at
            FROM hostels h
            LEFT JOIN locations l ON l.id = h.location_id
            WHERE h.visibility = 'public'
        """
        
        params = {}
        
        # Apply filters
        conditions = []
        
        if filters.city:
            # city lives on the locations table
            conditions.append("LOWER(l.city) = LOWER(:city)")
            params['city'] = filters.city
        
        # area/pincode/gender/price/rating/geo are not present in current schema; apply what we can
        if filters.area:
            # no area column available — ignore or match against full_address
            conditions.append("LOWER(h.full_address) LIKE LOWER(:area)")
            params['area'] = f"%{filters.area}%"

        if filters.pincode:
            conditions.append("h.full_address LIKE :pincode")
            params['pincode'] = f"%{filters.pincode}%"

        if filters.gender:
            # no gender column defined on hostels; ignore filter
            pass

        if filters.min_price or filters.max_price:
            # price fields are not present; ignore price filtering
            pass

        if filters.min_rating:
            # rating is not present in current schema; ignore
            pass

        if filters.available_only:
            # available if total_beds > current_occupancy
            conditions.append("(h.total_beds IS NOT NULL AND COALESCE(h.current_occupancy, 0) < h.total_beds)")

        if filters.query:
            conditions.append(
                "(LOWER(h.hostel_name) LIKE LOWER(:query) OR LOWER(h.description) LIKE LOWER(:query) OR LOWER(h.full_address) LIKE LOWER(:query))"
            )
            params['query'] = f"%{filters.query}%"

        if filters.amenities:
            # amenities stored as TEXT; check substring match for each amenity
            for i, amenity in enumerate(filters.amenities):
                conditions.append(f"LOWER(h.amenities) LIKE LOWER(:amenity_{i})")
                params[f'amenity_{i}'] = f"%{amenity}%"
        
        if conditions:
            base_query += " AND " + " AND ".join(conditions)

        # Sorting - limited options supported on current schema
        order_by = {
            'newest': 'h.created_at DESC',
            'distance': 'h.id ASC',
            'rating': 'h.id ASC'
        }
        sort_clause = order_by.get(sort.sort_by, 'h.created_at DESC')

        # Wrap with simple query and pagination
        query = f"""
            {base_query}
            ORDER BY {sort_clause}
            LIMIT :limit OFFSET :offset
        """

        # Count query
        count_query = f"SELECT COUNT(*) FROM ({base_query}) as sub"

        total_count = db.execute(text(count_query), params).scalar() or 0

        # Pagination
        offset = (page - 1) * page_size
        params['limit'] = page_size
        params['offset'] = offset

        # Execute query and map rows to expected result keys
        result = db.execute(text(query), params)
        hostels = []
        for row in result.fetchall():
            r = row._mapping
            total_beds = r.get('total_beds') or 0
            current_occupancy = r.get('current_occupancy') or 0
            available_beds = max(total_beds - current_occupancy, 0)
            amenities_raw = r.get('amenities') or ''
            amenities_list = [a.strip() for a in amenities_raw.split(',')] if isinstance(amenities_raw, str) and amenities_raw else []

            hostels.append({
                'id': r.get('id'),
                'name': r.get('hostel_name'),
                'description': r.get('description'),
                'location': r.get('full_address'),
                'city': r.get('city'),
                'area': None,
                'pincode': None,
                'latitude': None,
                'longitude': None,
                'gender': None,
                'contact_phone': r.get('contact_phone'),
                'contact_email': r.get('contact_email'),
                'available_beds': available_beds,
                'total_beds': total_beds,
                'price_range_min': None,
                'price_range_max': None,
                'rating': 0.0,
                'review_count': 0,
                'amenities': amenities_list,
                'photos': [],
                'distance_km': None
            })

        return hostels, int(total_count)
    
    @staticmethod
    def log_search(db: Session, filters: HostelSearchFilters, results_count: int):
        """Log search query for analytics"""
        from app.models.reports import SearchQuery
        import json
        from decimal import Decimal
        
        # Convert Decimal to float for JSON serialization
        filters_dict = filters.model_dump(exclude_none=True)
        for key, value in filters_dict.items():
            if isinstance(value, Decimal):
                filters_dict[key] = float(value)
        
        search_log = SearchQuery(
            query_text=filters.query or "",
            city=filters.city,
            filters=json.dumps(filters_dict),
            results_count=results_count
        )
        db.add(search_log)
        db.commit()
    
    @staticmethod
    def log_profile_view(db: Session, hostel_id: int, source: str = "direct", visitor_ip: str = None, session_id: str = None):
        """Log hostel profile view for analytics"""
        from app.models.reports import HostelProfileView
        
        view = HostelProfileView(
            hostel_id=hostel_id,
            source=source,
            visitor_ip=visitor_ip,
            session_id=session_id
        )
        db.add(view)
        db.commit()

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\session_service.py ---
"""
Session context (active hostel)
"""
from sqlalchemy.orm import Session
from typing import Optional, List
from fastapi import HTTPException, status

from app.repositories.session_repository import SessionRepository
from app.repositories.hostel_repository import HostelRepository
from app.services.tenant_service import TenantService
from app.schemas.session import SwitchSessionRequest, SessionContextResponse
from app.core.roles import Role


class SessionService:
    def __init__(self, db: Session):
        self.db = db
        self.session_repo = SessionRepository(db)
        self.hostel_repo = HostelRepository(db)
        self.tenant_service = TenantService(db)
    
    def switch_session(self, user_id: int, user_role: str, request: SwitchSessionRequest) -> SessionContextResponse:
        """Switch active hostel session"""
        # Validate hostel access
        self.tenant_service.validate_hostel_access(user_id, user_role, request.hostel_id)
        
        # Create/activate session
        session = self.session_repo.create_session(user_id, request.hostel_id)
        
        return SessionContextResponse(
            id=session.id,
            user_id=session.user_id,
            hostel_id=session.hostel_id,
            is_active=session.is_active,
            created_at=session.created_at,
            updated_at=session.updated_at
        )
    
    def get_active_session(self, user_id: int) -> Optional[SessionContextResponse]:
        """Get active session for user"""
        session = self.session_repo.get_active_session(user_id)
        if not session:
            return None
        
        return SessionContextResponse(
            id=session.id,
            user_id=session.user_id,
            hostel_id=session.hostel_id,
            is_active=session.is_active,
            created_at=session.created_at,
            updated_at=session.updated_at
        )
    
    def get_recent_sessions(self, user_id: int, limit: int = 5) -> List[SessionContextResponse]:
        """Get recently accessed hostels"""
        sessions = self.session_repo.get_all_sessions(user_id)
        recent = sessions[:limit]
        
        return [
            SessionContextResponse(
                id=s.id,
                user_id=s.user_id,
                hostel_id=s.hostel_id,
                is_active=s.is_active,
                created_at=s.created_at,
                updated_at=s.updated_at
            )
            for s in recent
        ]
    
    def deactivate_session(self, user_id: int, session_id: int) -> bool:
        """Deactivate a session"""
        return self.session_repo.deactivate_session(user_id, session_id)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\shift_coordination_service.py ---
from sqlalchemy.orm import Session
import app.repositories.shift_coordination_repositories as repo

from app.schemas.shift_coordination_schemas import (
    ShiftCreate, ShiftScheduleCreate, TaskCreate, TaskUpdate,
    TaskDelegationCreate, HandoverCreate, HandoverItemCreate, CoordinationMeetingCreate
)


# ================== SHIFT ===================
def create_shift_service(db: Session, shift_data: ShiftCreate):
    return repo.create_shift(db, shift_data)


def get_shifts_service(db: Session):
    return repo.get_all_shifts(db)


# ================== SCHEDULE ===================
def create_shift_schedule_service(db: Session, schedule_data: ShiftScheduleCreate):
    return repo.create_shift_schedule(db, schedule_data)


# ================== TASK ===================
def create_task_service(db: Session, task_data: TaskCreate):
    return repo.create_task(db, task_data)


def update_task_service(db: Session, task_id: int, update_data: TaskUpdate):
    return repo.update_task(db, task_id, update_data)


# ================== DELEGATION ===================
def delegate_task_service(db: Session, delegation_data: TaskDelegationCreate):
    return repo.create_task_delegation(db, delegation_data)


# ================== HANDOVER ===================
def create_handover_service(db: Session, handover_data: HandoverCreate):
    return repo.create_handover(db, handover_data)


def add_handover_item_service(db: Session, item_data: HandoverItemCreate):
    return repo.create_handover_item(db, item_data)


# ================== COORDINATION MEETING ===================
def create_meeting_service(db: Session, meeting_data: CoordinationMeetingCreate):
    return repo.create_coordination_meeting(db, meeting_data)


def get_meetings_by_hostel_service(db: Session, hostel_id: int):
    return repo.get_meetings_by_hostel(db, hostel_id)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\sms_service.py ---
"""
SMS service for sending OTP and notifications via Twilio
"""
from typing import Optional
import logging

from app.config import settings

logger = logging.getLogger(__name__)

# Try to import Twilio, but make it optional
try:
    from twilio.rest import Client
    TWILIO_AVAILABLE = True
except ImportError:
    TWILIO_AVAILABLE = False
    logger.warning("Twilio not installed. Install with: pip install twilio")


class SMSService:
    """SMS service for sending SMS via Twilio"""
    
    def __init__(self):
        self.account_sid = settings.TWILIO_ACCOUNT_SID
        self.auth_token = settings.TWILIO_AUTH_TOKEN
        # support both TWILIO_FROM_NUMBER (current) and legacy TWILIO_PHONE_NUMBER
        self.phone_number = getattr(settings, 'TWILIO_FROM_NUMBER', None) or getattr(settings, 'TWILIO_PHONE_NUMBER', None)
        self.client = None
        
        if TWILIO_AVAILABLE and self.is_configured():
            try:
                self.client = Client(self.account_sid, self.auth_token)
            except Exception as e:
                logger.error(f"Error initializing Twilio client: {str(e)}")
    
    def is_configured(self) -> bool:
        """Check if SMS service is configured"""
        return all([
            self.account_sid,
            self.auth_token,
            self.phone_number
        ])
    
    def send_sms(self, to_phone: str, message: str) -> bool:
        """Send SMS via Twilio"""
        if not TWILIO_AVAILABLE:
            logger.warning("Twilio not installed. SMS not sent.")
            if settings.DEBUG:
                logger.info(f"Would send SMS to {to_phone}: {message}")
            return False
        
        if not self.is_configured():
            logger.warning("SMS service not configured. SMS not sent.")
            if settings.DEBUG:
                logger.info(f"Would send SMS to {to_phone}: {message}")
            return False
        
        try:
            # Format phone number (ensure it starts with +)
            if not to_phone.startswith('+'):
                to_phone = f"+{to_phone.lstrip('+')}"
            
            # Send SMS
            message_obj = self.client.messages.create(
                body=message,
                from_=self.phone_number,
                to=to_phone
            )
            
            logger.info(f"SMS sent successfully to {to_phone}. SID: {message_obj.sid}")
            return True
            
        except Exception as e:
            logger.error(f"Error sending SMS to {to_phone}: {str(e)}")
            if settings.DEBUG:
                logger.exception("SMS sending error details:")
            return False
    
    def send_otp_sms(self, to_phone: str, otp_code: str, otp_type: str = "registration") -> bool:
        """Send OTP via SMS"""
        # OTP delivery has been disabled by administrator request.
        logger.info(f"OTP delivery disabled: would have sent SMS to {to_phone} (type={otp_type})")
        if settings.DEBUG:
            logger.debug(f"OTP code for {to_phone}: {otp_code}")
        return False
    
    def send_password_reset_sms(self, to_phone: str, reset_code: str) -> bool:
        """Send password reset code via SMS"""
        message = f"Your {settings.APP_NAME} password reset code is: {reset_code}. Valid for {settings.PASSWORD_RESET_TOKEN_EXPIRY_MINUTES} minutes. Do not share this code."
        return self.send_sms(to_phone, message)



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\student_service.py ---
from typing import List, Optional
from datetime import date, datetime, time as time_type
from sqlalchemy.orm import Session
from app.repositories.student_repository import (
    list_students as repo_list_students,
    get_student as repo_get_student,
    create_student as repo_create_student,
    update_student as repo_update_student,
    delete_student as repo_delete_student,
    set_status as repo_set_status,
    transfer as repo_transfer,
    list_history as repo_list_history,
    create_payment as repo_create_payment,
    list_payments as repo_list_payments,
    create_attendance as repo_create_attendance,
    list_attendance as repo_list_attendance,
    create_student_document as repo_create_student_document,
    list_student_documents as repo_list_student_documents,
)
from app.schemas.students import (
    StudentCreate,
    StudentOut,
    StudentUpdate,
    StudentDocumentCreate,
    StudentDocumentOut,
    PaymentOut,
    PaymentCreate,
    AttendanceOut,
    AttendanceCreate,
)
from app.models.students import PaymentType, PaymentMethod, AttendanceMode


# ---- Student CRUD / status / transfer ----

def list_students(
    db: Session,
    skip: int = 0,
    limit: int = 100,
    name: Optional[str] = None,
    room: Optional[str] = None,
    payment_status: Optional[str] = None,
    attendance_status: Optional[str] = None,
) -> List:
    return repo_list_students(
        db,
        skip=skip,
        limit=limit,
        name=name,
        room=room,
        payment_status=payment_status,
        attendance_status=attendance_status,
    )


def get_student(db: Session, student_id: str):
    return repo_get_student(db, student_id)


def create_student(db: Session, student_in: StudentCreate):
    return repo_create_student(db, student_in)


def update_student(db: Session, student_id: str, student_in: StudentUpdate):
    return repo_update_student(db, student_id, student_in)


def delete_student(db: Session, student_id: str) -> bool:
    return repo_delete_student(db, student_id)


def set_student_status(db: Session, student_id: str, new_status: str, notes: Optional[str] = None):
    return repo_set_status(db, student_id, new_status, notes)


def transfer_student(db: Session, student_id: str, new_room: Optional[str], new_bed: Optional[str], notes: Optional[str] = None):
    return repo_transfer(db, student_id, new_room, new_bed, notes)


def get_student_history(db: Session, student_id: str) -> List[dict]:
    return repo_list_history(db, student_id)


# ---- Payments / mapper ----

def _payment_to_payment_out(db: Session, payment) -> PaymentOut:
    """
    Normalize Payment model -> PaymentOut (resolving student name and enums).
    Falls back to reasonable defaults when fields missing.
    """
    student = repo_get_student(db, payment.student_id)
    student_name = student.student_name if student else ""

    # Convert or fallback payment_type / method to enums expected by Pydantic
    payment_type = PaymentType.OTHER
    if payment.payment_type:
        try:
            payment_type = PaymentType(payment.payment_type) if not isinstance(payment.payment_type, PaymentType) else payment.payment_type
        except Exception:
            payment_type = PaymentType.OTHER

    payment_method = PaymentMethod.OTHER
    if payment.payment_method:
        try:
            payment_method = PaymentMethod(payment.payment_method) if not isinstance(payment.payment_method, PaymentMethod) else payment.payment_method
        except Exception:
            payment_method = PaymentMethod.OTHER

    # Determine payment_date
    pay_date = payment.payment_date
    if not pay_date and getattr(payment, "paid_at", None):
        pay_date = payment.paid_at.date()

    # fallback to today if absolutely missing
    if not pay_date:
        pay_date = date.today()

    return PaymentOut(
        id=payment.id,
        student_id=payment.student_id,
        student_name=student_name,
        payment_type=payment_type,
        amount=payment.amount,
        payment_method=payment_method,
        payment_date=pay_date,
        due_date=payment.due_date or pay_date,
        transaction_id=payment.transaction_id or "",
        status=payment.status,
        notes=payment.notes,
        created_at=payment.created_at,
    )


def create_payment(db: Session, student_id: str, payload: PaymentCreate) -> PaymentOut:
    payment = repo_create_payment(
        db=db,
        student_id=student_id,
        payment_type=payload.payment_type.value if payload.payment_type else None,
        amount=payload.amount,
        payment_method=payload.payment_method.value if payload.payment_method else None,
        payment_date=payload.payment_date,
        due_date=payload.due_date,
        transaction_id=payload.transaction_id,
        status=payload.status,
        notes=payload.notes,
    )
    return _payment_to_payment_out(db, payment)


def list_payments(db: Session, student_id: str) -> List[PaymentOut]:
    payments = repo_list_payments(db, student_id)
    return [_payment_to_payment_out(db, p) for p in payments]


# ---- Attendance / mapper ----

def _attendance_to_attendance_out(db: Session, attendance) -> AttendanceOut:
    student = repo_get_student(db, attendance.student_id)
    student_name = student.student_name if student else ""

    attendance_mode = AttendanceMode.IN_PERSON
    if attendance.attendance_mode:
        try:
            attendance_mode = AttendanceMode(attendance.attendance_mode) if not isinstance(attendance.attendance_mode, AttendanceMode) else attendance.attendance_mode
        except Exception:
            attendance_mode = AttendanceMode.IN_PERSON

    attendance_date = attendance.attendance_date or getattr(attendance, "date", None)
    if not attendance_date:
        from datetime import date
        attendance_date = date.today()

    check_in_time = attendance.check_in_time or time_type(9, 0)
    check_out_time = attendance.check_out_time or time_type(17, 0)

    return AttendanceOut(
        id=attendance.id,
        student_id=attendance.student_id,
        student_name=student_name,
        attendance_date=attendance_date,
        attendance_mode=attendance_mode,
        check_in_time=check_in_time,
        check_out_time=check_out_time,
        is_late=attendance.is_late if attendance.is_late is not None else False,
        status=attendance.status,
        notes=attendance.notes,
        created_at=attendance.created_at,
    )


def create_attendance(db: Session, student_id: str, payload: AttendanceCreate) -> AttendanceOut:
    attendance = repo_create_attendance(
        db=db,
        student_id=student_id,
        attendance_date=payload.attendance_date,
        attendance_mode=payload.attendance_mode.value if payload.attendance_mode else None,
        check_in_time=payload.check_in_time,
        check_out_time=payload.check_out_time,
        is_late=payload.is_late,
        status=payload.status,
        notes=payload.notes,
    )
    return _attendance_to_attendance_out(db, attendance)


def list_attendance(db: Session, student_id: str) -> List[AttendanceOut]:
    attendances = repo_list_attendance(db, student_id)
    return [_attendance_to_attendance_out(db, a) for a in attendances]


# ---- Student Documents ----

def create_student_document(db: Session, student_id: str, payload: StudentDocumentCreate):
    return repo_create_student_document(db, student_id, payload.doc_type, payload.doc_url)


def list_student_documents(db: Session, student_id: str):
    return repo_list_student_documents(db, student_id)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\subscription_service.py ---
from sqlalchemy.orm import Session
from app import schemas, repositories
from datetime import datetime


def create_plan_service(db: Session, plan: schemas.SubscriptionPlanCreate):
    return repositories.subscription_repository.create_plan(db, plan)


def list_plans_service(db: Session):
    return repositories.subscription_repository.get_all_plans(db)


def create_subscription_service(db: Session, subscription: schemas.SubscriptionCreate):
    existing = repositories.subscription_repository.get_subscription_by_org(db, subscription.organization_id)
    if existing:
        raise ValueError("Organization already has an active subscription")
    return repositories.subscription_repository.create_subscription(db, subscription)


def list_subscriptions_service(db: Session):
    return repositories.subscription_repository.list_subscriptions(db)


def create_payment_service(db: Session, payment: schemas.PaymentCreate):
    # stamp when payment was created/recorded
    payment.paid_at = datetime.utcnow()

    # Ensure the subscription exists. callers may pass either a subscription.id
    # or an organization_id (legacy/tests). Try subscription id first, then
    # fall back to organization lookup and map to the real subscription id.
    sub = repositories.subscription_repository.get_subscription_by_id(db, payment.subscription_id)
    if not sub:
        sub = repositories.subscription_repository.get_subscription_by_org(db, payment.subscription_id)
        if sub:
            # mutate schema value so repository will use the correct fk
            payment.subscription_id = sub.id
        else:
            raise ValueError(f"Subscription not found for id or organization_id: {payment.subscription_id}")

    return repositories.subscription_repository.create_payment(db, payment)


def list_payments_service(db: Session, subscription_id: str = None):
    return repositories.subscription_repository.list_payments(db, subscription_id)


def create_change_service(db: Session, change: schemas.SubscriptionChangeCreate):
    return repositories.subscription_repository.create_change(db, change)


def list_changes_service(db: Session, subscription_id: str):
    return repositories.subscription_repository.list_changes(db, subscription_id)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\supervisor_service.py ---
from typing import List, Optional
from sqlalchemy.orm import Session

from app.repositories.supervisor_repository import (
    create_supervisor as repo_create_supervisor,
    get_supervisor as repo_get_supervisor,
    list_supervisors as repo_list_supervisors,
    update_supervisor as repo_update_supervisor,
    delete_supervisor as repo_delete_supervisor,
    assign_hostel as repo_assign_hostel,
    list_hostels as repo_list_hostels,
    list_activity as repo_list_activity,
    create_admin_override as repo_create_admin_override,
    admin_override_assign_supervisor_hostel as repo_admin_override_assign_supervisor_hostel,
)
from app.schemas.supervisors import SupervisorCreate, SupervisorUpdate
from app.models.supervisors import Supervisor, AdminOverride


def create_supervisor(db: Session, sup_in: SupervisorCreate) -> Supervisor:
    return repo_create_supervisor(db, sup_in)


def get_supervisor(db: Session, employee_id: str) -> Optional[Supervisor]:
    return repo_get_supervisor(db, employee_id)


def list_supervisors(db: Session, skip: int = 0, limit: int = 100, name: Optional[str] = None, role: Optional[str] = None, department: Optional[str] = None) -> List[Supervisor]:
    return repo_list_supervisors(db, skip=skip, limit=limit, name=name, role=role, department=department)


def update_supervisor(db: Session, employee_id: str, sup_in: SupervisorUpdate) -> Optional[Supervisor]:
    return repo_update_supervisor(db, employee_id, sup_in)


def delete_supervisor(db: Session, employee_id: str) -> bool:
    return repo_delete_supervisor(db, employee_id)


def assign_supervisor_hostel(db: Session, employee_id: str, hostel_id: str) -> None:
    return repo_assign_hostel(db, employee_id, hostel_id)


def list_supervisor_hostels(db: Session, employee_id: str) -> List[dict]:
    return repo_list_hostels(db, employee_id)


def list_supervisor_activity(db: Session, employee_id: str) -> List[dict]:
    return repo_list_activity(db, employee_id)


# Admin overrides
def create_admin_override(db: Session, admin_employee_id: str, target_supervisor_id: Optional[str], action: str, details: Optional[str]) -> AdminOverride:
    return repo_create_admin_override(db, admin_employee_id, target_supervisor_id, action, details)


def override_assign_supervisor_hostel(db: Session, admin_employee_id: str, target_supervisor_id: str, new_hostel_id: str) -> None:
    return repo_admin_override_assign_supervisor_hostel(db, admin_employee_id, target_supervisor_id, new_hostel_id)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\super_admin_service.py ---
from sqlalchemy.orm import Session
from app.repositories.hostel_repository import HostelRepository
from app.schemas.super_admin_schemas import HostelUpsert
from typing import List, Dict, Any, Optional
from fastapi import HTTPException, status

class HostelService:
    @staticmethod
    def upsert_hostel(db: Session, hostel_data: HostelUpsert) -> Dict[str, Any]:
        repo = HostelRepository(db)
        try:
            return repo.upsert_hostel(hostel_data)
        except ValueError as e:
            # Translate repository integrity errors into HTTP 400 responses
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

    @staticmethod
    def get_all_hostels(db: Session, skip: int = 0, limit: int = 100):
        repo = HostelRepository(db)
        return repo.get_all_hostels(skip, limit)

    @staticmethod
    def get_total_hostels_count(db: Session) -> int:
        repo = HostelRepository(db)
        return repo.get_total_hostels_count()

    @staticmethod
    def get_hostel_by_id(db: Session, hostel_id: int):
        repo = HostelRepository(db)
        return repo.get_hostel_by_id(hostel_id)

    @staticmethod
    def delete_hostel(db: Session, hostel_id: int):
        repo = HostelRepository(db)
        return repo.delete_hostel(hostel_id)

    @staticmethod
    def search_hostels(db: Session, search_term: str, skip: int = 0, limit: int = 100):
        repo = HostelRepository(db)
        return repo.search_hostels(search_term, skip, limit)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\tenant_service.py ---
"""
Multi-hostel admin validation
"""
from sqlalchemy.orm import Session
from typing import List, Optional
from fastapi import HTTPException, status

from app.core.roles import Role
from app.repositories.hostel_repository import HostelRepository
from app.repositories.user_repository import UserRepository
from app.core.exceptions import InvalidHostelException


class TenantService:
    def __init__(self, db: Session):
        self.db = db
        self.hostel_repo = HostelRepository(db)
        self.user_repo = UserRepository(db)
    
    def validate_hostel_access(self, user_id: int, user_role: str, hostel_id: int) -> bool:
        """Validate if user has access to a hostel"""
        # Superadmin has access to all hostels
        if user_role == Role.SUPERADMIN:
            return True
        
        # Check if hostel exists
        hostel = self.hostel_repo.get_by_id(hostel_id)
        if not hostel:
            raise InvalidHostelException("Hostel not found")
        
        # For admin, check if assigned to hostel
        if user_role == Role.ADMIN:
            admin_hostels = self.hostel_repo.get_by_admin(user_id)
            hostel_ids = [h.id for h in admin_hostels]
            if hostel_id not in hostel_ids:
                raise InvalidHostelException("Admin not assigned to this hostel")
            return True
        
        # For other roles, check if user's hostel_id matches
        user = self.user_repo.get_by_id(user_id)
        if user and user.hostel_id == hostel_id:
            return True
        
        raise InvalidHostelException("User does not have access to this hostel")
    
    def get_user_hostels(self, user_id: int, user_role: str) -> List[dict]:
        """Get list of hostels user has access to"""
        if user_role == Role.SUPERADMIN:
            # Superadmin sees all hostels
            hostels = self.hostel_repo.get_all()
            return [{"id": h.id, "name": h.name, "address": h.address} for h in hostels]
        elif user_role == Role.ADMIN:
            # Admin sees assigned hostels
            hostels = self.hostel_repo.get_by_admin(user_id)
            return [{"id": h.id, "name": h.name, "address": h.address} for h in hostels]
        else:
            # Other roles see only their hostel
            user = self.user_repo.get_by_id(user_id)
            if user and user.hostel_id:
                hostel = self.hostel_repo.get_by_id(user.hostel_id)
                if hostel:
                    return [{"id": hostel.id, "name": hostel.name, "address": hostel.address}]
            return []
    
    def assign_admin_to_hostel(self, admin_id: int, hostel_id: int, assigner_role: str) -> dict:
        """Assign admin to hostel"""
        if assigner_role != Role.SUPERADMIN:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Only superadmin can assign admins to hostels"
            )
        
        # Verify admin exists and is admin role
        admin = self.user_repo.get_by_id(admin_id)
        if not admin:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Admin not found")
        if admin.role != Role.ADMIN:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User is not an admin")
        
        # Verify hostel exists
        hostel = self.hostel_repo.get_by_id(hostel_id)
        if not hostel:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Hostel not found")
        
        # Assign
        mapping = self.hostel_repo.assign_admin(admin_id, hostel_id)
        return {
            "admin_id": mapping.admin_id,
            "hostel_id": mapping.hostel_id,
            "message": "Admin assigned to hostel successfully"
        }

    def assign_admin_to_hostels(self, admin_id: int, hostel_ids: List[int], assigner_role: str) -> dict:
        """Assign admin to multiple hostels (idempotent)

        Returns a summary with created and existing mappings.
        """
        if assigner_role != Role.SUPERADMIN:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Only superadmin can assign admins to hostels"
            )

        admin = self.user_repo.get_by_id(admin_id)
        if not admin:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Admin not found")
        if admin.role != Role.ADMIN:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User is not an admin")

        created = []
        existing = []
        for hid in hostel_ids:
            hostel = self.hostel_repo.get_by_id(hid)
            if not hostel:
                # skip non-existent hostel ids
                continue
            # perform idempotent assignment
            self.hostel_repo.assign_admin(admin_id, hid)

        # After assignments, return the actual hostels assigned to the admin from the DB
        assigned_hostels = self.hostel_repo.get_by_admin(admin_id)
        assigned = [{"id": h.id, "name": h.name, "address": h.address} for h in assigned_hostels]

        return {
            "admin_id": admin_id,
            "assigned_hostels": assigned,
            "message": f"Assigned admin to {len(assigned)} hostels (idempotent)."
        }



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\visitor_service.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\waitlist_service.py ---
# app/services/waitlist_service.py

from sqlalchemy.orm import Session
from datetime import datetime

from app.models.waitlist import Waitlist
from app.models.rooms import Room
from app.models.booking import Booking, BookingStatus
from app.repositories.booking_repository import BookingRepository
from app.services.booking_lock_service import BookingLockService


class WaitlistService:
    """
    Simple waitlist service:
    - add_to_waitlist: add visitor entry
    - get_for_hostel: list entries for hostel (ordered by priority & created_at)
    - try_promote: attempt to allocate a room and convert top waitlist entry into a booking
    """

    @staticmethod
    def add_to_waitlist(db: Session, hostel_id: int, room_type: str, visitor_id: int, priority: int = 1) -> Waitlist:
        entry = Waitlist(
            hostel_id=hostel_id,
            room_type=room_type,
            visitor_id=visitor_id,
            priority=priority,
            created_at=datetime.utcnow()
        )
        db.add(entry)
        db.commit()
        db.refresh(entry)
        return entry

    @staticmethod
    def get_for_hostel(db: Session, hostel_id: int, room_type: str | None = None):
        q = db.query(Waitlist).filter(Waitlist.hostel_id == hostel_id)
        if room_type:
            q = q.filter(Waitlist.room_type == room_type)
        # priority asc (1 = high), then older first
        return q.order_by(Waitlist.priority.asc(), Waitlist.created_at.asc()).all()

    @staticmethod
    def try_promote(db: Session, hostel_id: int, room_type: str | None = None):
        """
        Try to promote the highest-priority waitlist entry into an actual booking.
        Returns (booking, waitlist_entry) on success, or (None, None) on no-op.
        NOTE:
        - Uses SELECT FOR UPDATE on candidate room to avoid races.
        - Finds any room of requested type in the hostel with available_beds > 0.
        - If found, creates a confirmed booking (amount_paid=0) and removes waitlist entry.
        - Payment/notification logic should be added later.
        """

        # fetch first waitlist entry matching criteria
        q = db.query(Waitlist).filter(Waitlist.hostel_id == hostel_id)
        if room_type:
            q = q.filter(Waitlist.room_type == room_type)

        entry = q.order_by(Waitlist.priority.asc(), Waitlist.created_at.asc()).with_for_update().first()
        if not entry:
            return None, None

        # find any room with available_beds > 0 (we will lock the specific room row)
        rooms = db.query(Room).filter(Room.hostel_id == hostel_id, Room.room_type == entry.room_type, Room.available_beds > 0).all()
        if not rooms:
            # no available room now
            return None, entry

        # pick first candidate room and attempt to lock it
        for r in rooms:
            locked_room = BookingLockService.lock_room(db, r.id)
            if not locked_room:
                # if locked by another tx, try next room
                continue

            # double-check available_beds after locking
            if locked_room.available_beds <= 0:
                # release lock by committing/rolling back (we just continue)
                db.rollback()
                continue

            # create booking object (confirmed). If you prefer pending, change status.
            booking = Booking(
                visitor_id=entry.visitor_id,
                hostel_id=entry.hostel_id,
                room_id=locked_room.id,
                check_in=datetime.utcnow(),           # placeholder; system can set proper dates later
                check_out=datetime.utcnow(),          # placeholder; adapt as needed
                amount_paid=0.0,
                status=BookingStatus.confirmed,
                created_at=datetime.utcnow()
            )

            try:
                db.add(booking)

                # decrement available beds
                locked_room.available_beds = locked_room.available_beds - 1

                # delete waitlist entry
                db.delete(entry)

                db.commit()
                db.refresh(booking)
                return booking, entry

            except Exception:
                db.rollback()
                # release lock implicitly and try next room
                continue

        # no room could be locked/used
        return None, entry

    # -----------------------------------------------------------
    # ⭐ NEW — Get a single waitlist entry by ID
    # -----------------------------------------------------------
    @staticmethod
    def get_by_id(db: Session, waitlist_id: int):
        return db.query(Waitlist).filter(Waitlist.id == waitlist_id).first()

    # -----------------------------------------------------------
    # ⭐ NEW — Remove a waitlist entry (used by router)
    # -----------------------------------------------------------
    @staticmethod
    def remove(db: Session, waitlist_id: int):
        wl = db.query(Waitlist).filter(Waitlist.id == waitlist_id).first()
        if not wl:
            return False
        db.delete(wl)
        db.commit()
        return True

    # -----------------------------------------------------------
    # ⭐ NEW — Reorder waitlist priorities after deletion/promote
    # -----------------------------------------------------------
    @staticmethod
    def reorder_priorities(db: Session, hostel_id: int, room_type: str):
        entries = (
            db.query(Waitlist)
            .filter(Waitlist.hostel_id == hostel_id, Waitlist.room_type == room_type)
            .order_by(Waitlist.priority.asc(), Waitlist.created_at.asc())
            .all()
        )

        new_priority = 1
        for entry in entries:
            entry.priority = new_priority
            new_priority += 1

        db.commit()
        return True

    # -----------------------------------------------------------
    # ⭐ NEW — Admin Manual Promotion Helper
    # -----------------------------------------------------------
    @staticmethod
    def manual_promote(db: Session, entry: Waitlist):
        """
        Router handles promotion logic; service provides shared helper.
        """
        return entry  # simple placeholder, logic is in router

    # -----------------------------------------------------------
    # ⭐ NEW — Auto promotion hook for Booking cancellation
    # -----------------------------------------------------------
    @staticmethod
    def promote_after_cancellation(db: Session, hostel_id: int, room_type: str):
        """
        Called by BookingService.cancel_booking() to immediately fill freed beds.
        """
        booking, entry = WaitlistService.try_promote(db, hostel_id, room_type)
        return booking


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\__init__.py ---
# Re-export service modules for convenience
from . import subscription_service, admin_service, dashboard_service, super_admin_service

__all__ = [
    "subscription_service",
    "admin_service",
    "dashboard_service",
    "super_admin_service",
]



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\providers =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\providers\base_provider.py ---
from typing import Protocol, Optional, Dict, Any


class ProviderInterface(Protocol):
    """Protocol that all provider implementations must follow.

    Implementations must provide a `send` method that returns a dict
    containing at least `success` (bool) and `provider` (str).
    """

    def send(self, to: str, subject: str, body: str, extra: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        ...


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\providers\fcm_provider.py ---
import os
from typing import Optional, Dict, Any

try:
    import firebase_admin
    from firebase_admin import messaging, credentials
except Exception:
    firebase_admin = None

from app.services.providers.base_provider import ProviderInterface


class FCMProvider(ProviderInterface):
    def __init__(self, cred_json_path: Optional[str] = None):
        self.cred_json_path = cred_json_path or os.getenv("FCM_SERVICE_ACCOUNT_JSON")
        if firebase_admin and self.cred_json_path:
            try:
                cred = credentials.Certificate(self.cred_json_path)
                # initialize_app will raise if already initialized, so guard
                if not firebase_admin._apps:
                    firebase_admin.initialize_app(cred)
                self.available = True
            except Exception:
                self.available = False
        else:
            self.available = False

    def send(self, to: str, subject: str, body: str, extra: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        if not self.available:
            return {"success": False, "provider": "fcm", "response": "not_configured"}

        try:
            message = messaging.Message(
                notification=messaging.Notification(title=subject, body=body),
                token=to,
            )
            resp = messaging.send(message)
            return {"success": True, "provider": "fcm", "response": resp}
        except Exception as exc:
            return {"success": False, "provider": "fcm", "response": str(exc)}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\providers\sendgrid_provider.py ---
import os
from typing import Optional, Dict, Any

from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail

from app.services.providers.base_provider import ProviderInterface


class SendGridProvider(ProviderInterface):
    def __init__(self, api_key: Optional[str] = None, default_from: Optional[str] = None):
        self.api_key = api_key or os.getenv("SENDGRID_API_KEY")
        self.default_from = default_from or os.getenv("DEFAULT_FROM_EMAIL", "noreply@example.com")
        self.client = SendGridAPIClient(self.api_key) if self.api_key else None

    def send(self, to: str, subject: str, body: str, extra: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        if not self.client:
            return {"success": False, "provider": "sendgrid", "response": "missing_api_key"}

        message = Mail(from_email=self.default_from, to_emails=to, subject=subject, html_content=body)
        try:
            resp = self.client.send(message)
            status = getattr(resp, "status_code", None)
            body = getattr(resp, "body", None)
            success = status is not None and 200 <= int(status) < 300
            return {"success": success, "provider": "sendgrid", "response": f"{status}:{body}"}
        except Exception as exc:
            return {"success": False, "provider": "sendgrid", "response": str(exc)}


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\providers\twilio_provider.py ---
import os
from typing import Optional, Dict, Any

from twilio.rest import Client

from app.services.providers.base_provider import ProviderInterface


class TwilioProvider(ProviderInterface):
    def __init__(self, account_sid: Optional[str] = None, auth_token: Optional[str] = None, from_number: Optional[str] = None):
        self.account_sid = account_sid or os.getenv("TWILIO_ACCOUNT_SID")
        self.auth_token = auth_token or os.getenv("TWILIO_AUTH_TOKEN")
        self.from_number = from_number or os.getenv("TWILIO_PHONE_NUMBER")
        self.client = Client(self.account_sid, self.auth_token) if self.account_sid and self.auth_token else None

    def send(self, to: str, subject: str, body: str, extra: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        # Twilio SMS doesn't use subject — we include it in the body if present
        if not self.client:
            return {"success": False, "provider": "twilio", "response": "missing_credentials"}

        message_body = (subject + "\n" + body) if subject else body
        try:
            msg = self.client.messages.create(body=message_body, from_=self.from_number, to=to)
            return {"success": True, "provider": "twilio", "response": getattr(msg, "sid", str(msg))}
        except Exception as exc:
            return {"success": False, "provider": "twilio", "response": str(exc)}



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\providers\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\services\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tasks =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tasks\booking_tasks.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tasks\celery_app.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tasks\maintenance_tasks.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tasks\notification_tasks.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tasks\payment_tasks.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tasks\report_tasks.py ---
"""
Background tasks for report generation and scheduling
Using Celery for async task processing
"""

from celery import Celery
from datetime import date, datetime, timedelta
from typing import Optional
import os

from app.config import get_settings

settings = get_settings()

# Initialize Celery
celery_app = Celery(
    'hostel_analytics',
    broker='redis://localhost:6379/0',
    backend='redis://localhost:6379/0'
)

celery_app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,
)


@celery_app.task(name='generate_daily_report')
def generate_daily_report_task(hostel_id: int, report_date: str):
    """
    Generate daily report for a hostel
    """
    from app.core.database import SessionLocal
    from app.services.analytics_service import AnalyticsService
    
    db = SessionLocal()
    try:
        service = AnalyticsService(db)
        report_date_obj = datetime.strptime(report_date, '%Y-%m-%d').date()
        
        # Generate various reports
        attendance_report = service.get_attendance_report(
            report_date_obj, 
            report_date_obj, 
            hostel_id
        )
        
        complaint_report = service.get_complaint_report(
            report_date_obj,
            report_date_obj,
            hostel_id
        )
        
        # Store or send report
        print(f"Daily report generated for hostel {hostel_id} on {report_date}")
        
        return {
            "status": "success",
            "hostel_id": hostel_id,
            "date": report_date
        }
    finally:
        db.close()


@celery_app.task(name='generate_weekly_report')
def generate_weekly_report_task(hostel_id: int, week_start: str):
    """
    Generate weekly summary report
    """
    from app.core.database import SessionLocal
    from app.services.analytics_service import AnalyticsService
    
    db = SessionLocal()
    try:
        service = AnalyticsService(db)
        week_start_obj = datetime.strptime(week_start, '%Y-%m-%d').date()
        
        weekly_summary = service.get_weekly_summary(hostel_id, week_start_obj)
        
        print(f"Weekly report generated for hostel {hostel_id} starting {week_start}")
        
        return {
            "status": "success",
            "hostel_id": hostel_id,
            "week_start": week_start
        }
    finally:
        db.close()


@celery_app.task(name='generate_monthly_report')
def generate_monthly_report_task(hostel_id: int, month: int, year: int):
    """
    Generate monthly performance report
    """
    from app.core.database import SessionLocal
    from app.services.analytics_service import AnalyticsService
    from calendar import monthrange
    
    db = SessionLocal()
    try:
        service = AnalyticsService(db)
        
        # Get date range for the month
        days_in_month = monthrange(year, month)[1]
        start_date = date(year, month, 1)
        end_date = date(year, month, days_in_month)
        
        # Generate comprehensive reports
        revenue_report = service.get_revenue_report(start_date, end_date, hostel_id)
        occupancy_report = service.get_occupancy_report(start_date, end_date, hostel_id)
        financial_summary = service.get_financial_summary(start_date, end_date, hostel_id)
        
        print(f"Monthly report generated for hostel {hostel_id} for {year}-{month}")
        
        return {
            "status": "success",
            "hostel_id": hostel_id,
            "month": month,
            "year": year
        }
    finally:
        db.close()


@celery_app.task(name='generate_super_admin_report')
def generate_super_admin_report_task(start_date: str, end_date: str):
    """
    Generate comprehensive report for super admin across all hostels
    """
    from app.core.database import SessionLocal
    from app.services.analytics_service import AnalyticsService
    
    db = SessionLocal()
    try:
        service = AnalyticsService(db)
        start_date_obj = datetime.strptime(start_date, '%Y-%m-%d').date()
        end_date_obj = datetime.strptime(end_date, '%Y-%m-%d').date()
        
        # Generate multi-hostel comparison
        comparison = service.get_multi_hostel_comparison(start_date_obj, end_date_obj)
        
        print(f"Super admin report generated for {start_date} to {end_date}")
        
        return {
            "status": "success",
            "start_date": start_date,
            "end_date": end_date
        }
    finally:
        db.close()


@celery_app.task(name='cleanup_old_reports')
def cleanup_old_reports_task():
    """
    Clean up old reports based on retention policy
    """
    from app.core.database import SessionLocal
    from app.models import DailyReport
    
    db = SessionLocal()
    try:
        # Delete reports older than MAX_REPORT_AGE_DAYS
        cutoff_date = date.today() - timedelta(days=settings.MAX_REPORT_AGE_DAYS)
        
        deleted_count = db.query(DailyReport).filter(
            DailyReport.report_date < cutoff_date
        ).delete()
        
        db.commit()
        
        print(f"Cleaned up {deleted_count} old reports")
        
        return {
            "status": "success",
            "deleted_count": deleted_count
        }
    finally:
        db.close()


@celery_app.task(name='send_report_notifications')
def send_report_notifications_task(report_type: str, hostel_id: int, recipients: list):
    """
    Send email notifications for generated reports
    """
    # Placeholder for email notification logic
    print(f"Sending {report_type} report notifications for hostel {hostel_id}")
    print(f"Recipients: {recipients}")
    
    return {
        "status": "success",
        "report_type": report_type,
        "hostel_id": hostel_id,
        "recipients_count": len(recipients)
    }


# Scheduled tasks configuration
@celery_app.on_after_configure.connect
def setup_periodic_tasks(sender, **kwargs):
    """
    Setup periodic tasks for automatic report generation
    """
    
    # Generate daily reports every day at 11:59 PM
    sender.add_periodic_task(
        crontab(hour=23, minute=59),
        generate_daily_report_task.s(),
        name='daily-reports-generation'
    )
    
    # Generate weekly reports every Monday at 1:00 AM
    sender.add_periodic_task(
        crontab(hour=1, minute=0, day_of_week=1),
        generate_weekly_report_task.s(),
        name='weekly-reports-generation'
    )
    
    # Generate monthly reports on the 1st of each month at 2:00 AM
    sender.add_periodic_task(
        crontab(hour=2, minute=0, day_of_month=1),
        generate_monthly_report_task.s(),
        name='monthly-reports-generation'
    )
    
    # Cleanup old reports every Sunday at 3:00 AM
    sender.add_periodic_task(
        crontab(hour=3, minute=0, day_of_week=0),
        cleanup_old_reports_task.s(),
        name='cleanup-old-reports'
    )


# Helper function to schedule ad-hoc report generation
def schedule_report_generation(report_type: str, **kwargs):
    """
    Schedule a report generation task
    """
    if report_type == 'daily':
        return generate_daily_report_task.delay(
            kwargs.get('hostel_id'),
            kwargs.get('report_date')
        )
    elif report_type == 'weekly':
        return generate_weekly_report_task.delay(
            kwargs.get('hostel_id'),
            kwargs.get('week_start')
        )
    elif report_type == 'monthly':
        return generate_monthly_report_task.delay(
            kwargs.get('hostel_id'),
            kwargs.get('month'),
            kwargs.get('year')
        )
    elif report_type == 'super_admin':
        return generate_super_admin_report_task.delay(
            kwargs.get('start_date'),
            kwargs.get('end_date')
        )
    else:
        raise ValueError(f"Unknown report type: {report_type}")

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tasks\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tasks\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\conftest.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_audit_logging.py ---
"""
Verify audit logs created
"""
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)


def test_audit_log_creation():
    """Test audit log creation"""
    pass


def test_audit_log_filtering():
    """Test audit log filtering"""
    pass


def test_audit_log_access():
    """Test audit log access control"""
    pass



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_auth.py ---
"""
Test JWT + refresh
"""
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)


def test_register_user():
    """Test user registration"""
    response = client.post(
        "/api/v1/auth/register",
        json={
            "email": "test@example.com",
            "username": "testuser",
            "password": "testpass123",
            "full_name": "Test User",
            "role": "visitor"
        }
    )
    assert response.status_code == 201
    assert "id" in response.json()
    assert response.json()["email"] == "test@example.com"


def test_login():
    """Test user login"""
    # First register
    client.post(
        "/api/v1/auth/register",
        json={
            "email": "login@example.com",
            "username": "loginuser",
            "password": "testpass123",
            "role": "visitor"
        }
    )
    
    # Then login
    response = client.post(
        "/api/v1/auth/login",
        json={
            "username": "loginuser",
            "password": "testpass123"
        }
    )
    assert response.status_code == 200
    assert "access_token" in response.json()
    assert "refresh_token" in response.json()


def test_refresh_token():
    """Test token refresh"""
    # Register and login first
    client.post(
        "/api/v1/auth/register",
        json={
            "email": "refresh@example.com",
            "username": "refreshuser",
            "password": "testpass123",
            "role": "visitor"
        }
    )
    
    login_response = client.post(
        "/api/v1/auth/login",
        json={
            "username": "refreshuser",
            "password": "testpass123"
        }
    )
    refresh_token = login_response.json()["refresh_token"]
    
    # Refresh access token
    response = client.post(
        "/api/v1/auth/refresh",
        json={"refresh_token": refresh_token}
    )
    assert response.status_code == 200
    assert "access_token" in response.json()



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_booking_flow.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_multi_tenant.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_payment.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_permissions.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_rbac.py ---
"""
Test role access matrix
"""
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)


def test_role_permissions():
    """Test role-based permissions"""
    # This would require setting up test database and users
    pass


def test_role_hierarchy():
    """Test role hierarchy enforcement"""
    pass


def test_permission_check():
    """Test permission checking"""
    pass



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_session_api.py ---
"""
Test session switching APIs
"""
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)


def test_switch_session():
    """Test switching active hostel session"""
    pass


def test_get_active_session():
    """Test getting active session"""
    pass


def test_recent_sessions():
    """Test getting recent sessions"""
    pass



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_supervisor_delegation.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_supervisor_permission.py ---
"""
Test permission engine
"""
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)


def test_supervisor_permission_check():
    """Test supervisor permission checking"""
    pass


def test_permission_engine():
    """Test permission engine logic"""
    pass


def test_hierarchical_overrides():
    """Test hierarchical permission overrides"""
    pass



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\test_tenant_filter.py ---
"""
Test multi-hostel restrictions
"""
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)


def test_hostel_access_validation():
    """Test hostel access validation"""
    pass


def test_multi_hostel_admin():
    """Test multi-hostel admin access"""
    pass


def test_tenant_filtering():
    """Test tenant filtering middleware"""
    pass



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\tests\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils =====

# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\constants.py ---
"""
Role & permission constants
"""
from app.core.roles import Role
from app.core.permissions import Permission

# Export all roles
ALL_ROLES = [role.value for role in Role]

# Export all permissions
ALL_PERMISSIONS = [
    Permission.CREATE_USER,
    Permission.READ_USER,
    Permission.UPDATE_USER,
    Permission.DELETE_USER,
    Permission.CREATE_HOSTEL,
    Permission.READ_HOSTEL,
    Permission.UPDATE_HOSTEL,
    Permission.DELETE_HOSTEL,
    Permission.SWITCH_SESSION,
    Permission.VIEW_SESSION,
    Permission.VIEW_AUDIT,
    Permission.CREATE_AUDIT,
    Permission.MANAGE_PERMISSIONS,
    Permission.ASSIGN_ROLE,
    # Additional domain permissions
    Permission.EXPORT_AUDIT,
    Permission.EXPORT_REPORTS,
    Permission.MANAGE_SUBSCRIPTIONS,
    Permission.VIEW_PAYMENTS,
    Permission.MANAGE_PAYMENTS,
    Permission.MANAGE_SUPERVISORS,
    Permission.MANAGE_HOSTEL_CONFIG,
    Permission.MANAGE_ATTENDANCE,
    Permission.MANAGE_COMPLAINTS,
    Permission.MANAGE_MAINTENANCE,
    Permission.MANAGE_ANNOUNCEMENTS,
    Permission.INITIATE_BOOKING,
    Permission.CREATE_REGISTRATION,
    Permission.VIEW_OWN_PROFILE,
    Permission.VIEW_HOSTEL_ANNOUNCEMENTS,
]



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\date_utils.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\email_utilss.py ---
import os
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig

EMAIL_CONFIG = ConnectionConfig(
    MAIL_USERNAME=os.getenv("MAIL_USERNAME", "your-email@gmail.com"),
    MAIL_PASSWORD=os.getenv("MAIL_PASSWORD", "app-password"),
    MAIL_FROM=os.getenv("MAIL_FROM", "noreply@hostelpay.com"),
    MAIL_PORT=int(os.getenv("MAIL_PORT", 587)),
    MAIL_SERVER=os.getenv("MAIL_SERVER", "smtp.gmail.com"),
    MAIL_STARTTLS=True,
    MAIL_SSL_TLS=False,
    USE_CREDENTIALS=True
)

fast_mail = FastMail(EMAIL_CONFIG)

async def send_email_reminder(email: str, subject: str, body: str) -> bool:
    try:
        message = MessageSchema(subject=subject, recipients=[email], body=body, subtype="html")
        await fast_mail.send_message(message)
        return True
    except Exception as e:
        print("Email send failed:", e)
        return False


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\encryption.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\enums.py ---
"""
Enum for roles, permissions
"""
from enum import Enum
from app.core.roles import Role
from app.core.permissions import Permission


class UserRole(str, Enum):
    """User role enumeration"""
    SUPERADMIN = Role.SUPERADMIN
    ADMIN = Role.ADMIN
    SUPERVISOR = Role.SUPERVISOR
    STUDENT = Role.STUDENT
    VISITOR = Role.VISITOR


class UserPermission(str, Enum):
    """User permission enumeration"""
    CREATE_USER = Permission.CREATE_USER
    READ_USER = Permission.READ_USER
    UPDATE_USER = Permission.UPDATE_USER
    DELETE_USER = Permission.DELETE_USER
    CREATE_HOSTEL = Permission.CREATE_HOSTEL
    READ_HOSTEL = Permission.READ_HOSTEL
    UPDATE_HOSTEL = Permission.UPDATE_HOSTEL
    DELETE_HOSTEL = Permission.DELETE_HOSTEL
    SWITCH_SESSION = Permission.SWITCH_SESSION
    VIEW_SESSION = Permission.VIEW_SESSION
    VIEW_AUDIT = Permission.VIEW_AUDIT
    CREATE_AUDIT = Permission.CREATE_AUDIT
    MANAGE_PERMISSIONS = Permission.MANAGE_PERMISSIONS
    ASSIGN_ROLE = Permission.ASSIGN_ROLE
    EXPORT_AUDIT = Permission.EXPORT_AUDIT
    EXPORT_REPORTS = Permission.EXPORT_REPORTS
    MANAGE_SUBSCRIPTIONS = Permission.MANAGE_SUBSCRIPTIONS
    VIEW_PAYMENTS = Permission.VIEW_PAYMENTS
    MANAGE_PAYMENTS = Permission.MANAGE_PAYMENTS
    MANAGE_SUPERVISORS = Permission.MANAGE_SUPERVISORS
    MANAGE_HOSTEL_CONFIG = Permission.MANAGE_HOSTEL_CONFIG
    MANAGE_ATTENDANCE = Permission.MANAGE_ATTENDANCE
    MANAGE_COMPLAINTS = Permission.MANAGE_COMPLAINTS
    MANAGE_MAINTENANCE = Permission.MANAGE_MAINTENANCE
    MANAGE_ANNOUNCEMENTS = Permission.MANAGE_ANNOUNCEMENTS
    INITIATE_BOOKING = Permission.INITIATE_BOOKING
    CREATE_REGISTRATION = Permission.CREATE_REGISTRATION
    VIEW_OWN_PROFILE = Permission.VIEW_OWN_PROFILE
    VIEW_HOSTEL_ANNOUNCEMENTS = Permission.VIEW_HOSTEL_ANNOUNCEMENTS



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\file_utils.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\formatters.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\helpers.py ---
"""
Utility helpers for JWT decoding, extracting roles, user/hostel IDs,
and OTP expiry calculations.
"""

from typing import Optional, Dict
from datetime import datetime, timedelta

from app.core.security import decode_token
from app.config import settings


# =====================================================================
# 🔐 JWT DECODE HELPERS
# =====================================================================

def decode_jwt_token(token: str) -> Optional[Dict]:
    """Decode JWT token and return payload safely"""
    try:
        return decode_token(token)
    except Exception:
        return None


def extract_role_from_token(token: str) -> Optional[str]:
    """Extract role from JWT token"""
    payload = decode_jwt_token(token)
    return payload.get("role") if payload else None


def extract_user_id_from_token(token: str) -> Optional[int]:
    """Extract user ID from JWT token"""
    payload = decode_jwt_token(token)
    return payload.get("sub") if payload else None


def extract_hostel_id_from_token(token: str) -> Optional[int]:
    """Extract hostel_id from JWT token"""
    payload = decode_jwt_token(token)
    return payload.get("hostel_id") if payload else None


# =====================================================================
# 🔐 OTP EXPIRY HELPER
# =====================================================================

def otp_expiry_time(minutes: int = None) -> datetime:
    """Calculate OTP expiration time"""
    expiry_minutes = minutes or settings.OTP_EXPIRE_MINUTES
    return datetime.utcnow() + timedelta(minutes=expiry_minutes)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\helperss.py ---
import hmac, hashlib, uuid
from datetime import datetime
from app.config import settings

def generate_order_id():
    return f"ORD_{datetime.utcnow().strftime('%Y%m%d')}_{uuid.uuid4().hex[:8].upper()}"

def verify_razorpay_signature(order_id: str, payment_id: str, signature: str) -> bool:
    message = f"{order_id}|{payment_id}"
    generated_signature = hmac.new(
        settings.RAZORPAY_KEY_SECRET.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(generated_signature, signature)

def verify_webhook_signature(payload: bytes, signature: str) -> bool:
    expected = hmac.new(
        settings.RAZORPAY_WEBHOOK_SECRET.encode(),
        payload,
        hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(expected, signature)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\invoice.py ---
import os
import datetime
import random
from reportlab.pdfgen import canvas

INVOICE_DIR = os.path.join(os.getcwd(), "invoices")
os.makedirs(INVOICE_DIR, exist_ok=True)


def generate_booking_reference() -> str:
    date_str = datetime.datetime.now().strftime("%Y%m%d")
    random_str = str(random.randint(1000, 9999))
    return f"BK-{date_str}-{random_str}"


def generate_invoice(file_path: str, booking_ref: str, amount: float, user_name: str):
    c = canvas.Canvas(file_path)
    c.drawString(100, 750, f"Invoice for Booking: {booking_ref}")
    c.drawString(100, 730, f"Name: {user_name}")
    c.drawString(100, 710, f"Amount Paid: ₹{amount}")
    c.save()
    return file_path


def send_email_simulation(to_email: str, booking_ref: str, amount: float):
    # Simulated email send (replace with real integration later)
    print(f"[EMAIL] Sent to {to_email}: Booking {booking_ref}, Amount ₹{amount}")


def send_sms_simulation(phone: str, booking_ref: str, amount: float):
    # Simulated SMS send (replace with real integration later)
    print(f"[SMS] Sent to {phone}: Booking {booking_ref}, Amount ₹{amount}")


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\logger.py ---
"""
Logging setup (loguru)
"""
import logging
import sys
from loguru import logger as loguru_logger


def setup_logger():
    """Setup logging with loguru"""
    loguru_logger.remove()
    loguru_logger.add(
        sys.stdout,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        level="INFO"
    )
    loguru_logger.add(
        "logs/app.log",
        rotation="10 MB",
        retention="10 days",
        level="DEBUG"
    )
    return loguru_logger



# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\password_strength.py ---
"""
Password strength checker
"""

import re
from typing import Dict

__all__ = ["check_password_strength"]


def check_password_strength(password: str) -> Dict:
    """
    Check password strength and return feedback.
    Returns example:
    {
        "strength": "weak" | "medium" | "strong",
        "score": 0-100,
        "feedback": [...]
    }
    """
    score = 0
    feedback = []

    # Length check
    if len(password) >= 12:
        score += 25
    elif len(password) >= 8:
        score += 15
        feedback.append("Use at least 12 characters for stronger security")
    else:
        feedback.append("Password must be at least 8 characters long")

    # Uppercase
    if re.search(r"[A-Z]", password):
        score += 15
    else:
        feedback.append("Add uppercase letters (A-Z)")

    # Lowercase
    if re.search(r"[a-z]", password):
        score += 15
    else:
        feedback.append("Add lowercase letters (a-z)")

    # Numbers
    if re.search(r"\d", password):
        score += 15
    else:
        feedback.append("Add numbers (0-9)")

    # Special characters
    if re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        score += 15
    else:
        feedback.append("Add special characters (!@#$%^&*)")

    # Variety bonus
    if len(set(password)) >= len(password) * 0.7:
        score += 10

    # Avoid common patterns
    common_patterns = ["123", "abc", "password", "qwerty"]
    if not any(pattern in password.lower() for pattern in common_patterns):
        score += 5

    # Strength level
    if score >= 80:
        strength = "strong"
    elif score >= 50:
        strength = "medium"
    else:
        strength = "weak"

    return {
        "strength": strength,
        "score": min(score, 100),
        "feedback": feedback or ["Password is strong!"]
    }


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\pdf_generator.py ---
def generate_confirmation_pdf(payment):
    html = f"""
    <!DOCTYPE html>
    <html>
    <body>
      <h2>Booking Payment Confirmation</h2>
      <p>Payment Reference: {payment.payment_reference}</p>
      <p>Amount: {payment.amount} {payment.currency}</p>
      <p>Payment Method: {payment.payment_method}</p>
      <p>Status: {payment.status}</p>
    </body>
    </html>
    """
    return html


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\receipt_generatorss.py ---
# app/utils/receipt_generator.py
import io, os, json
import qrcode
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.enums import TA_CENTER
from datetime import datetime

def generate_qr_code(data: str) -> io.BytesIO:
    qr = qrcode.QRCode(version=1, box_size=6, border=2)
    qr.add_data(data)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white")
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)
    return buf

def generate_receipt_pdf(receipt, invoice, transaction) -> str:
    os.makedirs("receipts", exist_ok=True)
    filename = f"receipts/receipt_{receipt.receipt_number}.pdf"
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=40, leftMargin=40, topMargin=40, bottomMargin=40)
    styles = getSampleStyleSheet()
    elements = []

    title_style = ParagraphStyle('Title', parent=styles['Heading1'], alignment=TA_CENTER, fontSize=18)
    elements.append(Paragraph("PAYMENT RECEIPT", title_style))
    elements.append(Spacer(1, 12))

    # Basic info table
    info = [
        ["Receipt No:", receipt.receipt_number],
        ["Date:", receipt.generated_at.strftime("%Y-%m-%d %H:%M:%S")],
        ["Invoice No:", invoice.invoice_number],
        ["Transaction ID:", transaction.transaction_id],
    ]
    table = Table(info, colWidths=[120, 360])
    table.setStyle(TableStyle([
        ('FONTNAME', (0,0), (-1,-1), 'Helvetica'),
        ('FONTSIZE', (0,0), (-1,-1), 10),
        ('VALIGN', (0,0), (-1,-1), 'TOP'),
        ('BOTTOMPADDING', (0,0), (-1,-1), 6),
    ]))
    elements.append(table)
    elements.append(Spacer(1, 12))

    # Items (if any)
    items = []
    try:
        items = json.loads(invoice.items) if invoice.items else []
    except Exception:
        items = []

    if items:
        rows = [["Description", "Qty", "Unit", "Amount"]]
        for it in items:
            rows.append([it.get("description",""), str(it.get("quantity",1)), f"₹{it.get('unit_price',0):.2f}", f"₹{it.get('amount',0):.2f}"])
        rows.append(["", "", "Total:", f"₹{invoice.total_amount:.2f}"])
        rows.append(["", "", "Paid:", f"₹{receipt.amount:.2f}"])
        rows.append(["", "", "Remaining:", f"₹{invoice.due_amount:.2f}"])
        t = Table(rows, colWidths=[260, 60, 80, 80])
        t.setStyle(TableStyle([
            ('BACKGROUND', (0,0), (-1,0), colors.HexColor('#1a73e8')),
            ('TEXTCOLOR', (0,0), (-1,0), colors.white),
            ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold'),
            ('ALIGN', (2,1), (-1,-1), 'RIGHT'),
            ('GRID', (0,0), (-1,-1), 0.3, colors.grey),
        ]))
        elements.append(t)
        elements.append(Spacer(1, 12))

    # QR
    qr_buf = generate_qr_code(receipt.qr_code_data or f"R:{receipt.receipt_number}|A:{receipt.amount}")
    img = Image(qr_buf, width=1.5*inch, height=1.5*inch)
    img.hAlign = 'CENTER'
    elements.append(img)
    elements.append(Spacer(1, 8))
    elements.append(Paragraph("Scan QR code to verify", styles['Normal']))
    elements.append(Spacer(1, 20))
    elements.append(Paragraph("This is a computer-generated receipt.", styles['Normal']))

    doc.build(elements)

    with open(filename, "wb") as f:
        f.write(buffer.getvalue())

    return filename


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\sms_utilss.py ---
import os
from twilio.rest import Client

TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
TWILIO_PHONE_NUMBER = os.getenv("TWILIO_PHONE_NUMBER")

twilio_client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN) if TWILIO_ACCOUNT_SID else None

def send_sms_reminder(phone: str, message: str) -> bool:
    if not twilio_client:
        print("Twilio not configured")
        return False
    try:
        if not phone.startswith("+"):
            phone = f"+91{phone}"
        msg = twilio_client.messages.create(body=message, from_=TWILIO_PHONE_NUMBER, to=phone)
        return msg.sid is not None
    except Exception as e:
        print("SMS send failed:", e)
        return False


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\template_utilss.py ---
from jinja2 import Template

def render_template(template_text: str, context: dict) -> str:
    template = Template(template_text)
    return template.render(**context)


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\util.py ---
# app/utils.py
from __future__ import annotations
from typing import Any, Callable, Dict, Iterable, List, Optional, Sequence, Tuple, Type, TypeVar, Union
from contextlib import contextmanager
from functools import wraps
from datetime import datetime, date, time
import csv
import io
import os
import tempfile

from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, SQLAlchemyError

T = TypeVar("T")

# -------------------------
# Database / transaction helpers
# -------------------------
def safe_commit(db: Session) -> None:
    """
    Try to commit the session; rollback on error and re-raise.
    Use this for short single-commit operations.
    """
    try:
        db.commit()
    except Exception:
        db.rollback()
        raise


@contextmanager
def db_transaction(db: Session):
    """
    Context manager for explicit transactions:
        with db_transaction(db):
            ... multiple repo operations ...
    Will rollback automatically on exception.
    """
    try:
        yield
        db.commit()
    except Exception:
        db.rollback()
        raise


def get_or_create(db: Session, model: Type[T], defaults: Optional[Dict[str, Any]] = None, **kwargs) -> Tuple[T, bool]:
    """
    Try to get an instance matching kwargs, otherwise create with defaults merged.
    Returns (instance, created_bool).
    Note: not atomic across processes (no DB lock) but fine for many use-cases.
    """
    instance = db.query(model).filter_by(**kwargs).first()
    if instance:
        return instance, False
    params = dict(kwargs)
    if defaults:
        params.update(defaults)
    instance = model(**params)
    db.add(instance)
    try:
        db.commit()
        db.refresh(instance)
        return instance, True
    except IntegrityError:
        db.rollback()
        # another thread/process created simultaneously — try to fetch again
        instance = db.query(model).filter_by(**kwargs).first()
        if instance:
            return instance, False
        raise


def retry_on_exception(retries: int = 3, exceptions: Tuple[Type[BaseException], ...] = (SQLAlchemyError,)):
    """
    Decorator to retry a function on transient exceptions (useful for flaky DB calls).
    """
    def decorator(fn: Callable[..., T]) -> Callable[..., T]:
        @wraps(fn)
        def wrapper(*args, **kwargs):
            last_exc = None
            for attempt in range(retries):
                try:
                    return fn(*args, **kwargs)
                except exceptions as e:
                    last_exc = e
            # no more retries
            raise last_exc
        return wrapper
    return decorator


# -------------------------
# Enum & conversion helpers
# -------------------------
def safe_enum_cast(enum_cls: Type[Enum], value: Any, fallback: Optional[Any] = None):
    """
    Convert a DB/stored string or enum to the enum_cls if possible, otherwise fallback.
    Example: safe_enum_cast(RoomType, "single")
    """
    if value is None:
        return fallback
    try:
        if isinstance(value, enum_cls):
            return value
        return enum_cls(value)
    except Exception:
        return fallback


# -------------------------
# Pagination helpers
# -------------------------
def paginate_list(items: Sequence[T], skip: int = 0, limit: int = 100) -> List[T]:
    if skip < 0:
        skip = 0
    if limit <= 0:
        limit = 100
    return list(items)[skip : skip + limit]


def make_pagination_response(items: Sequence[T], skip: int, limit: int, total: Optional[int] = None) -> Dict[str, Any]:
    return {
        "skip": skip,
        "limit": limit,
        "count": len(items),
        "total": total if total is not None else None,
        "items": items,
    }


# -------------------------
# Model <-> dict / schema helpers
# -------------------------
def model_to_dict(obj: Any, include: Optional[Iterable[str]] = None, exclude: Optional[Iterable[str]] = None) -> Dict[str, Any]:
    """
    Convert a SQLAlchemy model instance to dict using attribute access.
    Avoids importing SQLAlchemy internals; assumes simple scalar/enum/date attributes.
    """
    data: Dict[str, Any] = {}
    exclude = set(exclude or [])
    include = set(include) if include is not None else None

    for attr in getattr(obj, "__table__", obj.__class__).__dict__.keys() if hasattr(obj, "__table__") else vars(obj).keys():
        # fallback: iterate public attributes
        pass  # we'll use attributes list below

    # safer: iterate __dict__ for normal attributes, and fallback to dir for properties
    for k in vars(obj).keys():
        if k.startswith("_"):
            continue
        if include is not None and k not in include:
            continue
        if k in exclude:
            continue
        try:
            val = getattr(obj, k)
            # convert datetime/date to isoformat for JSON friendliness
            if isinstance(val, datetime):
                val = val.isoformat()
            elif isinstance(val, date):
                val = val.isoformat()
            data[k] = val
        except Exception:
            continue
    return data


def apply_updates_from_schema(instance: Any, schema_obj: Any, exclude: Optional[Iterable[str]] = None) -> Any:
    """
    Apply attributes from a Pydantic schema (or dict-like) to a SQLAlchemy model instance.
    Only sets attributes present in schema_obj (use .dict(exclude_unset=True) before passing if needed).
    Returns the instance (convenience).
    """
    exclude = set(exclude or [])
    if hasattr(schema_obj, "dict"):
        payload = schema_obj.dict(exclude_unset=True)
    elif isinstance(schema_obj, dict):
        payload = schema_obj
    else:
        # fallback: try to iterate attributes
        payload = {k: getattr(schema_obj, k) for k in dir(schema_obj) if not k.startswith("_")}
    for k, v in payload.items():
        if k in exclude:
            continue
        if hasattr(instance, k):
            setattr(instance, k, v)
    return instance


# -------------------------
# Amenities parsing utilities
# -------------------------
def split_amenities(raw: Optional[str]) -> List[str]:
    """
    Convert a comma-separated amenities string into cleaned list of names.
    """
    if not raw:
        return []
    parts = [p.strip() for p in raw.split(",")]
    return [p for p in parts if p]


def merge_amenities(items: Iterable[str]) -> str:
    """
    Merge an iterable of amenities into a comma-separated canonical string.
    """
    cleaned = [i.strip() for i in items if i and i.strip()]
    # drop duplicates while preserving order
    seen = set()
    out = []
    for a in cleaned:
        if a.lower() not in seen:
            seen.add(a.lower())
            out.append(a)
    return ", ".join(out)


# -------------------------
# CSV import/export helpers (rooms / beds / students)
# -------------------------
def csv_to_dicts(csv_bytes: Union[bytes, str], delimiter: str = ",") -> List[Dict[str, str]]:
    """
    Parse CSV bytes/string to list of row dicts using first row as header.
    Useful for simple bulk imports (rooms/beds/students).
    """
    if isinstance(csv_bytes, bytes):
        csv_str = csv_bytes.decode("utf-8")
    else:
        csv_str = csv_bytes
    f = io.StringIO(csv_str)
    reader = csv.DictReader(f, delimiter=delimiter)
    return [dict(row) for row in reader]


def dicts_to_csv(rows: Iterable[Dict[str, Any]], fieldnames: Optional[List[str]] = None) -> str:
    """
    Convert an iterable of dicts to CSV string. If fieldnames not provided, use keys from first row.
    """
    rows = list(rows)
    if not rows:
        return ""
    if fieldnames is None:
        # preserve insertion order of keys from first dict
        fieldnames = list(rows[0].keys())
    f = io.StringIO()
    writer = csv.DictWriter(f, fieldnames=fieldnames)
    writer.writeheader()
    for r in rows:
        # ensure values are simple types
        writer.writerow({k: (v if v is not None else "") for k, v in r.items()})
    return f.getvalue()


# -------------------------
# File helpers for student documents
# -------------------------
STUDENT_DOCS_DIR = os.getenv("STUDENT_DOCS_DIR", os.path.join(tempfile.gettempdir(), "student_docs"))

def ensure_student_docs_dir():
    os.makedirs(STUDENT_DOCS_DIR, exist_ok=True)


def save_student_document(student_id: str, filename: str, content: bytes) -> str:
    """
    Save a student document to STUDENT_DOCS_DIR/<student_id>/<filename>
    Returns the relative file path.
    """
    ensure_student_docs_dir()
    student_dir = os.path.join(STUDENT_DOCS_DIR, student_id)
    os.makedirs(student_dir, exist_ok=True)
    safe_name = filename.replace("/", "_").replace("\\", "_")
    path = os.path.join(student_dir, safe_name)
    with open(path, "wb") as f:
        f.write(content)
    return path


def remove_student_document(path: str) -> bool:
    try:
        os.remove(path)
        return True
    except FileNotFoundError:
        return False


# -------------------------
# Small helpers used by services
# -------------------------
def calculate_pricing_stats(prices: Iterable[Optional[float]]) -> Tuple[Optional[float], Optional[float], Optional[float]]:
    """
    Accepts an iterable of numbers / None and returns (min, avg, max) or (None, None, None)
    if no valid numbers present.
    """
    vals = [float(v) for v in prices if v is not None]
    if not vals:
        return None, None, None
    mn = min(vals)
    mx = max(vals)
    avg = sum(vals) / len(vals)
    return mn, avg, mx


def coerce_date(val: Any) -> Optional[date]:
    """
    Try to coerce common inputs into a date object; return None when not possible.
    Accepts date, datetime, ISO string.
    """
    if val is None:
        return None
    if isinstance(val, date) and not isinstance(val, datetime):
        return val
    if isinstance(val, datetime):
        return val.date()
    if isinstance(val, str):
        for fmt in ("%Y-%m-%d", "%d-%m-%Y", "%Y/%m/%d"):
            try:
                return datetime.strptime(val, fmt).date()
            except Exception:
                continue
    return None


def coerce_time(val: Any) -> Optional[time]:
    """
    Try to coerce to time object.
    """
    if val is None:
        return None
    if isinstance(val, time):
        return val
    if isinstance(val, datetime):
        return val.time()
    if isinstance(val, str):
        for fmt in ("%H:%M:%S", "%H:%M"):
            try:
                return datetime.strptime(val, fmt).time()
            except Exception:
                continue
    return None


# -------------------------
# Validation helpers
# -------------------------
def validate_hostel_ids(hostel_ids: Sequence[str], max_items: int = 4) -> None:
    if not hostel_ids:
        raise ValueError("Provide at least one hostel id")
    if len(hostel_ids) > max_items:
        raise ValueError(f"You can compare up to {max_items} hostels")


# -------------------------
# Lightweight notification/email stub (replace with real service)
# -------------------------
def notify_supervisor_assignment(supervisor_email: str, hostel_id: str) -> None:
    """
    Stub for notifying a supervisor — replace with real mailer or messaging.
    """
    # Keep this a no-op in tests; log or hook into actual email sender in production.
    print(f"[notify] would send email to {supervisor_email}: assigned to {hostel_id}")


# -------------------------
# Misc small helpers
# -------------------------
def safe_int(v: Any, default: Optional[int] = None) -> Optional[int]:
    try:
        return int(v)
    except Exception:
        return default


def safe_float(v: Any, default: Optional[float] = None) -> Optional[float]:
    try:
        return float(v)
    except Exception:
        return default


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\utils.py ---
import io
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import pandas as pd
from openpyxl import Workbook

def generate_pdf_report(data: dict) -> io.BytesIO:
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    c.setFont("Helvetica", 12)

    y = 750
    c.drawString(50, y, f"Report: {data.get('name', 'Unnamed')}")
    y -= 30

    result_data = data.get("result_data", {})

    # Summary section
    summary = result_data.get("summary", {})
    c.drawString(50, y, "Summary:")
    y -= 20
    for k, v in summary.items():
        c.drawString(60, y, f"{k}: {v}")
        y -= 18

    # Add some spacing before next section
    y -= 20

    # By Hostel section
    by_hostel = result_data.get("by_hostel", [])
    if by_hostel:
        c.drawString(50, y, "By Hostel:")
        y -= 20
        headers = list(by_hostel[0].keys())
        header_line = " | ".join(headers)
        c.drawString(60, y, header_line)
        y -= 18

        for row in by_hostel:
            line = " | ".join(str(row.get(h, "")) for h in headers)
            c.drawString(60, y, line[:100])  # limit line width
            y -= 18
            if y < 50:
                c.showPage()
                c.setFont("Helvetica", 12)
                y = 750

    c.save()
    buffer.seek(0)
    return buffer


def generate_csv_report(data: dict) -> io.BytesIO:
    summary = data.get("result_data", {}).get("summary", {})
    by_hostel = data.get("result_data", {}).get("by_hostel", [])

    csv_buffer = io.StringIO()

    # Write summary as key-value pairs
    if summary:
        df_summary = pd.DataFrame([summary])
        df_summary = df_summary.melt(var_name="Key", value_name="Value")  # reshape to two columns
        df_summary.to_csv(csv_buffer, index=False)
        csv_buffer.write("\n")  # blank line between tables

    # Write by_hostel table
    if by_hostel:
        df_hostel = pd.DataFrame(by_hostel)
        df_hostel.to_csv(csv_buffer, index=False)

    bytes_buffer = io.BytesIO(csv_buffer.getvalue().encode("utf-8"))
    bytes_buffer.seek(0)
    return bytes_buffer


def generate_excel_report(data: dict) -> io.BytesIO:
    wb = Workbook()
    
    # Summary sheet
    ws_summary = wb.active
    ws_summary.title = "Summary"
    summary = data.get("result_data", {}).get("summary", {})
    ws_summary.append(["Key", "Value"])
    for k, v in summary.items():
        ws_summary.append([k, v])

    # By Hostel sheet
    by_hostel = data.get("result_data", {}).get("by_hostel", [])
    ws_hostel = wb.create_sheet(title="By Hostel")
    if by_hostel:
        headers = list(by_hostel[0].keys())
        ws_hostel.append(headers)
        for row in by_hostel:
            ws_hostel.append([row.get(h, "") for h in headers])
    else:
        ws_hostel.append(["No data available"])

    buffer = io.BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    return buffer


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\validators.py ---


# --- File: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\__init__.py ---



# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\utils\__pycache__ =====


# ===== Folder: D:\Last Github Push\Last Github Push\hostel_backend-main\app\__pycache__ =====
